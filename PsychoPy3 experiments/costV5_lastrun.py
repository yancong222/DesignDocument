#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2021.1.3),
    on Mon Apr 26 16:16:26 2021
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

from __future__ import absolute_import, division

from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

from psychopy.hardware import keyboard



# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

# Store info about the experiment session
psychopyVersion = '2021.1.3'
expName = 'pilot2exp_keyboard'  # from the Builder filename that created this script
expInfo = {'participant': '', 'session': '001'}
dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    originPath='/Users/yancong/Desktop/00 Grice-hen/06 exp/PsychoPy3 experiments/costV5_lastrun.py',
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.DEBUG)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run after the window creation

# Setup the Window
win = visual.Window(
    size=[1440, 900], fullscr=True, screen=0, 
    winType='pyglet', allowGUI=False, allowStencil=False,
    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
    blendMode='avg', useFBO=True, 
    units='height')
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard()

# Initialize components for Routine "intro"
introClock = core.Clock()
welcome = visual.TextStim(win=win, name='welcome',
    text='Please consider this information carefully before deciding whether to participate in this research:\n\nWe invite you to participate in a research study related to language.\n\nIf you have read this form and have decided to participate in this experiment, please understand your participation is voluntary and you have the right to withdraw your consent or discontinue participation at any time. However, please note that in order to validate your participation you need to complete the experiment and wait until the results are sent (this should only take a few seconds); otherwise, we have no way to ensure that you participated at all. There are no risks or benefits of any kind involved in this study. You will be paid for your participation at the posted rate.\n\nYour participation in this study will remain confidential. Your individual privacy will be maintained in all published and written data resulting from the study. You may print this form for your records.\n\nPress space bar to continue.',
    font='Arial',
    units='norm', pos=(0, 0), height=0.06, wrapWidth=None, ori=0, 
    color='white', colorSpace='rgb', opacity=1, 
    languageStyle='LTR',
    depth=0.0);
key_resp = keyboard.Keyboard()

# Initialize components for Routine "Iunderstand"
IunderstandClock = core.Clock()
text_9 = visual.TextStim(win=win, name='text_9',
    text='I understand and accept these terms. \n\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_5 = keyboard.Keyboard()

# Initialize components for Routine "blank"
blankClock = core.Clock()
blank500ms = visual.TextStim(win=win, name='blank500ms',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "instruction"
instructionClock = core.Clock()
text_2 = visual.TextStim(win=win, name='text_2',
    text='Suppose you are on Mars, and in order to communicte with aliens, you will learn their language. You will learn by feedback. You will see displays with fake words. They are used for describing colors and shapes, which are illustrated by the images.\n\nBelow is a group of word and images. Your task is to guess the meaning and to decide which image the word refers to.\n\nExample: word "bos". It can be USED BY ITSELF to refer to an object.',
    font='Open Sans',
    pos=(0, 0.3), height=0.02, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
polygon = visual.Polygon(
    win=win, name='polygon',
    edges=5, size=(0.1, 0.1),
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
polygonblack = visual.Polygon(
    win=win, name='polygonblack',
    edges=5, size=(0.1, 0.1),
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='black',
    opacity=None, depth=-2.0, interpolate=True)
text_3 = visual.TextStim(win=win, name='text_3',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.1), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_4 = visual.TextStim(win=win, name='text_4',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.1), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_6 = visual.TextStim(win=win, name='text_6',
    text='For this example, suppose "bos" means empty or white, when you TYPE 1 on your keyboard, you receive feedback "Correct".\n\nFor the learning part, you will receive prompts "Correct"/"Incorrect". Sometimes you will be tested on the words you have learned. You will not receive any feedback.\n\nSometimes, the task will seem very easy. Sometimes, it will seem trickier if not entirely arbitrary. This is not an IQ test and there may not always be a proper, unambiguous answer. What matters the most to us is that you follow your instinct and report your intuition, especially in these cases where it seems that you have to guess.\n\nPress SPACE bar to start the Practice.\n',
    font='Open Sans',
    pos=(0, -0.3), height=0.02, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_2 = keyboard.Keyboard()
text_7 = visual.TextStim(win=win, name='text_7',
    text='bos',
    font='Open Sans',
    pos=(0, 0.1), height=0.03, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "start_practice"
start_practiceClock = core.Clock()
text_8 = visual.TextStim(win=win, name='text_8',
    text='Press SPACE bar to start the PRACTICE.',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_4 = keyboard.Keyboard()

# Initialize components for Routine "start_2"
start_2Clock = core.Clock()
text1 = visual.TextStim(win=win, name='text1',
    text='Please TYPE your answer using  keyboard.\n\nAllowed Keys: 1, 2, 3\n\nYou will receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='purple', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_7 = keyboard.Keyboard()

# Initialize components for Routine "bosap1"
bosap1Clock = core.Clock()
key_resp_bosa_2 = keyboard.Keyboard()
number_correct_bosap=0
blicket1_14 = visual.TextStim(win=win, name='blicket1_14',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option1_critical_17 = visual.TextStim(win=win, name='option1_critical_17',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
option2_critical_17 = visual.TextStim(win=win, name='option2_critical_17',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
bosa3_2 = visual.TextStim(win=win, name='bosa3_2',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
polygon_8 = visual.Polygon(
    win=win, name='polygon_8',
    edges=5, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-6.0, interpolate=True)
polygon_9 = visual.Polygon(
    win=win, name='polygon_9',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-7.0, interpolate=True)
polygon_10 = visual.Polygon(
    win=win, name='polygon_10',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-8.0, interpolate=True)

# Initialize components for Routine "fb_bosap1"
fb_bosap1Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1_4 = visual.TextStim(win=win, name='feedback1_zud1_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1_4 = visual.TextStim(win=win, name='feedback0_zud1_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01_4 = visual.TextStim(win=win, name='feedback_zud01_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "bosap2"
bosap2Clock = core.Clock()
key_resp_bosa_3 = keyboard.Keyboard()
blicket1_15 = visual.TextStim(win=win, name='blicket1_15',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option1_critical_18 = visual.TextStim(win=win, name='option1_critical_18',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
option2_critical_18 = visual.TextStim(win=win, name='option2_critical_18',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
bosa3_3 = visual.TextStim(win=win, name='bosa3_3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
polygon_11 = visual.Polygon(
    win=win, name='polygon_11',
    edges=5, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-6.0, interpolate=True)
polygon_12 = visual.Polygon(
    win=win, name='polygon_12',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-7.0, interpolate=True)
polygon_13 = visual.Polygon(
    win=win, name='polygon_13',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-8.0, interpolate=True)

# Initialize components for Routine "fb_bosap2"
fb_bosap2Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1_5 = visual.TextStim(win=win, name='feedback1_zud1_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1_5 = visual.TextStim(win=win, name='feedback0_zud1_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01_5 = visual.TextStim(win=win, name='feedback_zud01_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "proceed"
proceedClock = core.Clock()
text2 = visual.TextStim(win=win, name='text2',
    text='You will NOT receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='darkorange', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "bosap_test"
bosap_testClock = core.Clock()
key_resp_bosa_4 = keyboard.Keyboard()
blicket1_16 = visual.TextStim(win=win, name='blicket1_16',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
option1_critical_19 = visual.TextStim(win=win, name='option1_critical_19',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option2_critical_19 = visual.TextStim(win=win, name='option2_critical_19',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
bosa3_4 = visual.TextStim(win=win, name='bosa3_4',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
polygon_14 = visual.Polygon(
    win=win, name='polygon_14',
    edges=5, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-5.0, interpolate=True)
polygon_15 = visual.Polygon(
    win=win, name='polygon_15',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-6.0, interpolate=True)
polygon_16 = visual.Polygon(
    win=win, name='polygon_16',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-7.0, interpolate=True)

# Initialize components for Routine "practice_trial_end"
practice_trial_endClock = core.Clock()
text_5 = visual.TextStim(win=win, name='text_5',
    text='This is the end of the practice! \n\nNow let’s start the real experiment!\n\nPress spacebar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.04, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_3 = keyboard.Keyboard()

# Initialize components for Routine "phase1"
phase1Clock = core.Clock()
text = visual.TextStim(win=win, name='text',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='blue', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "start_2"
start_2Clock = core.Clock()
text1 = visual.TextStim(win=win, name='text1',
    text='Please TYPE your answer using  keyboard.\n\nAllowed Keys: 1, 2, 3\n\nYou will receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='purple', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_7 = keyboard.Keyboard()

# Initialize components for Routine "blank"
blankClock = core.Clock()
blank500ms = visual.TextStim(win=win, name='blank500ms',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "zud1"
zud1Clock = core.Clock()
zud1_corr2 = visual.TextStim(win=win, name='zud1_corr2',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_1 = visual.ShapeStim(
    win=win, name='star_1', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triangle_1 = visual.ShapeStim(
    win=win, name='triangle_1',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_1 = visual.ShapeStim(
    win=win, name='cross_1', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
option1_01 = visual.TextStim(win=win, name='option1_01',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_01 = visual.TextStim(win=win, name='option2_01',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_01 = visual.TextStim(win=win, name='option3_01',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
key_resp_zud1 = keyboard.Keyboard()

# Initialize components for Routine "fb_zud1"
fb_zud1Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1 = visual.TextStim(win=win, name='feedback1_zud1',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1 = visual.TextStim(win=win, name='feedback0_zud1',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01 = visual.TextStim(win=win, name='feedback_zud01',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud2"
zud2Clock = core.Clock()
zud2_corr1 = visual.TextStim(win=win, name='zud2_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_2 = visual.ShapeStim(
    win=win, name='triangle_2',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_2 = visual.ShapeStim(
    win=win, name='star_2', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_2 = visual.ShapeStim(
    win=win, name='cross_2', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud2 = keyboard.Keyboard()
option1_02 = visual.TextStim(win=win, name='option1_02',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_02 = visual.TextStim(win=win, name='option2_02',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_02 = visual.TextStim(win=win, name='option3_02',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud2"
fb_zud2Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud2 = visual.TextStim(win=win, name='feedback1_zud2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud2 = visual.TextStim(win=win, name='feedback0_zud2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud02 = visual.TextStim(win=win, name='feedback_zud02',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud3"
zud3Clock = core.Clock()
zud3_corr1 = visual.TextStim(win=win, name='zud3_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_3 = visual.ShapeStim(
    win=win, name='triangle_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_3 = visual.ShapeStim(
    win=win, name='star_3', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_3 = visual.ShapeStim(
    win=win, name='cross_3', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud3 = keyboard.Keyboard()
option1_03 = visual.TextStim(win=win, name='option1_03',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_03 = visual.TextStim(win=win, name='option2_03',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_03 = visual.TextStim(win=win, name='option3_03',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud3"
fb_zud3Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud3 = visual.TextStim(win=win, name='feedback1_zud3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud3 = visual.TextStim(win=win, name='feedback0_zud3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud03 = visual.TextStim(win=win, name='feedback_zud03',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud4"
zud4Clock = core.Clock()
zud4_corr1 = visual.TextStim(win=win, name='zud4_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_4 = visual.ShapeStim(
    win=win, name='triangle_4',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_4 = visual.ShapeStim(
    win=win, name='star_4', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_4 = visual.ShapeStim(
    win=win, name='cross_4', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud4 = keyboard.Keyboard()
option1_04 = visual.TextStim(win=win, name='option1_04',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_04 = visual.TextStim(win=win, name='option2_04',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_04 = visual.TextStim(win=win, name='option3_04',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud4"
fb_zud4Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud4 = visual.TextStim(win=win, name='feedback1_zud4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud4 = visual.TextStim(win=win, name='feedback0_zud4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud04 = visual.TextStim(win=win, name='feedback_zud04',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicket13"
blicket13Clock = core.Clock()
key_resp_blicket13 = keyboard.Keyboard()
blicket1 = visual.TextStim(win=win, name='blicket1',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w = visual.ShapeStim(
    win=win, name='blicket_st_w', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b = visual.ShapeStim(
    win=win, name='blicket_st_b',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
rec_bl_2 = visual.Rect(
    win=win, name='rec_bl_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='black',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_3 = visual.TextStim(win=win, name='option1_critical_3',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_3 = visual.TextStim(win=win, name='option2_critical_3',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
text3 = visual.TextStim(win=win, name='text3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_blicket13"
fb_blicket13Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_5 = visual.TextStim(win=win, name='feedback1_dax9_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_5 = visual.TextStim(win=win, name='feedback0_dax9_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_5 = visual.TextStim(win=win, name='feedback_dax9_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicket14"
blicket14Clock = core.Clock()
key_resp_blicket14 = keyboard.Keyboard()
blicket1_2 = visual.TextStim(win=win, name='blicket1_2',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_2 = visual.ShapeStim(
    win=win, name='blicket_st_w_2', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_2 = visual.Rect(
    win=win, name='blicket_st_b_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
w_triange = visual.ShapeStim(
    win=win, name='w_triange',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_4 = visual.TextStim(win=win, name='option1_critical_4',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_4 = visual.TextStim(win=win, name='option2_critical_4',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
bltext = visual.TextStim(win=win, name='bltext',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_blicket14"
fb_blicket14Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_6 = visual.TextStim(win=win, name='feedback1_dax9_6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_6 = visual.TextStim(win=win, name='feedback0_dax9_6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_6 = visual.TextStim(win=win, name='feedback_dax9_6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicket17"
smicket17Clock = core.Clock()
key_resp_smicket17 = keyboard.Keyboard()
blicket1_5 = visual.TextStim(win=win, name='blicket1_5',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_3 = visual.ShapeStim(
    win=win, name='blicket_st_w_3', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_3 = visual.ShapeStim(
    win=win, name='blicket_st_b_3', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
sm = visual.ShapeStim(
    win=win, name='sm',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_7 = visual.TextStim(win=win, name='option1_critical_7',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_7 = visual.TextStim(win=win, name='option2_critical_7',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
smtext = visual.TextStim(win=win, name='smtext',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_smicket17"
fb_smicket17Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_9 = visual.TextStim(win=win, name='feedback1_dax9_9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_9 = visual.TextStim(win=win, name='feedback0_dax9_9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_9 = visual.TextStim(win=win, name='feedback_dax9_9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicket18"
smicket18Clock = core.Clock()
key_resp_smicket18 = keyboard.Keyboard()
blicket1_6 = visual.TextStim(win=win, name='blicket1_6',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_4 = visual.ShapeStim(
    win=win, name='blicket_st_w_4', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_4 = visual.ShapeStim(
    win=win, name='blicket_st_b_4', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
sm2 = visual.ShapeStim(
    win=win, name='sm2',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_8 = visual.TextStim(win=win, name='option1_critical_8',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_8 = visual.TextStim(win=win, name='option2_critical_8',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
smtext2 = visual.TextStim(win=win, name='smtext2',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_smicket18"
fb_smicket18Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_10 = visual.TextStim(win=win, name='feedback1_dax9_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_10 = visual.TextStim(win=win, name='feedback0_dax9_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_10 = visual.TextStim(win=win, name='feedback_dax9_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "bosa1"
bosa1Clock = core.Clock()
key_resp_bosa = keyboard.Keyboard()
blicket1_11 = visual.TextStim(win=win, name='blicket1_11',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option1_critical_14 = visual.TextStim(win=win, name='option1_critical_14',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
option2_critical_14 = visual.TextStim(win=win, name='option2_critical_14',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
bosa3 = visual.TextStim(win=win, name='bosa3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
polygon_5 = visual.Polygon(
    win=win, name='polygon_5',
    edges=5, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-6.0, interpolate=True)
polygon_6 = visual.Polygon(
    win=win, name='polygon_6',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-7.0, interpolate=True)
polygon_7 = visual.Polygon(
    win=win, name='polygon_7',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-8.0, interpolate=True)

# Initialize components for Routine "fb_bosa1"
fb_bosa1Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1_2 = visual.TextStim(win=win, name='feedback1_zud1_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1_2 = visual.TextStim(win=win, name='feedback0_zud1_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01_2 = visual.TextStim(win=win, name='feedback_zud01_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "bosa2"
bosa2Clock = core.Clock()
key_resp_bosa2 = keyboard.Keyboard()
blicket1_13 = visual.TextStim(win=win, name='blicket1_13',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option1_critical_16 = visual.TextStim(win=win, name='option1_critical_16',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
option2_critical_16 = visual.TextStim(win=win, name='option2_critical_16',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
bosa2text2 = visual.TextStim(win=win, name='bosa2text2',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
polygon_2 = visual.Polygon(
    win=win, name='polygon_2',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-6.0, interpolate=True)
polygon_3 = visual.Polygon(
    win=win, name='polygon_3',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-7.0, interpolate=True)
polygon_4 = visual.Polygon(
    win=win, name='polygon_4',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-8.0, interpolate=True)

# Initialize components for Routine "fb_bosa2"
fb_bosa2Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1_3 = visual.TextStim(win=win, name='feedback1_zud1_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1_3 = visual.TextStim(win=win, name='feedback0_zud1_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01_3 = visual.TextStim(win=win, name='feedback_zud01_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "bosa1"
bosa1Clock = core.Clock()
key_resp_bosa = keyboard.Keyboard()
blicket1_11 = visual.TextStim(win=win, name='blicket1_11',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option1_critical_14 = visual.TextStim(win=win, name='option1_critical_14',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
option2_critical_14 = visual.TextStim(win=win, name='option2_critical_14',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
bosa3 = visual.TextStim(win=win, name='bosa3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
polygon_5 = visual.Polygon(
    win=win, name='polygon_5',
    edges=5, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-6.0, interpolate=True)
polygon_6 = visual.Polygon(
    win=win, name='polygon_6',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-7.0, interpolate=True)
polygon_7 = visual.Polygon(
    win=win, name='polygon_7',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-8.0, interpolate=True)

# Initialize components for Routine "fb_bosa1"
fb_bosa1Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1_2 = visual.TextStim(win=win, name='feedback1_zud1_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1_2 = visual.TextStim(win=win, name='feedback0_zud1_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01_2 = visual.TextStim(win=win, name='feedback_zud01_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "bosa2"
bosa2Clock = core.Clock()
key_resp_bosa2 = keyboard.Keyboard()
blicket1_13 = visual.TextStim(win=win, name='blicket1_13',
    text='bosa',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
option1_critical_16 = visual.TextStim(win=win, name='option1_critical_16',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
option2_critical_16 = visual.TextStim(win=win, name='option2_critical_16',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
bosa2text2 = visual.TextStim(win=win, name='bosa2text2',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
polygon_2 = visual.Polygon(
    win=win, name='polygon_2',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='purple',
    opacity=None, depth=-6.0, interpolate=True)
polygon_3 = visual.Polygon(
    win=win, name='polygon_3',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='gold',
    opacity=None, depth=-7.0, interpolate=True)
polygon_4 = visual.Polygon(
    win=win, name='polygon_4',
    edges=6, size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='grey',
    opacity=None, depth=-8.0, interpolate=True)

# Initialize components for Routine "fb_bosa2"
fb_bosa2Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1_3 = visual.TextStim(win=win, name='feedback1_zud1_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1_3 = visual.TextStim(win=win, name='feedback0_zud1_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01_3 = visual.TextStim(win=win, name='feedback_zud01_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "proceed"
proceedClock = core.Clock()
text2 = visual.TextStim(win=win, name='text2',
    text='You will NOT receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='darkorange', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "blank"
blankClock = core.Clock()
blank500ms = visual.TextStim(win=win, name='blank500ms',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "test"
testClock = core.Clock()
key_resp_t1_3 = keyboard.Keyboard()
t1_zud_3 = visual.TextStim(win=win, name='t1_zud_3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
t1_triangle1_3 = visual.ShapeStim(
    win=win, name='t1_triangle1_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
t1_rectangle1_3 = visual.Rect(
    win=win, name='t1_rectangle1_3',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_13 = visual.TextStim(win=win, name='option1_critical_13',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_13 = visual.TextStim(win=win, name='option2_critical_13',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "phase2"
phase2Clock = core.Clock()
p2 = visual.TextStim(win=win, name='p2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='blue', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "start_2"
start_2Clock = core.Clock()
text1 = visual.TextStim(win=win, name='text1',
    text='Please TYPE your answer using  keyboard.\n\nAllowed Keys: 1, 2, 3\n\nYou will receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='purple', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_7 = keyboard.Keyboard()

# Initialize components for Routine "zud1"
zud1Clock = core.Clock()
zud1_corr2 = visual.TextStim(win=win, name='zud1_corr2',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_1 = visual.ShapeStim(
    win=win, name='star_1', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triangle_1 = visual.ShapeStim(
    win=win, name='triangle_1',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_1 = visual.ShapeStim(
    win=win, name='cross_1', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
option1_01 = visual.TextStim(win=win, name='option1_01',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_01 = visual.TextStim(win=win, name='option2_01',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_01 = visual.TextStim(win=win, name='option3_01',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
key_resp_zud1 = keyboard.Keyboard()

# Initialize components for Routine "fb_zud1"
fb_zud1Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1 = visual.TextStim(win=win, name='feedback1_zud1',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1 = visual.TextStim(win=win, name='feedback0_zud1',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01 = visual.TextStim(win=win, name='feedback_zud01',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud2"
zud2Clock = core.Clock()
zud2_corr1 = visual.TextStim(win=win, name='zud2_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_2 = visual.ShapeStim(
    win=win, name='triangle_2',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_2 = visual.ShapeStim(
    win=win, name='star_2', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_2 = visual.ShapeStim(
    win=win, name='cross_2', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud2 = keyboard.Keyboard()
option1_02 = visual.TextStim(win=win, name='option1_02',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_02 = visual.TextStim(win=win, name='option2_02',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_02 = visual.TextStim(win=win, name='option3_02',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud2"
fb_zud2Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud2 = visual.TextStim(win=win, name='feedback1_zud2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud2 = visual.TextStim(win=win, name='feedback0_zud2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud02 = visual.TextStim(win=win, name='feedback_zud02',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud3"
zud3Clock = core.Clock()
zud3_corr1 = visual.TextStim(win=win, name='zud3_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_3 = visual.ShapeStim(
    win=win, name='triangle_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_3 = visual.ShapeStim(
    win=win, name='star_3', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_3 = visual.ShapeStim(
    win=win, name='cross_3', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud3 = keyboard.Keyboard()
option1_03 = visual.TextStim(win=win, name='option1_03',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_03 = visual.TextStim(win=win, name='option2_03',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_03 = visual.TextStim(win=win, name='option3_03',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud3"
fb_zud3Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud3 = visual.TextStim(win=win, name='feedback1_zud3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud3 = visual.TextStim(win=win, name='feedback0_zud3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud03 = visual.TextStim(win=win, name='feedback_zud03',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud4"
zud4Clock = core.Clock()
zud4_corr1 = visual.TextStim(win=win, name='zud4_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_4 = visual.ShapeStim(
    win=win, name='triangle_4',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_4 = visual.ShapeStim(
    win=win, name='star_4', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_4 = visual.ShapeStim(
    win=win, name='cross_4', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud4 = keyboard.Keyboard()
option1_04 = visual.TextStim(win=win, name='option1_04',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_04 = visual.TextStim(win=win, name='option2_04',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_04 = visual.TextStim(win=win, name='option3_04',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud4"
fb_zud4Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud4 = visual.TextStim(win=win, name='feedback1_zud4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud4 = visual.TextStim(win=win, name='feedback0_zud4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud04 = visual.TextStim(win=win, name='feedback_zud04',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud5"
zud5Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud5_corr3 = visual.TextStim(win=win, name='zud5_corr3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_5 = visual.ShapeStim(
    win=win, name='star_5', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_5 = visual.ShapeStim(
    win=win, name='cross_5', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
rectangle_5 = visual.Rect(
    win=win, name='rectangle_5',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud5 = keyboard.Keyboard()
option1_05 = visual.TextStim(win=win, name='option1_05',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_05 = visual.TextStim(win=win, name='option2_05',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_05 = visual.TextStim(win=win, name='option3_05',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud5"
fb_zud5Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud5 = visual.TextStim(win=win, name='feedback1_zud5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud5 = visual.TextStim(win=win, name='feedback0_zud5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud5 = visual.TextStim(win=win, name='feedback_zud5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud6"
zud6Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud6_corr3 = visual.TextStim(win=win, name='zud6_corr3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_6 = visual.ShapeStim(
    win=win, name='star_6', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_6 = visual.ShapeStim(
    win=win, name='cross_6', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
rectangle_6 = visual.Rect(
    win=win, name='rectangle_6',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud6 = keyboard.Keyboard()
option1_06 = visual.TextStim(win=win, name='option1_06',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_06 = visual.TextStim(win=win, name='option2_06',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_06 = visual.TextStim(win=win, name='option3_06',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud6"
fb_zud6Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud6 = visual.TextStim(win=win, name='feedback1_zud6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud6 = visual.TextStim(win=win, name='feedback0_zud6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud6 = visual.TextStim(win=win, name='feedback_zud6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud7"
zud7Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud7_corr1 = visual.TextStim(win=win, name='zud7_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
rectangle_7 = visual.Rect(
    win=win, name='rectangle_7',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_7 = visual.ShapeStim(
    win=win, name='cross_7', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
star_7 = visual.ShapeStim(
    win=win, name='star_7', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud7 = keyboard.Keyboard()
option1_07 = visual.TextStim(win=win, name='option1_07',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_07 = visual.TextStim(win=win, name='option2_07',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_07 = visual.TextStim(win=win, name='option3_07',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud7"
fb_zud7Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud7 = visual.TextStim(win=win, name='feedback1_zud7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud7 = visual.TextStim(win=win, name='feedback0_zud7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud7 = visual.TextStim(win=win, name='feedback_zud7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud8"
zud8Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud8_corr2 = visual.TextStim(win=win, name='zud8_corr2',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_8 = visual.ShapeStim(
    win=win, name='star_8', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
rectangle_8 = visual.Rect(
    win=win, name='rectangle_8',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_8 = visual.ShapeStim(
    win=win, name='cross_8', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud8 = keyboard.Keyboard()
option1_9 = visual.TextStim(win=win, name='option1_9',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_9 = visual.TextStim(win=win, name='option2_9',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_8 = visual.TextStim(win=win, name='option3_8',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud8"
fb_zud8Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud8 = visual.TextStim(win=win, name='feedback1_zud8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud8 = visual.TextStim(win=win, name='feedback0_zud8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud8 = visual.TextStim(win=win, name='feedback_zud8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax9"
dax9Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax9_corr2 = visual.TextStim(win=win, name='dax9_corr2',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_9 = visual.ShapeStim(
    win=win, name='star_9', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_9 = visual.ShapeStim(
    win=win, name='triange_9',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_9 = visual.ShapeStim(
    win=win, name='cross_9', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax9 = keyboard.Keyboard()
option1 = visual.TextStim(win=win, name='option1',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2 = visual.TextStim(win=win, name='option2',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3 = visual.TextStim(win=win, name='option3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax9"
fb_dax9Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9 = visual.TextStim(win=win, name='feedback1_dax9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9 = visual.TextStim(win=win, name='feedback0_dax9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9 = visual.TextStim(win=win, name='feedback_dax9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax10"
dax10Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax10_corr1 = visual.TextStim(win=win, name='dax10_corr1',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
triangle_10 = visual.ShapeStim(
    win=win, name='triangle_10',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_10 = visual.ShapeStim(
    win=win, name='cross_10', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
star_10 = visual.ShapeStim(
    win=win, name='star_10', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax10 = keyboard.Keyboard()
option1_8 = visual.TextStim(win=win, name='option1_8',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_8 = visual.TextStim(win=win, name='option2_8',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_10 = visual.TextStim(win=win, name='option3_10',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax10"
fb_dax10Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_2 = visual.TextStim(win=win, name='feedback1_dax9_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_2 = visual.TextStim(win=win, name='feedback0_dax9_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_2 = visual.TextStim(win=win, name='feedback_dax9_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax11"
dax11Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax11_corr3 = visual.TextStim(win=win, name='dax11_corr3',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_11 = visual.ShapeStim(
    win=win, name='star_11', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_11 = visual.ShapeStim(
    win=win, name='cross_11', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
triangle_11 = visual.ShapeStim(
    win=win, name='triangle_11',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax11 = keyboard.Keyboard()
option1_6 = visual.TextStim(win=win, name='option1_6',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_6 = visual.TextStim(win=win, name='option2_6',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_6 = visual.TextStim(win=win, name='option3_6',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax11"
fb_dax11Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_3 = visual.TextStim(win=win, name='feedback1_dax9_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_3 = visual.TextStim(win=win, name='feedback0_dax9_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_3 = visual.TextStim(win=win, name='feedback_dax9_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax12"
dax12Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax11_corr2 = visual.TextStim(win=win, name='dax11_corr2',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_12 = visual.ShapeStim(
    win=win, name='star_12', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
tr_12 = visual.ShapeStim(
    win=win, name='tr_12',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cr_12 = visual.ShapeStim(
    win=win, name='cr_12', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax12 = keyboard.Keyboard()
option1_7 = visual.TextStim(win=win, name='option1_7',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_7 = visual.TextStim(win=win, name='option2_7',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_7 = visual.TextStim(win=win, name='option3_7',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax12"
fb_dax12Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_4 = visual.TextStim(win=win, name='feedback1_dax9_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_4 = visual.TextStim(win=win, name='feedback0_dax9_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_4 = visual.TextStim(win=win, name='feedback_dax9_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicket13"
blicket13Clock = core.Clock()
key_resp_blicket13 = keyboard.Keyboard()
blicket1 = visual.TextStim(win=win, name='blicket1',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w = visual.ShapeStim(
    win=win, name='blicket_st_w', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b = visual.ShapeStim(
    win=win, name='blicket_st_b',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
rec_bl_2 = visual.Rect(
    win=win, name='rec_bl_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='white', fillColor='black',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_3 = visual.TextStim(win=win, name='option1_critical_3',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_3 = visual.TextStim(win=win, name='option2_critical_3',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
text3 = visual.TextStim(win=win, name='text3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_blicket13"
fb_blicket13Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_5 = visual.TextStim(win=win, name='feedback1_dax9_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_5 = visual.TextStim(win=win, name='feedback0_dax9_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_5 = visual.TextStim(win=win, name='feedback_dax9_5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicket14"
blicket14Clock = core.Clock()
key_resp_blicket14 = keyboard.Keyboard()
blicket1_2 = visual.TextStim(win=win, name='blicket1_2',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_2 = visual.ShapeStim(
    win=win, name='blicket_st_w_2', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_2 = visual.Rect(
    win=win, name='blicket_st_b_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
w_triange = visual.ShapeStim(
    win=win, name='w_triange',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_4 = visual.TextStim(win=win, name='option1_critical_4',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_4 = visual.TextStim(win=win, name='option2_critical_4',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
bltext = visual.TextStim(win=win, name='bltext',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_blicket14"
fb_blicket14Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_6 = visual.TextStim(win=win, name='feedback1_dax9_6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_6 = visual.TextStim(win=win, name='feedback0_dax9_6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_6 = visual.TextStim(win=win, name='feedback_dax9_6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicket15"
blicket15Clock = core.Clock()
key_resp_blicket15 = keyboard.Keyboard()
blicket1_3 = visual.TextStim(win=win, name='blicket1_3',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
blicket_st_b15 = visual.ShapeStim(
    win=win, name='blicket_st_b15',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
blicket_st_w15 = visual.ShapeStim(
    win=win, name='blicket_st_w15',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_5 = visual.TextStim(win=win, name='option1_critical_5',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_5 = visual.TextStim(win=win, name='option2_critical_5',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "fb_blicket15"
fb_blicket15Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_7 = visual.TextStim(win=win, name='feedback1_dax9_7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_7 = visual.TextStim(win=win, name='feedback0_dax9_7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_7 = visual.TextStim(win=win, name='feedback_dax9_7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicket16"
blicket16Clock = core.Clock()
key_resp_blicket16 = keyboard.Keyboard()
blicket1_4 = visual.TextStim(win=win, name='blicket1_4',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
blicket_st_b15_2 = visual.Rect(
    win=win, name='blicket_st_b15_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
blicket_st_w15_2 = visual.Rect(
    win=win, name='blicket_st_w15_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_6 = visual.TextStim(win=win, name='option1_critical_6',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_6 = visual.TextStim(win=win, name='option2_critical_6',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "fb_blicket16"
fb_blicket16Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_8 = visual.TextStim(win=win, name='feedback1_dax9_8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_8 = visual.TextStim(win=win, name='feedback0_dax9_8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_8 = visual.TextStim(win=win, name='feedback_dax9_8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicket17"
smicket17Clock = core.Clock()
key_resp_smicket17 = keyboard.Keyboard()
blicket1_5 = visual.TextStim(win=win, name='blicket1_5',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_3 = visual.ShapeStim(
    win=win, name='blicket_st_w_3', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_3 = visual.ShapeStim(
    win=win, name='blicket_st_b_3', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
sm = visual.ShapeStim(
    win=win, name='sm',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_7 = visual.TextStim(win=win, name='option1_critical_7',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_7 = visual.TextStim(win=win, name='option2_critical_7',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
smtext = visual.TextStim(win=win, name='smtext',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_smicket17"
fb_smicket17Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_9 = visual.TextStim(win=win, name='feedback1_dax9_9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_9 = visual.TextStim(win=win, name='feedback0_dax9_9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_9 = visual.TextStim(win=win, name='feedback_dax9_9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicket18"
smicket18Clock = core.Clock()
key_resp_smicket18 = keyboard.Keyboard()
blicket1_6 = visual.TextStim(win=win, name='blicket1_6',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_4 = visual.ShapeStim(
    win=win, name='blicket_st_w_4', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_4 = visual.ShapeStim(
    win=win, name='blicket_st_b_4', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
sm2 = visual.ShapeStim(
    win=win, name='sm2',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-5.0, interpolate=True)
option1_critical_8 = visual.TextStim(win=win, name='option1_critical_8',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_critical_8 = visual.TextStim(win=win, name='option2_critical_8',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
smtext2 = visual.TextStim(win=win, name='smtext2',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_smicket18"
fb_smicket18Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_10 = visual.TextStim(win=win, name='feedback1_dax9_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_10 = visual.TextStim(win=win, name='feedback0_dax9_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_10 = visual.TextStim(win=win, name='feedback_dax9_10',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicket19"
smicket19Clock = core.Clock()
key_resp_smicket19 = keyboard.Keyboard()
blicket1_7 = visual.TextStim(win=win, name='blicket1_7',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
blicket_st_b15_3 = visual.ShapeStim(
    win=win, name='blicket_st_b15_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
blicket_st_w15_3 = visual.ShapeStim(
    win=win, name='blicket_st_w15_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_9 = visual.TextStim(win=win, name='option1_critical_9',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_9 = visual.TextStim(win=win, name='option2_critical_9',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "fb_smicket19"
fb_smicket19Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_11 = visual.TextStim(win=win, name='feedback1_dax9_11',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_11 = visual.TextStim(win=win, name='feedback0_dax9_11',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_11 = visual.TextStim(win=win, name='feedback_dax9_11',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicket20"
smicket20Clock = core.Clock()
key_resp_smicket20 = keyboard.Keyboard()
blicket1_8 = visual.TextStim(win=win, name='blicket1_8',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
blicket_st_b20 = visual.Rect(
    win=win, name='blicket_st_b20',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
blicket_st_w15_4 = visual.Rect(
    win=win, name='blicket_st_w15_4',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_10 = visual.TextStim(win=win, name='option1_critical_10',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_10 = visual.TextStim(win=win, name='option2_critical_10',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "fb_smicket20"
fb_smicket20Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_12 = visual.TextStim(win=win, name='feedback1_dax9_12',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_12 = visual.TextStim(win=win, name='feedback0_dax9_12',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_12 = visual.TextStim(win=win, name='feedback_dax9_12',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicketfep21"
blicketfep21Clock = core.Clock()
dax9_corr2_2 = visual.TextStim(win=win, name='dax9_corr2_2',
    text='blicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_13 = visual.ShapeStim(
    win=win, name='star_13', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange = visual.ShapeStim(
    win=win, name='triange', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_12 = visual.Rect(
    win=win, name='cross_12',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_blicketfep21 = keyboard.Keyboard()
option1_2 = visual.TextStim(win=win, name='option1_2',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_2 = visual.TextStim(win=win, name='option2_2',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_2 = visual.TextStim(win=win, name='option3_2',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_blicketfep21"
fb_blicketfep21Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_13 = visual.TextStim(win=win, name='feedback1_dax9_13',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_13 = visual.TextStim(win=win, name='feedback0_dax9_13',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_13 = visual.TextStim(win=win, name='feedback_dax9_13',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicketfep22"
blicketfep22Clock = core.Clock()
dax9_corr2_3 = visual.TextStim(win=win, name='dax9_corr2_3',
    text='blicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_14 = visual.ShapeStim(
    win=win, name='star_14', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_2 = visual.Rect(
    win=win, name='triange_2',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_13 = visual.ShapeStim(
    win=win, name='cross_13', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_blicketfep22 = keyboard.Keyboard()
option1_3 = visual.TextStim(win=win, name='option1_3',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_3 = visual.TextStim(win=win, name='option2_3',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_3 = visual.TextStim(win=win, name='option3_3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_blicketfep22"
fb_blicketfep22Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_14 = visual.TextStim(win=win, name='feedback1_dax9_14',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_14 = visual.TextStim(win=win, name='feedback0_dax9_14',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_14 = visual.TextStim(win=win, name='feedback_dax9_14',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicketfep23"
blicketfep23Clock = core.Clock()
dax9_corr2_4 = visual.TextStim(win=win, name='dax9_corr2_4',
    text='blicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_15 = visual.ShapeStim(
    win=win, name='star_15', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_3 = visual.Rect(
    win=win, name='triange_3',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_14 = visual.ShapeStim(
    win=win, name='cross_14', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_blicketfep23 = keyboard.Keyboard()
option1_4 = visual.TextStim(win=win, name='option1_4',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_4 = visual.TextStim(win=win, name='option2_4',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_4 = visual.TextStim(win=win, name='option3_4',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_blicketfep23"
fb_blicketfep23Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_15 = visual.TextStim(win=win, name='feedback1_dax9_15',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_15 = visual.TextStim(win=win, name='feedback0_dax9_15',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_15 = visual.TextStim(win=win, name='feedback_dax9_15',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "blicketfep24"
blicketfep24Clock = core.Clock()
dax9_corr2_5 = visual.TextStim(win=win, name='dax9_corr2_5',
    text='blicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_16 = visual.ShapeStim(
    win=win, name='star_16', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_4 = visual.Rect(
    win=win, name='triange_4',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_15 = visual.ShapeStim(
    win=win, name='cross_15', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_blicketfep24 = keyboard.Keyboard()
option1_5 = visual.TextStim(win=win, name='option1_5',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_5 = visual.TextStim(win=win, name='option2_5',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_5 = visual.TextStim(win=win, name='option3_5',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_blicketfep24"
fb_blicketfep24Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_16 = visual.TextStim(win=win, name='feedback1_dax9_16',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_16 = visual.TextStim(win=win, name='feedback0_dax9_16',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_16 = visual.TextStim(win=win, name='feedback_dax9_16',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicketfep25"
smicketfep25Clock = core.Clock()
dax9_corr2_6 = visual.TextStim(win=win, name='dax9_corr2_6',
    text='smicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_17 = visual.ShapeStim(
    win=win, name='star_17', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_5 = visual.Rect(
    win=win, name='triange_5',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_16 = visual.ShapeStim(
    win=win, name='cross_16', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_smicketfep25 = keyboard.Keyboard()
option1_12 = visual.TextStim(win=win, name='option1_12',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_12 = visual.TextStim(win=win, name='option2_12',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_11 = visual.TextStim(win=win, name='option3_11',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_smicketfep25"
fb_smicketfep25Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_17 = visual.TextStim(win=win, name='feedback1_dax9_17',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_17 = visual.TextStim(win=win, name='feedback0_dax9_17',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_17 = visual.TextStim(win=win, name='feedback_dax9_17',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicketfep26"
smicketfep26Clock = core.Clock()
dax9_corr2_7 = visual.TextStim(win=win, name='dax9_corr2_7',
    text='smicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_18 = visual.ShapeStim(
    win=win, name='star_18', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_6 = visual.ShapeStim(
    win=win, name='triange_6', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_17 = visual.Rect(
    win=win, name='cross_17',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_smicketfep26 = keyboard.Keyboard()
option1_13 = visual.TextStim(win=win, name='option1_13',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_13 = visual.TextStim(win=win, name='option2_13',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_12 = visual.TextStim(win=win, name='option3_12',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_smicketfep26"
fb_smicketfep26Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_18 = visual.TextStim(win=win, name='feedback1_dax9_18',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_18 = visual.TextStim(win=win, name='feedback0_dax9_18',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_18 = visual.TextStim(win=win, name='feedback_dax9_18',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicketfep27"
smicketfep27Clock = core.Clock()
dax9_corr2_8 = visual.TextStim(win=win, name='dax9_corr2_8',
    text='smicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_19 = visual.ShapeStim(
    win=win, name='star_19', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_7 = visual.ShapeStim(
    win=win, name='triange_7', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_18 = visual.Rect(
    win=win, name='cross_18',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_smicketfep27 = keyboard.Keyboard()
option1_14 = visual.TextStim(win=win, name='option1_14',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_14 = visual.TextStim(win=win, name='option2_14',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_13 = visual.TextStim(win=win, name='option3_13',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_smicketfep27"
fb_smicketfep27Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_19 = visual.TextStim(win=win, name='feedback1_dax9_19',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_19 = visual.TextStim(win=win, name='feedback0_dax9_19',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_19 = visual.TextStim(win=win, name='feedback_dax9_19',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "smicketfep28"
smicketfep28Clock = core.Clock()
dax9_corr2_9 = visual.TextStim(win=win, name='dax9_corr2_9',
    text='smicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_20 = visual.Rect(
    win=win, name='star_20',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-1.0, interpolate=True)
triange_8 = visual.ShapeStim(
    win=win, name='triange_8', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_19 = visual.ShapeStim(
    win=win, name='cross_19', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
key_resp_smicketfep28 = keyboard.Keyboard()
option1_15 = visual.TextStim(win=win, name='option1_15',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_15 = visual.TextStim(win=win, name='option2_15',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_14 = visual.TextStim(win=win, name='option3_14',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);

# Initialize components for Routine "fb_smicketfep28"
fb_smicketfep28Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_20 = visual.TextStim(win=win, name='feedback1_dax9_20',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_20 = visual.TextStim(win=win, name='feedback0_dax9_20',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_20 = visual.TextStim(win=win, name='feedback_dax9_20',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "proceed"
proceedClock = core.Clock()
text2 = visual.TextStim(win=win, name='text2',
    text='You will NOT receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='darkorange', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "dax12test2"
dax12test2Clock = core.Clock()
dax11_corr2_2 = visual.TextStim(win=win, name='dax11_corr2_2',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_21 = visual.ShapeStim(
    win=win, name='star_21', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
tr = visual.ShapeStim(
    win=win, name='tr',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cr = visual.ShapeStim(
    win=win, name='cr', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax12_2 = keyboard.Keyboard()
option1_16 = visual.TextStim(win=win, name='option1_16',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_16 = visual.TextStim(win=win, name='option2_16',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_15 = visual.TextStim(win=win, name='option3_15',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "blicket15test2"
blicket15test2Clock = core.Clock()
key_resp_blicket15_2 = keyboard.Keyboard()
blicket1_9 = visual.TextStim(win=win, name='blicket1_9',
    text='blicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_b15_4 = visual.ShapeStim(
    win=win, name='blicket_st_b15_4',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_w15_5 = visual.ShapeStim(
    win=win, name='blicket_st_w15_5',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
option1_critical_11 = visual.TextStim(win=win, name='option1_critical_11',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_critical_11 = visual.TextStim(win=win, name='option2_critical_11',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);

# Initialize components for Routine "smicket18test2"
smicket18test2Clock = core.Clock()
key_resp_smicket18_2 = keyboard.Keyboard()
blicket1_10 = visual.TextStim(win=win, name='blicket1_10',
    text='smicket',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
blicket_st_w_5 = visual.ShapeStim(
    win=win, name='blicket_st_w_5', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
blicket_st_b_5 = visual.ShapeStim(
    win=win, name='blicket_st_b_5', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
option1_critical_12 = visual.TextStim(win=win, name='option1_critical_12',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_critical_12 = visual.TextStim(win=win, name='option2_critical_12',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);

# Initialize components for Routine "blicketfep21test2"
blicketfep21test2Clock = core.Clock()
dax9_corr2_10 = visual.TextStim(win=win, name='dax9_corr2_10',
    text='blicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_22 = visual.ShapeStim(
    win=win, name='star_22', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_10 = visual.ShapeStim(
    win=win, name='triange_10', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_20 = visual.Rect(
    win=win, name='cross_20',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_blicketfep21_2 = keyboard.Keyboard()
option1_17 = visual.TextStim(win=win, name='option1_17',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_17 = visual.TextStim(win=win, name='option2_17',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_16 = visual.TextStim(win=win, name='option3_16',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "smicketfep27test2"
smicketfep27test2Clock = core.Clock()
dax9_corr2_11 = visual.TextStim(win=win, name='dax9_corr2_11',
    text='smicket fep',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_23 = visual.ShapeStim(
    win=win, name='star_23', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_11 = visual.ShapeStim(
    win=win, name='triange_11', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_21 = visual.Rect(
    win=win, name='cross_21',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_smicketfep27_2 = keyboard.Keyboard()
option1_18 = visual.TextStim(win=win, name='option1_18',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_18 = visual.TextStim(win=win, name='option2_18',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_17 = visual.TextStim(win=win, name='option3_17',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "proceed"
proceedClock = core.Clock()
text2 = visual.TextStim(win=win, name='text2',
    text='You will NOT receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='darkorange', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "blank"
blankClock = core.Clock()
blank500ms = visual.TextStim(win=win, name='blank500ms',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "test"
testClock = core.Clock()
key_resp_t1_3 = keyboard.Keyboard()
t1_zud_3 = visual.TextStim(win=win, name='t1_zud_3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
t1_triangle1_3 = visual.ShapeStim(
    win=win, name='t1_triangle1_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
t1_rectangle1_3 = visual.Rect(
    win=win, name='t1_rectangle1_3',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_13 = visual.TextStim(win=win, name='option1_critical_13',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_13 = visual.TextStim(win=win, name='option2_critical_13',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "phase3"
phase3Clock = core.Clock()
p3 = visual.TextStim(win=win, name='p3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='blue', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "start_2"
start_2Clock = core.Clock()
text1 = visual.TextStim(win=win, name='text1',
    text='Please TYPE your answer using  keyboard.\n\nAllowed Keys: 1, 2, 3\n\nYou will receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.06, wrapWidth=None, ori=0.0, 
    color='purple', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_7 = keyboard.Keyboard()

# Initialize components for Routine "zud1"
zud1Clock = core.Clock()
zud1_corr2 = visual.TextStim(win=win, name='zud1_corr2',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
star_1 = visual.ShapeStim(
    win=win, name='star_1', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triangle_1 = visual.ShapeStim(
    win=win, name='triangle_1',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_1 = visual.ShapeStim(
    win=win, name='cross_1', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
option1_01 = visual.TextStim(win=win, name='option1_01',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
option2_01 = visual.TextStim(win=win, name='option2_01',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option3_01 = visual.TextStim(win=win, name='option3_01',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
key_resp_zud1 = keyboard.Keyboard()

# Initialize components for Routine "fb_zud1"
fb_zud1Clock = core.Clock()
msg1=""
msg0=""
msg=""

feedback1_zud1 = visual.TextStim(win=win, name='feedback1_zud1',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud1 = visual.TextStim(win=win, name='feedback0_zud1',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud01 = visual.TextStim(win=win, name='feedback_zud01',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud2"
zud2Clock = core.Clock()
zud2_corr1 = visual.TextStim(win=win, name='zud2_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_2 = visual.ShapeStim(
    win=win, name='triangle_2',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_2 = visual.ShapeStim(
    win=win, name='star_2', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_2 = visual.ShapeStim(
    win=win, name='cross_2', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud2 = keyboard.Keyboard()
option1_02 = visual.TextStim(win=win, name='option1_02',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_02 = visual.TextStim(win=win, name='option2_02',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_02 = visual.TextStim(win=win, name='option3_02',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud2"
fb_zud2Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud2 = visual.TextStim(win=win, name='feedback1_zud2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud2 = visual.TextStim(win=win, name='feedback0_zud2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud02 = visual.TextStim(win=win, name='feedback_zud02',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud3"
zud3Clock = core.Clock()
zud3_corr1 = visual.TextStim(win=win, name='zud3_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_3 = visual.ShapeStim(
    win=win, name='triangle_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_3 = visual.ShapeStim(
    win=win, name='star_3', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_3 = visual.ShapeStim(
    win=win, name='cross_3', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud3 = keyboard.Keyboard()
option1_03 = visual.TextStim(win=win, name='option1_03',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_03 = visual.TextStim(win=win, name='option2_03',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_03 = visual.TextStim(win=win, name='option3_03',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud3"
fb_zud3Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud3 = visual.TextStim(win=win, name='feedback1_zud3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud3 = visual.TextStim(win=win, name='feedback0_zud3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud03 = visual.TextStim(win=win, name='feedback_zud03',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud4"
zud4Clock = core.Clock()
zud4_corr1 = visual.TextStim(win=win, name='zud4_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
triangle_4 = visual.ShapeStim(
    win=win, name='triangle_4',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
star_4 = visual.ShapeStim(
    win=win, name='star_4', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_4 = visual.ShapeStim(
    win=win, name='cross_4', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud4 = keyboard.Keyboard()
option1_04 = visual.TextStim(win=win, name='option1_04',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_04 = visual.TextStim(win=win, name='option2_04',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_04 = visual.TextStim(win=win, name='option3_04',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud4"
fb_zud4Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud4 = visual.TextStim(win=win, name='feedback1_zud4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud4 = visual.TextStim(win=win, name='feedback0_zud4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud04 = visual.TextStim(win=win, name='feedback_zud04',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud5"
zud5Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud5_corr3 = visual.TextStim(win=win, name='zud5_corr3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_5 = visual.ShapeStim(
    win=win, name='star_5', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_5 = visual.ShapeStim(
    win=win, name='cross_5', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
rectangle_5 = visual.Rect(
    win=win, name='rectangle_5',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud5 = keyboard.Keyboard()
option1_05 = visual.TextStim(win=win, name='option1_05',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_05 = visual.TextStim(win=win, name='option2_05',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_05 = visual.TextStim(win=win, name='option3_05',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud5"
fb_zud5Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud5 = visual.TextStim(win=win, name='feedback1_zud5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud5 = visual.TextStim(win=win, name='feedback0_zud5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud5 = visual.TextStim(win=win, name='feedback_zud5',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud6"
zud6Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud6_corr3 = visual.TextStim(win=win, name='zud6_corr3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_6 = visual.ShapeStim(
    win=win, name='star_6', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_6 = visual.ShapeStim(
    win=win, name='cross_6', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
rectangle_6 = visual.Rect(
    win=win, name='rectangle_6',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud6 = keyboard.Keyboard()
option1_06 = visual.TextStim(win=win, name='option1_06',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_06 = visual.TextStim(win=win, name='option2_06',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_06 = visual.TextStim(win=win, name='option3_06',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud6"
fb_zud6Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud6 = visual.TextStim(win=win, name='feedback1_zud6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud6 = visual.TextStim(win=win, name='feedback0_zud6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud6 = visual.TextStim(win=win, name='feedback_zud6',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud7"
zud7Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud7_corr1 = visual.TextStim(win=win, name='zud7_corr1',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
rectangle_7 = visual.Rect(
    win=win, name='rectangle_7',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_7 = visual.ShapeStim(
    win=win, name='cross_7', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
star_7 = visual.ShapeStim(
    win=win, name='star_7', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud7 = keyboard.Keyboard()
option1_07 = visual.TextStim(win=win, name='option1_07',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_07 = visual.TextStim(win=win, name='option2_07',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_07 = visual.TextStim(win=win, name='option3_07',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud7"
fb_zud7Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud7 = visual.TextStim(win=win, name='feedback1_zud7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud7 = visual.TextStim(win=win, name='feedback0_zud7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud7 = visual.TextStim(win=win, name='feedback_zud7',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "zud8"
zud8Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
zud8_corr2 = visual.TextStim(win=win, name='zud8_corr2',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_8 = visual.ShapeStim(
    win=win, name='star_8', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
rectangle_8 = visual.Rect(
    win=win, name='rectangle_8',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_8 = visual.ShapeStim(
    win=win, name='cross_8', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_zud8 = keyboard.Keyboard()
option1_9 = visual.TextStim(win=win, name='option1_9',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_9 = visual.TextStim(win=win, name='option2_9',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_8 = visual.TextStim(win=win, name='option3_8',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_zud8"
fb_zud8Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_zud8 = visual.TextStim(win=win, name='feedback1_zud8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_zud8 = visual.TextStim(win=win, name='feedback0_zud8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_zud8 = visual.TextStim(win=win, name='feedback_zud8',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax9"
dax9Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax9_corr2 = visual.TextStim(win=win, name='dax9_corr2',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_9 = visual.ShapeStim(
    win=win, name='star_9', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_9 = visual.ShapeStim(
    win=win, name='triange_9',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_9 = visual.ShapeStim(
    win=win, name='cross_9', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax9 = keyboard.Keyboard()
option1 = visual.TextStim(win=win, name='option1',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2 = visual.TextStim(win=win, name='option2',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3 = visual.TextStim(win=win, name='option3',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax9"
fb_dax9Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9 = visual.TextStim(win=win, name='feedback1_dax9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9 = visual.TextStim(win=win, name='feedback0_dax9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9 = visual.TextStim(win=win, name='feedback_dax9',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax10"
dax10Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax10_corr1 = visual.TextStim(win=win, name='dax10_corr1',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
triangle_10 = visual.ShapeStim(
    win=win, name='triangle_10',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_10 = visual.ShapeStim(
    win=win, name='cross_10', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
star_10 = visual.ShapeStim(
    win=win, name='star_10', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax10 = keyboard.Keyboard()
option1_8 = visual.TextStim(win=win, name='option1_8',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_8 = visual.TextStim(win=win, name='option2_8',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_10 = visual.TextStim(win=win, name='option3_10',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax10"
fb_dax10Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_2 = visual.TextStim(win=win, name='feedback1_dax9_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_2 = visual.TextStim(win=win, name='feedback0_dax9_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_2 = visual.TextStim(win=win, name='feedback_dax9_2',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax11"
dax11Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax11_corr3 = visual.TextStim(win=win, name='dax11_corr3',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_11 = visual.ShapeStim(
    win=win, name='star_11', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
cross_11 = visual.ShapeStim(
    win=win, name='cross_11', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
triangle_11 = visual.ShapeStim(
    win=win, name='triangle_11',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax11 = keyboard.Keyboard()
option1_6 = visual.TextStim(win=win, name='option1_6',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_6 = visual.TextStim(win=win, name='option2_6',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_6 = visual.TextStim(win=win, name='option3_6',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax11"
fb_dax11Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_3 = visual.TextStim(win=win, name='feedback1_dax9_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_3 = visual.TextStim(win=win, name='feedback0_dax9_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_3 = visual.TextStim(win=win, name='feedback_dax9_3',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "dax12"
dax12Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax11_corr2 = visual.TextStim(win=win, name='dax11_corr2',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_12 = visual.ShapeStim(
    win=win, name='star_12', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
tr_12 = visual.ShapeStim(
    win=win, name='tr_12',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cr_12 = visual.ShapeStim(
    win=win, name='cr_12', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax12 = keyboard.Keyboard()
option1_7 = visual.TextStim(win=win, name='option1_7',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_7 = visual.TextStim(win=win, name='option2_7',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_7 = visual.TextStim(win=win, name='option3_7',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_dax12"
fb_dax12Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_4 = visual.TextStim(win=win, name='feedback1_dax9_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_4 = visual.TextStim(win=win, name='feedback0_dax9_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_4 = visual.TextStim(win=win, name='feedback_dax9_4',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "tas29"
tas29Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax9_corr2_12 = visual.TextStim(win=win, name='dax9_corr2_12',
    text='tas',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_24 = visual.Rect(
    win=win, name='star_24',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_12 = visual.ShapeStim(
    win=win, name='triange_12', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_22 = visual.ShapeStim(
    win=win, name='cross_22', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_tas29 = keyboard.Keyboard()
option1_19 = visual.TextStim(win=win, name='option1_19',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_19 = visual.TextStim(win=win, name='option2_19',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_18 = visual.TextStim(win=win, name='option3_18',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_tas29"
fb_tas29Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_21 = visual.TextStim(win=win, name='feedback1_dax9_21',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_21 = visual.TextStim(win=win, name='feedback0_dax9_21',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_21 = visual.TextStim(win=win, name='feedback_dax9_21',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "tas30"
tas30Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax9_corr2_13 = visual.TextStim(win=win, name='dax9_corr2_13',
    text='tas',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_25 = visual.ShapeStim(
    win=win, name='star_25', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_13 = visual.Rect(
    win=win, name='triange_13',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_23 = visual.ShapeStim(
    win=win, name='cross_23', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_tas30 = keyboard.Keyboard()
option1_20 = visual.TextStim(win=win, name='option1_20',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_20 = visual.TextStim(win=win, name='option2_20',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_19 = visual.TextStim(win=win, name='option3_19',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_tas30"
fb_tas30Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_22 = visual.TextStim(win=win, name='feedback1_dax9_22',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_22 = visual.TextStim(win=win, name='feedback0_dax9_22',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_22 = visual.TextStim(win=win, name='feedback_dax9_22',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "tas31"
tas31Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax9_corr2_14 = visual.TextStim(win=win, name='dax9_corr2_14',
    text='tas',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_26 = visual.Rect(
    win=win, name='star_26',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_14 = visual.ShapeStim(
    win=win, name='triange_14', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_24 = visual.ShapeStim(
    win=win, name='cross_24', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_tas31 = keyboard.Keyboard()
option1_21 = visual.TextStim(win=win, name='option1_21',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_21 = visual.TextStim(win=win, name='option2_21',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_20 = visual.TextStim(win=win, name='option3_20',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_tas31"
fb_tas31Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_23 = visual.TextStim(win=win, name='feedback1_dax9_23',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_23 = visual.TextStim(win=win, name='feedback0_dax9_23',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_23 = visual.TextStim(win=win, name='feedback_dax9_23',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "tas32"
tas32Clock = core.Clock()
msg1='yeah!'
msg0='doh!'
dax9_corr2_15 = visual.TextStim(win=win, name='dax9_corr2_15',
    text='tas',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_27 = visual.ShapeStim(
    win=win, name='star_27', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_15 = visual.ShapeStim(
    win=win, name='triange_15', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_25 = visual.Rect(
    win=win, name='cross_25',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_tas32 = keyboard.Keyboard()
option1_22 = visual.TextStim(win=win, name='option1_22',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_22 = visual.TextStim(win=win, name='option2_22',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_21 = visual.TextStim(win=win, name='option3_21',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "fb_tas32"
fb_tas32Clock = core.Clock()
msg1=""
msg0=""
msg=""
feedback1_dax9_24 = visual.TextStim(win=win, name='feedback1_dax9_24',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkgreen', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
feedback0_dax9_24 = visual.TextStim(win=win, name='feedback0_dax9_24',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
feedback_dax9_24 = visual.TextStim(win=win, name='feedback_dax9_24',
    text='',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='darkred', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);

# Initialize components for Routine "proceed"
proceedClock = core.Clock()
text2 = visual.TextStim(win=win, name='text2',
    text='You will NOT receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='darkorange', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "test2dax9"
test2dax9Clock = core.Clock()
dax9_corr2_16 = visual.TextStim(win=win, name='dax9_corr2_16',
    text='dax',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_28 = visual.ShapeStim(
    win=win, name='star_28', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_16 = visual.ShapeStim(
    win=win, name='triange_16',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_26 = visual.ShapeStim(
    win=win, name='cross_26', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_dax9_2 = keyboard.Keyboard()
option1_23 = visual.TextStim(win=win, name='option1_23',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_23 = visual.TextStim(win=win, name='option2_23',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_22 = visual.TextStim(win=win, name='option3_22',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "test2tas32"
test2tas32Clock = core.Clock()
dax9_corr2_17 = visual.TextStim(win=win, name='dax9_corr2_17',
    text='tas',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
star_29 = visual.ShapeStim(
    win=win, name='star_29', vertices='cross',
    size=(0.2, 0.2),
    ori=0.0, pos=(-0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
triange_17 = visual.ShapeStim(
    win=win, name='triange_17', vertices='star7',
    size=(0.2, 0.2),
    ori=0.0, pos=(0, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
cross_27 = visual.Rect(
    win=win, name='cross_27',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.5, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-4.0, interpolate=True)
key_resp_tas32_2 = keyboard.Keyboard()
option1_24 = visual.TextStim(win=win, name='option1_24',
    text='1',
    font='Open Sans',
    pos=(-0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-6.0);
option2_24 = visual.TextStim(win=win, name='option2_24',
    text='2',
    font='Open Sans',
    pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-7.0);
option3_23 = visual.TextStim(win=win, name='option3_23',
    text='3',
    font='Open Sans',
    pos=(0.5, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-8.0);

# Initialize components for Routine "proceed"
proceedClock = core.Clock()
text2 = visual.TextStim(win=win, name='text2',
    text='You will NOT receive feedbacks in the next few trials.\n\nPress SPACE bar to continue.',
    font='Open Sans',
    pos=(0, 0), height=0.07, wrapWidth=None, ori=0.0, 
    color='darkorange', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);
key_resp_6 = keyboard.Keyboard()

# Initialize components for Routine "blank"
blankClock = core.Clock()
blank500ms = visual.TextStim(win=win, name='blank500ms',
    text=None,
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Initialize components for Routine "test"
testClock = core.Clock()
key_resp_t1_3 = keyboard.Keyboard()
t1_zud_3 = visual.TextStim(win=win, name='t1_zud_3',
    text='zud',
    font='Open Sans',
    pos=(0, 0.3), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
t1_triangle1_3 = visual.ShapeStim(
    win=win, name='t1_triangle1_3',
    vertices=[[-(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [+(0.2, 0.2)[0]/2.0,-(0.2, 0.2)[1]/2.0], [0,(0.2, 0.2)[1]/2.0]],
    ori=0.0, pos=(-0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-2.0, interpolate=True)
t1_rectangle1_3 = visual.Rect(
    win=win, name='t1_rectangle1_3',
    width=(0.2, 0.2)[0], height=(0.2, 0.2)[1],
    ori=0.0, pos=(0.2, 0),
    lineWidth=1.0,     colorSpace='rgb',  lineColor='black', fillColor='white',
    opacity=None, depth=-3.0, interpolate=True)
option1_critical_13 = visual.TextStim(win=win, name='option1_critical_13',
    text='1',
    font='Open Sans',
    pos=(-0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
option2_critical_13 = visual.TextStim(win=win, name='option2_critical_13',
    text='2',
    font='Open Sans',
    pos=(0.2, -0.2), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);

# Initialize components for Routine "end"
endClock = core.Clock()
thankyou = visual.TextStim(win=win, name='thankyou',
    text='Thank you for your participation',
    font='Open Sans',
    pos=(0, 0), height=0.1, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=0.0);

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

# ------Prepare to start Routine "intro"-------
continueRoutine = True
# update component parameters for each repeat
key_resp.keys = []
key_resp.rt = []
_key_resp_allKeys = []
# keep track of which components have finished
introComponents = [welcome, key_resp]
for thisComponent in introComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
introClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "intro"-------
while continueRoutine:
    # get current time
    t = introClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=introClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *welcome* updates
    if welcome.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        welcome.frameNStart = frameN  # exact frame index
        welcome.tStart = t  # local t and not account for scr refresh
        welcome.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(welcome, 'tStartRefresh')  # time at next scr refresh
        welcome.setAutoDraw(True)
    
    # *key_resp* updates
    waitOnFlip = False
    if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp.frameNStart = frameN  # exact frame index
        key_resp.tStart = t  # local t and not account for scr refresh
        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
        key_resp.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp.status == STARTED and not waitOnFlip:
        theseKeys = key_resp.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_allKeys.extend(theseKeys)
        if len(_key_resp_allKeys):
            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
            key_resp.rt = _key_resp_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in introComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "intro"-------
for thisComponent in introComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('welcome.started', welcome.tStartRefresh)
thisExp.addData('welcome.stopped', welcome.tStopRefresh)
# check responses
if key_resp.keys in ['', [], None]:  # No response was made
    key_resp.keys = None
thisExp.addData('key_resp.keys',key_resp.keys)
if key_resp.keys != None:  # we had a response
    thisExp.addData('key_resp.rt', key_resp.rt)
thisExp.addData('key_resp.started', key_resp.tStartRefresh)
thisExp.addData('key_resp.stopped', key_resp.tStopRefresh)
thisExp.nextEntry()
# the Routine "intro" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "Iunderstand"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_5.keys = []
key_resp_5.rt = []
_key_resp_5_allKeys = []
# keep track of which components have finished
IunderstandComponents = [text_9, key_resp_5]
for thisComponent in IunderstandComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
IunderstandClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "Iunderstand"-------
while continueRoutine:
    # get current time
    t = IunderstandClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=IunderstandClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_9* updates
    if text_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_9.frameNStart = frameN  # exact frame index
        text_9.tStart = t  # local t and not account for scr refresh
        text_9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_9, 'tStartRefresh')  # time at next scr refresh
        text_9.setAutoDraw(True)
    
    # *key_resp_5* updates
    waitOnFlip = False
    if key_resp_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_5.frameNStart = frameN  # exact frame index
        key_resp_5.tStart = t  # local t and not account for scr refresh
        key_resp_5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_5, 'tStartRefresh')  # time at next scr refresh
        key_resp_5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_5.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_5.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_5_allKeys.extend(theseKeys)
        if len(_key_resp_5_allKeys):
            key_resp_5.keys = _key_resp_5_allKeys[-1].name  # just the last key pressed
            key_resp_5.rt = _key_resp_5_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in IunderstandComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "Iunderstand"-------
for thisComponent in IunderstandComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_9.started', text_9.tStartRefresh)
thisExp.addData('text_9.stopped', text_9.tStopRefresh)
# check responses
if key_resp_5.keys in ['', [], None]:  # No response was made
    key_resp_5.keys = None
thisExp.addData('key_resp_5.keys',key_resp_5.keys)
if key_resp_5.keys != None:  # we had a response
    thisExp.addData('key_resp_5.rt', key_resp_5.rt)
thisExp.addData('key_resp_5.started', key_resp_5.tStartRefresh)
thisExp.addData('key_resp_5.stopped', key_resp_5.tStopRefresh)
thisExp.nextEntry()
# the Routine "Iunderstand" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "blank"-------
continueRoutine = True
routineTimer.add(0.200000)
# update component parameters for each repeat
# keep track of which components have finished
blankComponents = [blank500ms]
for thisComponent in blankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
blankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = blankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=blankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *blank500ms* updates
    if blank500ms.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        blank500ms.frameNStart = frameN  # exact frame index
        blank500ms.tStart = t  # local t and not account for scr refresh
        blank500ms.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(blank500ms, 'tStartRefresh')  # time at next scr refresh
        blank500ms.setAutoDraw(True)
    if blank500ms.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > blank500ms.tStartRefresh + 0.2-frameTolerance:
            # keep track of stop time/frame for later
            blank500ms.tStop = t  # not accounting for scr refresh
            blank500ms.frameNStop = frameN  # exact frame index
            win.timeOnFlip(blank500ms, 'tStopRefresh')  # time at next scr refresh
            blank500ms.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in blankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "blank"-------
for thisComponent in blankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('blank500ms.started', blank500ms.tStartRefresh)
thisExp.addData('blank500ms.stopped', blank500ms.tStopRefresh)

# ------Prepare to start Routine "instruction"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_2.keys = []
key_resp_2.rt = []
_key_resp_2_allKeys = []
# keep track of which components have finished
instructionComponents = [text_2, polygon, polygonblack, text_3, text_4, text_6, key_resp_2, text_7]
for thisComponent in instructionComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
instructionClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "instruction"-------
while continueRoutine:
    # get current time
    t = instructionClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=instructionClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_2* updates
    if text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_2.frameNStart = frameN  # exact frame index
        text_2.tStart = t  # local t and not account for scr refresh
        text_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
        text_2.setAutoDraw(True)
    
    # *polygon* updates
    if polygon.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        polygon.frameNStart = frameN  # exact frame index
        polygon.tStart = t  # local t and not account for scr refresh
        polygon.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(polygon, 'tStartRefresh')  # time at next scr refresh
        polygon.setAutoDraw(True)
    
    # *polygonblack* updates
    if polygonblack.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        polygonblack.frameNStart = frameN  # exact frame index
        polygonblack.tStart = t  # local t and not account for scr refresh
        polygonblack.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(polygonblack, 'tStartRefresh')  # time at next scr refresh
        polygonblack.setAutoDraw(True)
    
    # *text_3* updates
    if text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_3.frameNStart = frameN  # exact frame index
        text_3.tStart = t  # local t and not account for scr refresh
        text_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_3, 'tStartRefresh')  # time at next scr refresh
        text_3.setAutoDraw(True)
    
    # *text_4* updates
    if text_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_4.frameNStart = frameN  # exact frame index
        text_4.tStart = t  # local t and not account for scr refresh
        text_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_4, 'tStartRefresh')  # time at next scr refresh
        text_4.setAutoDraw(True)
    
    # *text_6* updates
    if text_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_6.frameNStart = frameN  # exact frame index
        text_6.tStart = t  # local t and not account for scr refresh
        text_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_6, 'tStartRefresh')  # time at next scr refresh
        text_6.setAutoDraw(True)
    
    # *key_resp_2* updates
    waitOnFlip = False
    if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_2.frameNStart = frameN  # exact frame index
        key_resp_2.tStart = t  # local t and not account for scr refresh
        key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
        key_resp_2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_2.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_2.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_2_allKeys.extend(theseKeys)
        if len(_key_resp_2_allKeys):
            key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
            key_resp_2.rt = _key_resp_2_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *text_7* updates
    if text_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_7.frameNStart = frameN  # exact frame index
        text_7.tStart = t  # local t and not account for scr refresh
        text_7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_7, 'tStartRefresh')  # time at next scr refresh
        text_7.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in instructionComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "instruction"-------
for thisComponent in instructionComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_2.started', text_2.tStartRefresh)
thisExp.addData('text_2.stopped', text_2.tStopRefresh)
thisExp.addData('polygon.started', polygon.tStartRefresh)
thisExp.addData('polygon.stopped', polygon.tStopRefresh)
thisExp.addData('polygonblack.started', polygonblack.tStartRefresh)
thisExp.addData('polygonblack.stopped', polygonblack.tStopRefresh)
thisExp.addData('text_3.started', text_3.tStartRefresh)
thisExp.addData('text_3.stopped', text_3.tStopRefresh)
thisExp.addData('text_4.started', text_4.tStartRefresh)
thisExp.addData('text_4.stopped', text_4.tStopRefresh)
thisExp.addData('text_6.started', text_6.tStartRefresh)
thisExp.addData('text_6.stopped', text_6.tStopRefresh)
# check responses
if key_resp_2.keys in ['', [], None]:  # No response was made
    key_resp_2.keys = None
thisExp.addData('key_resp_2.keys',key_resp_2.keys)
if key_resp_2.keys != None:  # we had a response
    thisExp.addData('key_resp_2.rt', key_resp_2.rt)
thisExp.addData('key_resp_2.started', key_resp_2.tStartRefresh)
thisExp.addData('key_resp_2.stopped', key_resp_2.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('text_7.started', text_7.tStartRefresh)
thisExp.addData('text_7.stopped', text_7.tStopRefresh)
# the Routine "instruction" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "start_practice"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_4.keys = []
key_resp_4.rt = []
_key_resp_4_allKeys = []
# keep track of which components have finished
start_practiceComponents = [text_8, key_resp_4]
for thisComponent in start_practiceComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
start_practiceClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "start_practice"-------
while continueRoutine:
    # get current time
    t = start_practiceClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=start_practiceClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_8* updates
    if text_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_8.frameNStart = frameN  # exact frame index
        text_8.tStart = t  # local t and not account for scr refresh
        text_8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_8, 'tStartRefresh')  # time at next scr refresh
        text_8.setAutoDraw(True)
    
    # *key_resp_4* updates
    waitOnFlip = False
    if key_resp_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_4.frameNStart = frameN  # exact frame index
        key_resp_4.tStart = t  # local t and not account for scr refresh
        key_resp_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_4, 'tStartRefresh')  # time at next scr refresh
        key_resp_4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_4.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_4.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_4_allKeys.extend(theseKeys)
        if len(_key_resp_4_allKeys):
            key_resp_4.keys = _key_resp_4_allKeys[-1].name  # just the last key pressed
            key_resp_4.rt = _key_resp_4_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in start_practiceComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "start_practice"-------
for thisComponent in start_practiceComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_8.started', text_8.tStartRefresh)
thisExp.addData('text_8.stopped', text_8.tStopRefresh)
# check responses
if key_resp_4.keys in ['', [], None]:  # No response was made
    key_resp_4.keys = None
thisExp.addData('key_resp_4.keys',key_resp_4.keys)
if key_resp_4.keys != None:  # we had a response
    thisExp.addData('key_resp_4.rt', key_resp_4.rt)
thisExp.addData('key_resp_4.started', key_resp_4.tStartRefresh)
thisExp.addData('key_resp_4.stopped', key_resp_4.tStopRefresh)
thisExp.nextEntry()
# the Routine "start_practice" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "start_2"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_7.keys = []
key_resp_7.rt = []
_key_resp_7_allKeys = []
# keep track of which components have finished
start_2Components = [text1, key_resp_7]
for thisComponent in start_2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
start_2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "start_2"-------
while continueRoutine:
    # get current time
    t = start_2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=start_2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text1* updates
    if text1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text1.frameNStart = frameN  # exact frame index
        text1.tStart = t  # local t and not account for scr refresh
        text1.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text1, 'tStartRefresh')  # time at next scr refresh
        text1.setAutoDraw(True)
    
    # *key_resp_7* updates
    waitOnFlip = False
    if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_7.frameNStart = frameN  # exact frame index
        key_resp_7.tStart = t  # local t and not account for scr refresh
        key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
        key_resp_7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_7.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_7.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_7_allKeys.extend(theseKeys)
        if len(_key_resp_7_allKeys):
            key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
            key_resp_7.rt = _key_resp_7_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in start_2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "start_2"-------
for thisComponent in start_2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text1.started', text1.tStartRefresh)
thisExp.addData('text1.stopped', text1.tStopRefresh)
# check responses
if key_resp_7.keys in ['', [], None]:  # No response was made
    key_resp_7.keys = None
thisExp.addData('key_resp_7.keys',key_resp_7.keys)
if key_resp_7.keys != None:  # we had a response
    thisExp.addData('key_resp_7.rt', key_resp_7.rt)
thisExp.addData('key_resp_7.started', key_resp_7.tStartRefresh)
thisExp.addData('key_resp_7.stopped', key_resp_7.tStopRefresh)
thisExp.nextEntry()
# the Routine "start_2" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# set up handler to look after randomisation of conditions etc
trials_practice = data.TrialHandler(nReps=3.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=[None],
    seed=None, name='trials_practice')
thisExp.addLoop(trials_practice)  # add the loop to the experiment
thisTrials_practice = trials_practice.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTrials_practice.rgb)
if thisTrials_practice != None:
    for paramName in thisTrials_practice:
        exec('{} = thisTrials_practice[paramName]'.format(paramName))

for thisTrials_practice in trials_practice:
    currentLoop = trials_practice
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_practice.rgb)
    if thisTrials_practice != None:
        for paramName in thisTrials_practice:
            exec('{} = thisTrials_practice[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "bosap1"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_bosa_2.keys = []
    key_resp_bosa_2.rt = []
    _key_resp_bosa_2_allKeys = []
    # keep track of which components have finished
    bosap1Components = [key_resp_bosa_2, blicket1_14, option1_critical_17, option2_critical_17, bosa3_2, polygon_8, polygon_9, polygon_10]
    for thisComponent in bosap1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    bosap1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "bosap1"-------
    while continueRoutine:
        # get current time
        t = bosap1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=bosap1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_bosa_2* updates
        waitOnFlip = False
        if key_resp_bosa_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_bosa_2.frameNStart = frameN  # exact frame index
            key_resp_bosa_2.tStart = t  # local t and not account for scr refresh
            key_resp_bosa_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_bosa_2, 'tStartRefresh')  # time at next scr refresh
            key_resp_bosa_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_bosa_2.clock.reset)  # t=0 on next screen flip
        if key_resp_bosa_2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_bosa_2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_bosa_2_allKeys.extend(theseKeys)
            if len(_key_resp_bosa_2_allKeys):
                key_resp_bosa_2.keys = _key_resp_bosa_2_allKeys[-1].name  # just the last key pressed
                key_resp_bosa_2.rt = _key_resp_bosa_2_allKeys[-1].rt
                # was this correct?
                if (key_resp_bosa_2.keys == str('3')) or (key_resp_bosa_2.keys == '3'):
                    key_resp_bosa_2.corr = 1
                else:
                    key_resp_bosa_2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_14* updates
        if blicket1_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_14.frameNStart = frameN  # exact frame index
            blicket1_14.tStart = t  # local t and not account for scr refresh
            blicket1_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_14, 'tStartRefresh')  # time at next scr refresh
            blicket1_14.setAutoDraw(True)
        
        # *option1_critical_17* updates
        if option1_critical_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_17.frameNStart = frameN  # exact frame index
            option1_critical_17.tStart = t  # local t and not account for scr refresh
            option1_critical_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_17, 'tStartRefresh')  # time at next scr refresh
            option1_critical_17.setAutoDraw(True)
        
        # *option2_critical_17* updates
        if option2_critical_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_17.frameNStart = frameN  # exact frame index
            option2_critical_17.tStart = t  # local t and not account for scr refresh
            option2_critical_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_17, 'tStartRefresh')  # time at next scr refresh
            option2_critical_17.setAutoDraw(True)
        
        # *bosa3_2* updates
        if bosa3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bosa3_2.frameNStart = frameN  # exact frame index
            bosa3_2.tStart = t  # local t and not account for scr refresh
            bosa3_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bosa3_2, 'tStartRefresh')  # time at next scr refresh
            bosa3_2.setAutoDraw(True)
        
        # *polygon_8* updates
        if polygon_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_8.frameNStart = frameN  # exact frame index
            polygon_8.tStart = t  # local t and not account for scr refresh
            polygon_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_8, 'tStartRefresh')  # time at next scr refresh
            polygon_8.setAutoDraw(True)
        
        # *polygon_9* updates
        if polygon_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_9.frameNStart = frameN  # exact frame index
            polygon_9.tStart = t  # local t and not account for scr refresh
            polygon_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_9, 'tStartRefresh')  # time at next scr refresh
            polygon_9.setAutoDraw(True)
        
        # *polygon_10* updates
        if polygon_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_10.frameNStart = frameN  # exact frame index
            polygon_10.tStart = t  # local t and not account for scr refresh
            polygon_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_10, 'tStartRefresh')  # time at next scr refresh
            polygon_10.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in bosap1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "bosap1"-------
    for thisComponent in bosap1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_bosa_2.keys in ['', [], None]:  # No response was made
        key_resp_bosa_2.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_bosa_2.corr = 1;  # correct non-response
        else:
           key_resp_bosa_2.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_practice (TrialHandler)
    trials_practice.addData('key_resp_bosa_2.keys',key_resp_bosa_2.keys)
    trials_practice.addData('key_resp_bosa_2.corr', key_resp_bosa_2.corr)
    if key_resp_bosa_2.keys != None:  # we had a response
        trials_practice.addData('key_resp_bosa_2.rt', key_resp_bosa_2.rt)
    trials_practice.addData('key_resp_bosa_2.started', key_resp_bosa_2.tStartRefresh)
    trials_practice.addData('key_resp_bosa_2.stopped', key_resp_bosa_2.tStopRefresh)
    #''' update the number correct:'''
    if key_resp_bosa_2.corr: 
        number_correct_bosap = number_correct_bosap + 1
        print('number_correct_bosap: ' + str(number_correct_bosap))
    #     ''' if this is the final repetition, check the proportion correct.
    #         (am avoiding hard coding the value '12' for flexibility):'''
    if number_correct_bosap == 2:
        print('total Correct: ' + str(number_correct_bosap))
    # ''' terminate the outer loop so no more practice happens:'''
        trials_practice.finished = True
    else:
        print('flag2!')
        trials_practice.finished = False
    trials_practice.addData('blicket1_14.started', blicket1_14.tStartRefresh)
    trials_practice.addData('blicket1_14.stopped', blicket1_14.tStopRefresh)
    trials_practice.addData('option1_critical_17.started', option1_critical_17.tStartRefresh)
    trials_practice.addData('option1_critical_17.stopped', option1_critical_17.tStopRefresh)
    trials_practice.addData('option2_critical_17.started', option2_critical_17.tStartRefresh)
    trials_practice.addData('option2_critical_17.stopped', option2_critical_17.tStopRefresh)
    trials_practice.addData('bosa3_2.started', bosa3_2.tStartRefresh)
    trials_practice.addData('bosa3_2.stopped', bosa3_2.tStopRefresh)
    trials_practice.addData('polygon_8.started', polygon_8.tStartRefresh)
    trials_practice.addData('polygon_8.stopped', polygon_8.tStopRefresh)
    trials_practice.addData('polygon_9.started', polygon_9.tStartRefresh)
    trials_practice.addData('polygon_9.stopped', polygon_9.tStopRefresh)
    trials_practice.addData('polygon_10.started', polygon_10.tStartRefresh)
    trials_practice.addData('polygon_10.stopped', polygon_10.tStopRefresh)
    # the Routine "bosap1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_bosap1"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_bosa_2.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_bosa_2.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1_4.setText(msg1)
    feedback0_zud1_4.setText(msg0)
    feedback_zud01_4.setText(msg)
    # keep track of which components have finished
    fb_bosap1Components = [feedback1_zud1_4, feedback0_zud1_4, feedback_zud01_4]
    for thisComponent in fb_bosap1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_bosap1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_bosap1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_bosap1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_bosap1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1_4* updates
        if feedback1_zud1_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1_4.frameNStart = frameN  # exact frame index
            feedback1_zud1_4.tStart = t  # local t and not account for scr refresh
            feedback1_zud1_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1_4, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1_4.setAutoDraw(True)
        if feedback1_zud1_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1_4.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1_4.tStop = t  # not accounting for scr refresh
                feedback1_zud1_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1_4, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1_4.setAutoDraw(False)
        
        # *feedback0_zud1_4* updates
        if feedback0_zud1_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1_4.frameNStart = frameN  # exact frame index
            feedback0_zud1_4.tStart = t  # local t and not account for scr refresh
            feedback0_zud1_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1_4, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1_4.setAutoDraw(True)
        if feedback0_zud1_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1_4.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1_4.tStop = t  # not accounting for scr refresh
                feedback0_zud1_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1_4, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1_4.setAutoDraw(False)
        
        # *feedback_zud01_4* updates
        if feedback_zud01_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01_4.frameNStart = frameN  # exact frame index
            feedback_zud01_4.tStart = t  # local t and not account for scr refresh
            feedback_zud01_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01_4, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01_4.setAutoDraw(True)
        if feedback_zud01_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01_4.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01_4.tStop = t  # not accounting for scr refresh
                feedback_zud01_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01_4, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01_4.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_bosap1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_bosap1"-------
    for thisComponent in fb_bosap1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_practice.addData('feedback1_zud1_4.started', feedback1_zud1_4.tStartRefresh)
    trials_practice.addData('feedback1_zud1_4.stopped', feedback1_zud1_4.tStopRefresh)
    trials_practice.addData('feedback0_zud1_4.started', feedback0_zud1_4.tStartRefresh)
    trials_practice.addData('feedback0_zud1_4.stopped', feedback0_zud1_4.tStopRefresh)
    trials_practice.addData('feedback_zud01_4.started', feedback_zud01_4.tStartRefresh)
    trials_practice.addData('feedback_zud01_4.stopped', feedback_zud01_4.tStopRefresh)
    
    # ------Prepare to start Routine "bosap2"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_bosa_3.keys = []
    key_resp_bosa_3.rt = []
    _key_resp_bosa_3_allKeys = []
    # keep track of which components have finished
    bosap2Components = [key_resp_bosa_3, blicket1_15, option1_critical_18, option2_critical_18, bosa3_3, polygon_11, polygon_12, polygon_13]
    for thisComponent in bosap2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    bosap2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "bosap2"-------
    while continueRoutine:
        # get current time
        t = bosap2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=bosap2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_bosa_3* updates
        waitOnFlip = False
        if key_resp_bosa_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_bosa_3.frameNStart = frameN  # exact frame index
            key_resp_bosa_3.tStart = t  # local t and not account for scr refresh
            key_resp_bosa_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_bosa_3, 'tStartRefresh')  # time at next scr refresh
            key_resp_bosa_3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_bosa_3.clock.reset)  # t=0 on next screen flip
        if key_resp_bosa_3.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_bosa_3.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_bosa_3_allKeys.extend(theseKeys)
            if len(_key_resp_bosa_3_allKeys):
                key_resp_bosa_3.keys = _key_resp_bosa_3_allKeys[-1].name  # just the last key pressed
                key_resp_bosa_3.rt = _key_resp_bosa_3_allKeys[-1].rt
                # was this correct?
                if (key_resp_bosa_3.keys == str('3')) or (key_resp_bosa_3.keys == '3'):
                    key_resp_bosa_3.corr = 1
                else:
                    key_resp_bosa_3.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_15* updates
        if blicket1_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_15.frameNStart = frameN  # exact frame index
            blicket1_15.tStart = t  # local t and not account for scr refresh
            blicket1_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_15, 'tStartRefresh')  # time at next scr refresh
            blicket1_15.setAutoDraw(True)
        
        # *option1_critical_18* updates
        if option1_critical_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_18.frameNStart = frameN  # exact frame index
            option1_critical_18.tStart = t  # local t and not account for scr refresh
            option1_critical_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_18, 'tStartRefresh')  # time at next scr refresh
            option1_critical_18.setAutoDraw(True)
        
        # *option2_critical_18* updates
        if option2_critical_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_18.frameNStart = frameN  # exact frame index
            option2_critical_18.tStart = t  # local t and not account for scr refresh
            option2_critical_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_18, 'tStartRefresh')  # time at next scr refresh
            option2_critical_18.setAutoDraw(True)
        
        # *bosa3_3* updates
        if bosa3_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bosa3_3.frameNStart = frameN  # exact frame index
            bosa3_3.tStart = t  # local t and not account for scr refresh
            bosa3_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bosa3_3, 'tStartRefresh')  # time at next scr refresh
            bosa3_3.setAutoDraw(True)
        
        # *polygon_11* updates
        if polygon_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_11.frameNStart = frameN  # exact frame index
            polygon_11.tStart = t  # local t and not account for scr refresh
            polygon_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_11, 'tStartRefresh')  # time at next scr refresh
            polygon_11.setAutoDraw(True)
        
        # *polygon_12* updates
        if polygon_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_12.frameNStart = frameN  # exact frame index
            polygon_12.tStart = t  # local t and not account for scr refresh
            polygon_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_12, 'tStartRefresh')  # time at next scr refresh
            polygon_12.setAutoDraw(True)
        
        # *polygon_13* updates
        if polygon_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_13.frameNStart = frameN  # exact frame index
            polygon_13.tStart = t  # local t and not account for scr refresh
            polygon_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_13, 'tStartRefresh')  # time at next scr refresh
            polygon_13.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in bosap2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "bosap2"-------
    for thisComponent in bosap2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_bosa_3.keys in ['', [], None]:  # No response was made
        key_resp_bosa_3.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_bosa_3.corr = 1;  # correct non-response
        else:
           key_resp_bosa_3.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_practice (TrialHandler)
    trials_practice.addData('key_resp_bosa_3.keys',key_resp_bosa_3.keys)
    trials_practice.addData('key_resp_bosa_3.corr', key_resp_bosa_3.corr)
    if key_resp_bosa_3.keys != None:  # we had a response
        trials_practice.addData('key_resp_bosa_3.rt', key_resp_bosa_3.rt)
    trials_practice.addData('key_resp_bosa_3.started', key_resp_bosa_3.tStartRefresh)
    trials_practice.addData('key_resp_bosa_3.stopped', key_resp_bosa_3.tStopRefresh)
    if key_resp_bosa_3.corr:
        number_correct_bosap = number_correct_bosap + 1
        print('number_Correct: ' + str(number_correct_bosap))
    
    if number_correct_bosap == 2 : 
        print('total Correct: ' + str(number_correct_bosap))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_practice.finished = True
    else:
        print('flag!')
        trials_practice.finished = False
    trials_practice.addData('blicket1_15.started', blicket1_15.tStartRefresh)
    trials_practice.addData('blicket1_15.stopped', blicket1_15.tStopRefresh)
    trials_practice.addData('option1_critical_18.started', option1_critical_18.tStartRefresh)
    trials_practice.addData('option1_critical_18.stopped', option1_critical_18.tStopRefresh)
    trials_practice.addData('option2_critical_18.started', option2_critical_18.tStartRefresh)
    trials_practice.addData('option2_critical_18.stopped', option2_critical_18.tStopRefresh)
    trials_practice.addData('bosa3_3.started', bosa3_3.tStartRefresh)
    trials_practice.addData('bosa3_3.stopped', bosa3_3.tStopRefresh)
    trials_practice.addData('polygon_11.started', polygon_11.tStartRefresh)
    trials_practice.addData('polygon_11.stopped', polygon_11.tStopRefresh)
    trials_practice.addData('polygon_12.started', polygon_12.tStartRefresh)
    trials_practice.addData('polygon_12.stopped', polygon_12.tStopRefresh)
    trials_practice.addData('polygon_13.started', polygon_13.tStartRefresh)
    trials_practice.addData('polygon_13.stopped', polygon_13.tStopRefresh)
    # the Routine "bosap2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_bosap2"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_bosa_3.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_bosa_3.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1_5.setText(msg1)
    feedback0_zud1_5.setText(msg0)
    feedback_zud01_5.setText(msg)
    # keep track of which components have finished
    fb_bosap2Components = [feedback1_zud1_5, feedback0_zud1_5, feedback_zud01_5]
    for thisComponent in fb_bosap2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_bosap2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_bosap2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_bosap2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_bosap2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1_5* updates
        if feedback1_zud1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1_5.frameNStart = frameN  # exact frame index
            feedback1_zud1_5.tStart = t  # local t and not account for scr refresh
            feedback1_zud1_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1_5, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1_5.setAutoDraw(True)
        if feedback1_zud1_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1_5.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1_5.tStop = t  # not accounting for scr refresh
                feedback1_zud1_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1_5, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1_5.setAutoDraw(False)
        
        # *feedback0_zud1_5* updates
        if feedback0_zud1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1_5.frameNStart = frameN  # exact frame index
            feedback0_zud1_5.tStart = t  # local t and not account for scr refresh
            feedback0_zud1_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1_5, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1_5.setAutoDraw(True)
        if feedback0_zud1_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1_5.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1_5.tStop = t  # not accounting for scr refresh
                feedback0_zud1_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1_5, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1_5.setAutoDraw(False)
        
        # *feedback_zud01_5* updates
        if feedback_zud01_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01_5.frameNStart = frameN  # exact frame index
            feedback_zud01_5.tStart = t  # local t and not account for scr refresh
            feedback_zud01_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01_5, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01_5.setAutoDraw(True)
        if feedback_zud01_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01_5.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01_5.tStop = t  # not accounting for scr refresh
                feedback_zud01_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01_5, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01_5.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_bosap2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_bosap2"-------
    for thisComponent in fb_bosap2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_practice.addData('feedback1_zud1_5.started', feedback1_zud1_5.tStartRefresh)
    trials_practice.addData('feedback1_zud1_5.stopped', feedback1_zud1_5.tStopRefresh)
    trials_practice.addData('feedback0_zud1_5.started', feedback0_zud1_5.tStartRefresh)
    trials_practice.addData('feedback0_zud1_5.stopped', feedback0_zud1_5.tStopRefresh)
    trials_practice.addData('feedback_zud01_5.started', feedback_zud01_5.tStartRefresh)
    trials_practice.addData('feedback_zud01_5.stopped', feedback_zud01_5.tStopRefresh)
    thisExp.nextEntry()
    
# completed 3.0 repeats of 'trials_practice'


# ------Prepare to start Routine "proceed"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_6.keys = []
key_resp_6.rt = []
_key_resp_6_allKeys = []
# keep track of which components have finished
proceedComponents = [text2, key_resp_6]
for thisComponent in proceedComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
proceedClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "proceed"-------
while continueRoutine:
    # get current time
    t = proceedClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=proceedClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text2* updates
    if text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text2.frameNStart = frameN  # exact frame index
        text2.tStart = t  # local t and not account for scr refresh
        text2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text2, 'tStartRefresh')  # time at next scr refresh
        text2.setAutoDraw(True)
    
    # *key_resp_6* updates
    waitOnFlip = False
    if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_6.frameNStart = frameN  # exact frame index
        key_resp_6.tStart = t  # local t and not account for scr refresh
        key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
        key_resp_6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_6.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_6_allKeys.extend(theseKeys)
        if len(_key_resp_6_allKeys):
            key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
            key_resp_6.rt = _key_resp_6_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in proceedComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "proceed"-------
for thisComponent in proceedComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text2.started', text2.tStartRefresh)
thisExp.addData('text2.stopped', text2.tStopRefresh)
# check responses
if key_resp_6.keys in ['', [], None]:  # No response was made
    key_resp_6.keys = None
thisExp.addData('key_resp_6.keys',key_resp_6.keys)
if key_resp_6.keys != None:  # we had a response
    thisExp.addData('key_resp_6.rt', key_resp_6.rt)
thisExp.addData('key_resp_6.started', key_resp_6.tStartRefresh)
thisExp.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
thisExp.nextEntry()
# the Routine "proceed" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "bosap_test"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_bosa_4.keys = []
key_resp_bosa_4.rt = []
_key_resp_bosa_4_allKeys = []
# keep track of which components have finished
bosap_testComponents = [key_resp_bosa_4, blicket1_16, option1_critical_19, option2_critical_19, bosa3_4, polygon_14, polygon_15, polygon_16]
for thisComponent in bosap_testComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
bosap_testClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "bosap_test"-------
while continueRoutine:
    # get current time
    t = bosap_testClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=bosap_testClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *key_resp_bosa_4* updates
    waitOnFlip = False
    if key_resp_bosa_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_bosa_4.frameNStart = frameN  # exact frame index
        key_resp_bosa_4.tStart = t  # local t and not account for scr refresh
        key_resp_bosa_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_bosa_4, 'tStartRefresh')  # time at next scr refresh
        key_resp_bosa_4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_bosa_4.clock.reset)  # t=0 on next screen flip
    if key_resp_bosa_4.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_bosa_4.getKeys(keyList=['1', '2', '3'], waitRelease=False)
        _key_resp_bosa_4_allKeys.extend(theseKeys)
        if len(_key_resp_bosa_4_allKeys):
            key_resp_bosa_4.keys = _key_resp_bosa_4_allKeys[-1].name  # just the last key pressed
            key_resp_bosa_4.rt = _key_resp_bosa_4_allKeys[-1].rt
            # was this correct?
            if (key_resp_bosa_4.keys == str('3')) or (key_resp_bosa_4.keys == '3'):
                key_resp_bosa_4.corr = 1
            else:
                key_resp_bosa_4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # *blicket1_16* updates
    if blicket1_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        blicket1_16.frameNStart = frameN  # exact frame index
        blicket1_16.tStart = t  # local t and not account for scr refresh
        blicket1_16.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(blicket1_16, 'tStartRefresh')  # time at next scr refresh
        blicket1_16.setAutoDraw(True)
    
    # *option1_critical_19* updates
    if option1_critical_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option1_critical_19.frameNStart = frameN  # exact frame index
        option1_critical_19.tStart = t  # local t and not account for scr refresh
        option1_critical_19.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option1_critical_19, 'tStartRefresh')  # time at next scr refresh
        option1_critical_19.setAutoDraw(True)
    
    # *option2_critical_19* updates
    if option2_critical_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option2_critical_19.frameNStart = frameN  # exact frame index
        option2_critical_19.tStart = t  # local t and not account for scr refresh
        option2_critical_19.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option2_critical_19, 'tStartRefresh')  # time at next scr refresh
        option2_critical_19.setAutoDraw(True)
    
    # *bosa3_4* updates
    if bosa3_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        bosa3_4.frameNStart = frameN  # exact frame index
        bosa3_4.tStart = t  # local t and not account for scr refresh
        bosa3_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(bosa3_4, 'tStartRefresh')  # time at next scr refresh
        bosa3_4.setAutoDraw(True)
    
    # *polygon_14* updates
    if polygon_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        polygon_14.frameNStart = frameN  # exact frame index
        polygon_14.tStart = t  # local t and not account for scr refresh
        polygon_14.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(polygon_14, 'tStartRefresh')  # time at next scr refresh
        polygon_14.setAutoDraw(True)
    
    # *polygon_15* updates
    if polygon_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        polygon_15.frameNStart = frameN  # exact frame index
        polygon_15.tStart = t  # local t and not account for scr refresh
        polygon_15.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(polygon_15, 'tStartRefresh')  # time at next scr refresh
        polygon_15.setAutoDraw(True)
    
    # *polygon_16* updates
    if polygon_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        polygon_16.frameNStart = frameN  # exact frame index
        polygon_16.tStart = t  # local t and not account for scr refresh
        polygon_16.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(polygon_16, 'tStartRefresh')  # time at next scr refresh
        polygon_16.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in bosap_testComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "bosap_test"-------
for thisComponent in bosap_testComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if key_resp_bosa_4.keys in ['', [], None]:  # No response was made
    key_resp_bosa_4.keys = None
    # was no response the correct answer?!
    if str('3').lower() == 'none':
       key_resp_bosa_4.corr = 1;  # correct non-response
    else:
       key_resp_bosa_4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_bosa_4.keys',key_resp_bosa_4.keys)
thisExp.addData('key_resp_bosa_4.corr', key_resp_bosa_4.corr)
if key_resp_bosa_4.keys != None:  # we had a response
    thisExp.addData('key_resp_bosa_4.rt', key_resp_bosa_4.rt)
thisExp.addData('key_resp_bosa_4.started', key_resp_bosa_4.tStartRefresh)
thisExp.addData('key_resp_bosa_4.stopped', key_resp_bosa_4.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('blicket1_16.started', blicket1_16.tStartRefresh)
thisExp.addData('blicket1_16.stopped', blicket1_16.tStopRefresh)
thisExp.addData('option1_critical_19.started', option1_critical_19.tStartRefresh)
thisExp.addData('option1_critical_19.stopped', option1_critical_19.tStopRefresh)
thisExp.addData('option2_critical_19.started', option2_critical_19.tStartRefresh)
thisExp.addData('option2_critical_19.stopped', option2_critical_19.tStopRefresh)
thisExp.addData('bosa3_4.started', bosa3_4.tStartRefresh)
thisExp.addData('bosa3_4.stopped', bosa3_4.tStopRefresh)
thisExp.addData('polygon_14.started', polygon_14.tStartRefresh)
thisExp.addData('polygon_14.stopped', polygon_14.tStopRefresh)
thisExp.addData('polygon_15.started', polygon_15.tStartRefresh)
thisExp.addData('polygon_15.stopped', polygon_15.tStopRefresh)
thisExp.addData('polygon_16.started', polygon_16.tStartRefresh)
thisExp.addData('polygon_16.stopped', polygon_16.tStopRefresh)
# the Routine "bosap_test" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "practice_trial_end"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_3.keys = []
key_resp_3.rt = []
_key_resp_3_allKeys = []
# keep track of which components have finished
practice_trial_endComponents = [text_5, key_resp_3]
for thisComponent in practice_trial_endComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
practice_trial_endClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "practice_trial_end"-------
while continueRoutine:
    # get current time
    t = practice_trial_endClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=practice_trial_endClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text_5* updates
    if text_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_5.frameNStart = frameN  # exact frame index
        text_5.tStart = t  # local t and not account for scr refresh
        text_5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
        text_5.setAutoDraw(True)
    
    # *key_resp_3* updates
    waitOnFlip = False
    if key_resp_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_3.frameNStart = frameN  # exact frame index
        key_resp_3.tStart = t  # local t and not account for scr refresh
        key_resp_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_3, 'tStartRefresh')  # time at next scr refresh
        key_resp_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_3.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_3_allKeys.extend(theseKeys)
        if len(_key_resp_3_allKeys):
            key_resp_3.keys = _key_resp_3_allKeys[-1].name  # just the last key pressed
            key_resp_3.rt = _key_resp_3_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in practice_trial_endComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "practice_trial_end"-------
for thisComponent in practice_trial_endComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text_5.started', text_5.tStartRefresh)
thisExp.addData('text_5.stopped', text_5.tStopRefresh)
# check responses
if key_resp_3.keys in ['', [], None]:  # No response was made
    key_resp_3.keys = None
thisExp.addData('key_resp_3.keys',key_resp_3.keys)
if key_resp_3.keys != None:  # we had a response
    thisExp.addData('key_resp_3.rt', key_resp_3.rt)
thisExp.addData('key_resp_3.started', key_resp_3.tStartRefresh)
thisExp.addData('key_resp_3.stopped', key_resp_3.tStopRefresh)
thisExp.nextEntry()
# the Routine "practice_trial_end" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "phase1"-------
continueRoutine = True
routineTimer.add(2.000000)
# update component parameters for each repeat
text.setText('Phase 1')
# keep track of which components have finished
phase1Components = [text]
for thisComponent in phase1Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
phase1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "phase1"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = phase1Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=phase1Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text* updates
    if text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text.frameNStart = frameN  # exact frame index
        text.tStart = t  # local t and not account for scr refresh
        text.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
        text.setAutoDraw(True)
    if text.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text.tStop = t  # not accounting for scr refresh
            text.frameNStop = frameN  # exact frame index
            win.timeOnFlip(text, 'tStopRefresh')  # time at next scr refresh
            text.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in phase1Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "phase1"-------
for thisComponent in phase1Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text.started', text.tStartRefresh)
thisExp.addData('text.stopped', text.tStopRefresh)

# set up handler to look after randomisation of conditions etc
trials_phase1 = data.TrialHandler(nReps=4.0, method='random', 
    extraInfo=expInfo, originPath=-1,
    trialList=[None],
    seed=None, name='trials_phase1')
thisExp.addLoop(trials_phase1)  # add the loop to the experiment
thisTrials_phase1 = trials_phase1.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTrials_phase1.rgb)
if thisTrials_phase1 != None:
    for paramName in thisTrials_phase1:
        exec('{} = thisTrials_phase1[paramName]'.format(paramName))

for thisTrials_phase1 in trials_phase1:
    currentLoop = trials_phase1
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_phase1.rgb)
    if thisTrials_phase1 != None:
        for paramName in thisTrials_phase1:
            exec('{} = thisTrials_phase1[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "start_2"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # keep track of which components have finished
    start_2Components = [text1, key_resp_7]
    for thisComponent in start_2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    start_2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "start_2"-------
    while continueRoutine:
        # get current time
        t = start_2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=start_2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text1* updates
        if text1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text1.frameNStart = frameN  # exact frame index
            text1.tStart = t  # local t and not account for scr refresh
            text1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text1, 'tStartRefresh')  # time at next scr refresh
            text1.setAutoDraw(True)
        
        # *key_resp_7* updates
        waitOnFlip = False
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "start_2"-------
    for thisComponent in start_2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('text1.started', text1.tStartRefresh)
    trials_phase1.addData('text1.stopped', text1.tStopRefresh)
    # check responses
    if key_resp_7.keys in ['', [], None]:  # No response was made
        key_resp_7.keys = None
    trials_phase1.addData('key_resp_7.keys',key_resp_7.keys)
    if key_resp_7.keys != None:  # we had a response
        trials_phase1.addData('key_resp_7.rt', key_resp_7.rt)
    trials_phase1.addData('key_resp_7.started', key_resp_7.tStartRefresh)
    trials_phase1.addData('key_resp_7.stopped', key_resp_7.tStopRefresh)
    # the Routine "start_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "blank"-------
    continueRoutine = True
    routineTimer.add(0.200000)
    # update component parameters for each repeat
    # keep track of which components have finished
    blankComponents = [blank500ms]
    for thisComponent in blankComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blank"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = blankClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blankClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blank500ms* updates
        if blank500ms.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blank500ms.frameNStart = frameN  # exact frame index
            blank500ms.tStart = t  # local t and not account for scr refresh
            blank500ms.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blank500ms, 'tStartRefresh')  # time at next scr refresh
            blank500ms.setAutoDraw(True)
        if blank500ms.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blank500ms.tStartRefresh + 0.2-frameTolerance:
                # keep track of stop time/frame for later
                blank500ms.tStop = t  # not accounting for scr refresh
                blank500ms.frameNStop = frameN  # exact frame index
                win.timeOnFlip(blank500ms, 'tStopRefresh')  # time at next scr refresh
                blank500ms.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blankComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blank"-------
    for thisComponent in blankComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('blank500ms.started', blank500ms.tStartRefresh)
    trials_phase1.addData('blank500ms.stopped', blank500ms.tStopRefresh)
    
    # ------Prepare to start Routine "zud1"-------
    continueRoutine = True
    # update component parameters for each repeat
    number_correct=0
    star_1.setFillColor('black')
    triangle_1.setFillColor('black')
    cross_1.setFillColor('black')
    key_resp_zud1.keys = []
    key_resp_zud1.rt = []
    _key_resp_zud1_allKeys = []
    # keep track of which components have finished
    zud1Components = [zud1_corr2, star_1, triangle_1, cross_1, option1_01, option2_01, option3_01, key_resp_zud1]
    for thisComponent in zud1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud1"-------
    while continueRoutine:
        # get current time
        t = zud1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud1_corr2* updates
        if zud1_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud1_corr2.frameNStart = frameN  # exact frame index
            zud1_corr2.tStart = t  # local t and not account for scr refresh
            zud1_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud1_corr2, 'tStartRefresh')  # time at next scr refresh
            zud1_corr2.setAutoDraw(True)
        
        # *star_1* updates
        if star_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_1.frameNStart = frameN  # exact frame index
            star_1.tStart = t  # local t and not account for scr refresh
            star_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_1, 'tStartRefresh')  # time at next scr refresh
            star_1.setAutoDraw(True)
        
        # *triangle_1* updates
        if triangle_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_1.frameNStart = frameN  # exact frame index
            triangle_1.tStart = t  # local t and not account for scr refresh
            triangle_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_1, 'tStartRefresh')  # time at next scr refresh
            triangle_1.setAutoDraw(True)
        
        # *cross_1* updates
        if cross_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_1.frameNStart = frameN  # exact frame index
            cross_1.tStart = t  # local t and not account for scr refresh
            cross_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_1, 'tStartRefresh')  # time at next scr refresh
            cross_1.setAutoDraw(True)
        
        # *option1_01* updates
        if option1_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_01.frameNStart = frameN  # exact frame index
            option1_01.tStart = t  # local t and not account for scr refresh
            option1_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_01, 'tStartRefresh')  # time at next scr refresh
            option1_01.setAutoDraw(True)
        
        # *option2_01* updates
        if option2_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_01.frameNStart = frameN  # exact frame index
            option2_01.tStart = t  # local t and not account for scr refresh
            option2_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_01, 'tStartRefresh')  # time at next scr refresh
            option2_01.setAutoDraw(True)
        
        # *option3_01* updates
        if option3_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_01.frameNStart = frameN  # exact frame index
            option3_01.tStart = t  # local t and not account for scr refresh
            option3_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_01, 'tStartRefresh')  # time at next scr refresh
            option3_01.setAutoDraw(True)
        
        # *key_resp_zud1* updates
        waitOnFlip = False
        if key_resp_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud1.frameNStart = frameN  # exact frame index
            key_resp_zud1.tStart = t  # local t and not account for scr refresh
            key_resp_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud1, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud1.clock.reset)  # t=0 on next screen flip
        if key_resp_zud1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud1.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud1_allKeys.extend(theseKeys)
            if len(_key_resp_zud1_allKeys):
                key_resp_zud1.keys = _key_resp_zud1_allKeys[-1].name  # just the last key pressed
                key_resp_zud1.rt = _key_resp_zud1_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud1.keys == str('2')) or (key_resp_zud1.keys == '2'):
                    key_resp_zud1.corr = 1
                else:
                    key_resp_zud1.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud1"-------
    for thisComponent in zud1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('zud1_corr2.started', zud1_corr2.tStartRefresh)
    trials_phase1.addData('zud1_corr2.stopped', zud1_corr2.tStopRefresh)
    number_correct = number_correct + 1
    
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('star_1.started', star_1.tStartRefresh)
    trials_phase1.addData('star_1.stopped', star_1.tStopRefresh)
    trials_phase1.addData('triangle_1.started', triangle_1.tStartRefresh)
    trials_phase1.addData('triangle_1.stopped', triangle_1.tStopRefresh)
    trials_phase1.addData('cross_1.started', cross_1.tStartRefresh)
    trials_phase1.addData('cross_1.stopped', cross_1.tStopRefresh)
    trials_phase1.addData('option1_01.started', option1_01.tStartRefresh)
    trials_phase1.addData('option1_01.stopped', option1_01.tStopRefresh)
    trials_phase1.addData('option2_01.started', option2_01.tStartRefresh)
    trials_phase1.addData('option2_01.stopped', option2_01.tStopRefresh)
    trials_phase1.addData('option3_01.started', option3_01.tStartRefresh)
    trials_phase1.addData('option3_01.stopped', option3_01.tStopRefresh)
    # check responses
    if key_resp_zud1.keys in ['', [], None]:  # No response was made
        key_resp_zud1.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_zud1.corr = 1;  # correct non-response
        else:
           key_resp_zud1.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_zud1.keys',key_resp_zud1.keys)
    trials_phase1.addData('key_resp_zud1.corr', key_resp_zud1.corr)
    if key_resp_zud1.keys != None:  # we had a response
        trials_phase1.addData('key_resp_zud1.rt', key_resp_zud1.rt)
    trials_phase1.addData('key_resp_zud1.started', key_resp_zud1.tStartRefresh)
    trials_phase1.addData('key_resp_zud1.stopped', key_resp_zud1.tStopRefresh)
    # the Routine "zud1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud1"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud1.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud1.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1.setText(msg1)
    feedback0_zud1.setText(msg0)
    feedback_zud01.setText(msg)
    # keep track of which components have finished
    fb_zud1Components = [feedback1_zud1, feedback0_zud1, feedback_zud01]
    for thisComponent in fb_zud1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1* updates
        if feedback1_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1.frameNStart = frameN  # exact frame index
            feedback1_zud1.tStart = t  # local t and not account for scr refresh
            feedback1_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1.setAutoDraw(True)
        if feedback1_zud1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1.tStop = t  # not accounting for scr refresh
                feedback1_zud1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1.setAutoDraw(False)
        
        # *feedback0_zud1* updates
        if feedback0_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1.frameNStart = frameN  # exact frame index
            feedback0_zud1.tStart = t  # local t and not account for scr refresh
            feedback0_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1.setAutoDraw(True)
        if feedback0_zud1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1.tStop = t  # not accounting for scr refresh
                feedback0_zud1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1.setAutoDraw(False)
        
        # *feedback_zud01* updates
        if feedback_zud01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01.frameNStart = frameN  # exact frame index
            feedback_zud01.tStart = t  # local t and not account for scr refresh
            feedback_zud01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01.setAutoDraw(True)
        if feedback_zud01.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01.tStop = t  # not accounting for scr refresh
                feedback_zud01.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud1"-------
    for thisComponent in fb_zud1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud1.started', feedback1_zud1.tStartRefresh)
    trials_phase1.addData('feedback1_zud1.stopped', feedback1_zud1.tStopRefresh)
    trials_phase1.addData('feedback0_zud1.started', feedback0_zud1.tStartRefresh)
    trials_phase1.addData('feedback0_zud1.stopped', feedback0_zud1.tStopRefresh)
    trials_phase1.addData('feedback_zud01.started', feedback_zud01.tStartRefresh)
    trials_phase1.addData('feedback_zud01.stopped', feedback_zud01.tStopRefresh)
    
    # ------Prepare to start Routine "zud2"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_2.setFillColor('black')
    star_2.setFillColor('black')
    cross_2.setFillColor('black')
    key_resp_zud2.keys = []
    key_resp_zud2.rt = []
    _key_resp_zud2_allKeys = []
    # keep track of which components have finished
    zud2Components = [zud2_corr1, triangle_2, star_2, cross_2, key_resp_zud2, option1_02, option2_02, option3_02]
    for thisComponent in zud2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud2"-------
    while continueRoutine:
        # get current time
        t = zud2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud2_corr1* updates
        if zud2_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud2_corr1.frameNStart = frameN  # exact frame index
            zud2_corr1.tStart = t  # local t and not account for scr refresh
            zud2_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud2_corr1, 'tStartRefresh')  # time at next scr refresh
            zud2_corr1.setAutoDraw(True)
        
        # *triangle_2* updates
        if triangle_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_2.frameNStart = frameN  # exact frame index
            triangle_2.tStart = t  # local t and not account for scr refresh
            triangle_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_2, 'tStartRefresh')  # time at next scr refresh
            triangle_2.setAutoDraw(True)
        
        # *star_2* updates
        if star_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_2.frameNStart = frameN  # exact frame index
            star_2.tStart = t  # local t and not account for scr refresh
            star_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_2, 'tStartRefresh')  # time at next scr refresh
            star_2.setAutoDraw(True)
        
        # *cross_2* updates
        if cross_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_2.frameNStart = frameN  # exact frame index
            cross_2.tStart = t  # local t and not account for scr refresh
            cross_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_2, 'tStartRefresh')  # time at next scr refresh
            cross_2.setAutoDraw(True)
        
        # *key_resp_zud2* updates
        waitOnFlip = False
        if key_resp_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud2.frameNStart = frameN  # exact frame index
            key_resp_zud2.tStart = t  # local t and not account for scr refresh
            key_resp_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud2, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud2.clock.reset)  # t=0 on next screen flip
        if key_resp_zud2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud2_allKeys.extend(theseKeys)
            if len(_key_resp_zud2_allKeys):
                key_resp_zud2.keys = _key_resp_zud2_allKeys[-1].name  # just the last key pressed
                key_resp_zud2.rt = _key_resp_zud2_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud2.keys == str('1')) or (key_resp_zud2.keys == '1'):
                    key_resp_zud2.corr = 1
                else:
                    key_resp_zud2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_02* updates
        if option1_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_02.frameNStart = frameN  # exact frame index
            option1_02.tStart = t  # local t and not account for scr refresh
            option1_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_02, 'tStartRefresh')  # time at next scr refresh
            option1_02.setAutoDraw(True)
        
        # *option2_02* updates
        if option2_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_02.frameNStart = frameN  # exact frame index
            option2_02.tStart = t  # local t and not account for scr refresh
            option2_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_02, 'tStartRefresh')  # time at next scr refresh
            option2_02.setAutoDraw(True)
        
        # *option3_02* updates
        if option3_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_02.frameNStart = frameN  # exact frame index
            option3_02.tStart = t  # local t and not account for scr refresh
            option3_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_02, 'tStartRefresh')  # time at next scr refresh
            option3_02.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud2"-------
    for thisComponent in zud2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('zud2_corr1.started', zud2_corr1.tStartRefresh)
    trials_phase1.addData('zud2_corr1.stopped', zud2_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('triangle_2.started', triangle_2.tStartRefresh)
    trials_phase1.addData('triangle_2.stopped', triangle_2.tStopRefresh)
    trials_phase1.addData('star_2.started', star_2.tStartRefresh)
    trials_phase1.addData('star_2.stopped', star_2.tStopRefresh)
    trials_phase1.addData('cross_2.started', cross_2.tStartRefresh)
    trials_phase1.addData('cross_2.stopped', cross_2.tStopRefresh)
    # check responses
    if key_resp_zud2.keys in ['', [], None]:  # No response was made
        key_resp_zud2.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud2.corr = 1;  # correct non-response
        else:
           key_resp_zud2.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_zud2.keys',key_resp_zud2.keys)
    trials_phase1.addData('key_resp_zud2.corr', key_resp_zud2.corr)
    if key_resp_zud2.keys != None:  # we had a response
        trials_phase1.addData('key_resp_zud2.rt', key_resp_zud2.rt)
    trials_phase1.addData('key_resp_zud2.started', key_resp_zud2.tStartRefresh)
    trials_phase1.addData('key_resp_zud2.stopped', key_resp_zud2.tStopRefresh)
    trials_phase1.addData('option1_02.started', option1_02.tStartRefresh)
    trials_phase1.addData('option1_02.stopped', option1_02.tStopRefresh)
    trials_phase1.addData('option2_02.started', option2_02.tStartRefresh)
    trials_phase1.addData('option2_02.stopped', option2_02.tStopRefresh)
    trials_phase1.addData('option3_02.started', option3_02.tStartRefresh)
    trials_phase1.addData('option3_02.stopped', option3_02.tStopRefresh)
    # the Routine "zud2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud2"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud2.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud2.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud2.setText(msg1)
    feedback0_zud2.setText(msg0)
    feedback_zud02.setText(msg)
    # keep track of which components have finished
    fb_zud2Components = [feedback1_zud2, feedback0_zud2, feedback_zud02]
    for thisComponent in fb_zud2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud2* updates
        if feedback1_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud2.frameNStart = frameN  # exact frame index
            feedback1_zud2.tStart = t  # local t and not account for scr refresh
            feedback1_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud2, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud2.setAutoDraw(True)
        if feedback1_zud2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud2.tStop = t  # not accounting for scr refresh
                feedback1_zud2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud2, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud2.setAutoDraw(False)
        
        # *feedback0_zud2* updates
        if feedback0_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud2.frameNStart = frameN  # exact frame index
            feedback0_zud2.tStart = t  # local t and not account for scr refresh
            feedback0_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud2, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud2.setAutoDraw(True)
        if feedback0_zud2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud2.tStop = t  # not accounting for scr refresh
                feedback0_zud2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud2, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud2.setAutoDraw(False)
        
        # *feedback_zud02* updates
        if feedback_zud02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud02.frameNStart = frameN  # exact frame index
            feedback_zud02.tStart = t  # local t and not account for scr refresh
            feedback_zud02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud02, 'tStartRefresh')  # time at next scr refresh
            feedback_zud02.setAutoDraw(True)
        if feedback_zud02.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud02.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud02.tStop = t  # not accounting for scr refresh
                feedback_zud02.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud02, 'tStopRefresh')  # time at next scr refresh
                feedback_zud02.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud2"-------
    for thisComponent in fb_zud2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud2.started', feedback1_zud2.tStartRefresh)
    trials_phase1.addData('feedback1_zud2.stopped', feedback1_zud2.tStopRefresh)
    trials_phase1.addData('feedback0_zud2.started', feedback0_zud2.tStartRefresh)
    trials_phase1.addData('feedback0_zud2.stopped', feedback0_zud2.tStopRefresh)
    trials_phase1.addData('feedback_zud02.started', feedback_zud02.tStartRefresh)
    trials_phase1.addData('feedback_zud02.stopped', feedback_zud02.tStopRefresh)
    
    # ------Prepare to start Routine "zud3"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_3.setFillColor('white')
    star_3.setFillColor('white')
    cross_3.setFillColor('white')
    key_resp_zud3.keys = []
    key_resp_zud3.rt = []
    _key_resp_zud3_allKeys = []
    # keep track of which components have finished
    zud3Components = [zud3_corr1, triangle_3, star_3, cross_3, key_resp_zud3, option1_03, option2_03, option3_03]
    for thisComponent in zud3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud3"-------
    while continueRoutine:
        # get current time
        t = zud3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud3_corr1* updates
        if zud3_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud3_corr1.frameNStart = frameN  # exact frame index
            zud3_corr1.tStart = t  # local t and not account for scr refresh
            zud3_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud3_corr1, 'tStartRefresh')  # time at next scr refresh
            zud3_corr1.setAutoDraw(True)
        
        # *triangle_3* updates
        if triangle_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_3.frameNStart = frameN  # exact frame index
            triangle_3.tStart = t  # local t and not account for scr refresh
            triangle_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_3, 'tStartRefresh')  # time at next scr refresh
            triangle_3.setAutoDraw(True)
        
        # *star_3* updates
        if star_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_3.frameNStart = frameN  # exact frame index
            star_3.tStart = t  # local t and not account for scr refresh
            star_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_3, 'tStartRefresh')  # time at next scr refresh
            star_3.setAutoDraw(True)
        
        # *cross_3* updates
        if cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_3.frameNStart = frameN  # exact frame index
            cross_3.tStart = t  # local t and not account for scr refresh
            cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_3, 'tStartRefresh')  # time at next scr refresh
            cross_3.setAutoDraw(True)
        
        # *key_resp_zud3* updates
        waitOnFlip = False
        if key_resp_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud3.frameNStart = frameN  # exact frame index
            key_resp_zud3.tStart = t  # local t and not account for scr refresh
            key_resp_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud3, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud3.clock.reset)  # t=0 on next screen flip
        if key_resp_zud3.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud3.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud3_allKeys.extend(theseKeys)
            if len(_key_resp_zud3_allKeys):
                key_resp_zud3.keys = _key_resp_zud3_allKeys[-1].name  # just the last key pressed
                key_resp_zud3.rt = _key_resp_zud3_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud3.keys == str('1')) or (key_resp_zud3.keys == '1'):
                    key_resp_zud3.corr = 1
                else:
                    key_resp_zud3.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_03* updates
        if option1_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_03.frameNStart = frameN  # exact frame index
            option1_03.tStart = t  # local t and not account for scr refresh
            option1_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_03, 'tStartRefresh')  # time at next scr refresh
            option1_03.setAutoDraw(True)
        
        # *option2_03* updates
        if option2_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_03.frameNStart = frameN  # exact frame index
            option2_03.tStart = t  # local t and not account for scr refresh
            option2_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_03, 'tStartRefresh')  # time at next scr refresh
            option2_03.setAutoDraw(True)
        
        # *option3_03* updates
        if option3_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_03.frameNStart = frameN  # exact frame index
            option3_03.tStart = t  # local t and not account for scr refresh
            option3_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_03, 'tStartRefresh')  # time at next scr refresh
            option3_03.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud3"-------
    for thisComponent in zud3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('zud3_corr1.started', zud3_corr1.tStartRefresh)
    trials_phase1.addData('zud3_corr1.stopped', zud3_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('triangle_3.started', triangle_3.tStartRefresh)
    trials_phase1.addData('triangle_3.stopped', triangle_3.tStopRefresh)
    trials_phase1.addData('star_3.started', star_3.tStartRefresh)
    trials_phase1.addData('star_3.stopped', star_3.tStopRefresh)
    trials_phase1.addData('cross_3.started', cross_3.tStartRefresh)
    trials_phase1.addData('cross_3.stopped', cross_3.tStopRefresh)
    # check responses
    if key_resp_zud3.keys in ['', [], None]:  # No response was made
        key_resp_zud3.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud3.corr = 1;  # correct non-response
        else:
           key_resp_zud3.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_zud3.keys',key_resp_zud3.keys)
    trials_phase1.addData('key_resp_zud3.corr', key_resp_zud3.corr)
    if key_resp_zud3.keys != None:  # we had a response
        trials_phase1.addData('key_resp_zud3.rt', key_resp_zud3.rt)
    trials_phase1.addData('key_resp_zud3.started', key_resp_zud3.tStartRefresh)
    trials_phase1.addData('key_resp_zud3.stopped', key_resp_zud3.tStopRefresh)
    trials_phase1.addData('option1_03.started', option1_03.tStartRefresh)
    trials_phase1.addData('option1_03.stopped', option1_03.tStopRefresh)
    trials_phase1.addData('option2_03.started', option2_03.tStartRefresh)
    trials_phase1.addData('option2_03.stopped', option2_03.tStopRefresh)
    trials_phase1.addData('option3_03.started', option3_03.tStartRefresh)
    trials_phase1.addData('option3_03.stopped', option3_03.tStopRefresh)
    # the Routine "zud3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud3"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud3.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud3.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud3.setText(msg1)
    feedback0_zud3.setText(msg0)
    feedback_zud03.setText(msg)
    # keep track of which components have finished
    fb_zud3Components = [feedback1_zud3, feedback0_zud3, feedback_zud03]
    for thisComponent in fb_zud3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud3"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud3* updates
        if feedback1_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud3.frameNStart = frameN  # exact frame index
            feedback1_zud3.tStart = t  # local t and not account for scr refresh
            feedback1_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud3, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud3.setAutoDraw(True)
        if feedback1_zud3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud3.tStop = t  # not accounting for scr refresh
                feedback1_zud3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud3, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud3.setAutoDraw(False)
        
        # *feedback0_zud3* updates
        if feedback0_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud3.frameNStart = frameN  # exact frame index
            feedback0_zud3.tStart = t  # local t and not account for scr refresh
            feedback0_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud3, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud3.setAutoDraw(True)
        if feedback0_zud3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud3.tStop = t  # not accounting for scr refresh
                feedback0_zud3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud3, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud3.setAutoDraw(False)
        
        # *feedback_zud03* updates
        if feedback_zud03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud03.frameNStart = frameN  # exact frame index
            feedback_zud03.tStart = t  # local t and not account for scr refresh
            feedback_zud03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud03, 'tStartRefresh')  # time at next scr refresh
            feedback_zud03.setAutoDraw(True)
        if feedback_zud03.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud03.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud03.tStop = t  # not accounting for scr refresh
                feedback_zud03.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud03, 'tStopRefresh')  # time at next scr refresh
                feedback_zud03.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud3"-------
    for thisComponent in fb_zud3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud3.started', feedback1_zud3.tStartRefresh)
    trials_phase1.addData('feedback1_zud3.stopped', feedback1_zud3.tStopRefresh)
    trials_phase1.addData('feedback0_zud3.started', feedback0_zud3.tStartRefresh)
    trials_phase1.addData('feedback0_zud3.stopped', feedback0_zud3.tStopRefresh)
    trials_phase1.addData('feedback_zud03.started', feedback_zud03.tStartRefresh)
    trials_phase1.addData('feedback_zud03.stopped', feedback_zud03.tStopRefresh)
    
    # ------Prepare to start Routine "zud4"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_4.setFillColor('white')
    star_4.setFillColor('white')
    cross_4.setFillColor('white')
    key_resp_zud4.keys = []
    key_resp_zud4.rt = []
    _key_resp_zud4_allKeys = []
    # keep track of which components have finished
    zud4Components = [zud4_corr1, triangle_4, star_4, cross_4, key_resp_zud4, option1_04, option2_04, option3_04]
    for thisComponent in zud4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud4"-------
    while continueRoutine:
        # get current time
        t = zud4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud4_corr1* updates
        if zud4_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud4_corr1.frameNStart = frameN  # exact frame index
            zud4_corr1.tStart = t  # local t and not account for scr refresh
            zud4_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud4_corr1, 'tStartRefresh')  # time at next scr refresh
            zud4_corr1.setAutoDraw(True)
        
        # *triangle_4* updates
        if triangle_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_4.frameNStart = frameN  # exact frame index
            triangle_4.tStart = t  # local t and not account for scr refresh
            triangle_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_4, 'tStartRefresh')  # time at next scr refresh
            triangle_4.setAutoDraw(True)
        
        # *star_4* updates
        if star_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_4.frameNStart = frameN  # exact frame index
            star_4.tStart = t  # local t and not account for scr refresh
            star_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_4, 'tStartRefresh')  # time at next scr refresh
            star_4.setAutoDraw(True)
        
        # *cross_4* updates
        if cross_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_4.frameNStart = frameN  # exact frame index
            cross_4.tStart = t  # local t and not account for scr refresh
            cross_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_4, 'tStartRefresh')  # time at next scr refresh
            cross_4.setAutoDraw(True)
        
        # *key_resp_zud4* updates
        waitOnFlip = False
        if key_resp_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud4.frameNStart = frameN  # exact frame index
            key_resp_zud4.tStart = t  # local t and not account for scr refresh
            key_resp_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud4, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud4.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud4.clock.reset)  # t=0 on next screen flip
        if key_resp_zud4.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud4.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud4_allKeys.extend(theseKeys)
            if len(_key_resp_zud4_allKeys):
                key_resp_zud4.keys = _key_resp_zud4_allKeys[-1].name  # just the last key pressed
                key_resp_zud4.rt = _key_resp_zud4_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud4.keys == str('1')) or (key_resp_zud4.keys == '1'):
                    key_resp_zud4.corr = 1
                else:
                    key_resp_zud4.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_04* updates
        if option1_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_04.frameNStart = frameN  # exact frame index
            option1_04.tStart = t  # local t and not account for scr refresh
            option1_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_04, 'tStartRefresh')  # time at next scr refresh
            option1_04.setAutoDraw(True)
        
        # *option2_04* updates
        if option2_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_04.frameNStart = frameN  # exact frame index
            option2_04.tStart = t  # local t and not account for scr refresh
            option2_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_04, 'tStartRefresh')  # time at next scr refresh
            option2_04.setAutoDraw(True)
        
        # *option3_04* updates
        if option3_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_04.frameNStart = frameN  # exact frame index
            option3_04.tStart = t  # local t and not account for scr refresh
            option3_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_04, 'tStartRefresh')  # time at next scr refresh
            option3_04.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud4"-------
    for thisComponent in zud4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('zud4_corr1.started', zud4_corr1.tStartRefresh)
    trials_phase1.addData('zud4_corr1.stopped', zud4_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('triangle_4.started', triangle_4.tStartRefresh)
    trials_phase1.addData('triangle_4.stopped', triangle_4.tStopRefresh)
    trials_phase1.addData('star_4.started', star_4.tStartRefresh)
    trials_phase1.addData('star_4.stopped', star_4.tStopRefresh)
    trials_phase1.addData('cross_4.started', cross_4.tStartRefresh)
    trials_phase1.addData('cross_4.stopped', cross_4.tStopRefresh)
    # check responses
    if key_resp_zud4.keys in ['', [], None]:  # No response was made
        key_resp_zud4.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud4.corr = 1;  # correct non-response
        else:
           key_resp_zud4.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_zud4.keys',key_resp_zud4.keys)
    trials_phase1.addData('key_resp_zud4.corr', key_resp_zud4.corr)
    if key_resp_zud4.keys != None:  # we had a response
        trials_phase1.addData('key_resp_zud4.rt', key_resp_zud4.rt)
    trials_phase1.addData('key_resp_zud4.started', key_resp_zud4.tStartRefresh)
    trials_phase1.addData('key_resp_zud4.stopped', key_resp_zud4.tStopRefresh)
    trials_phase1.addData('option1_04.started', option1_04.tStartRefresh)
    trials_phase1.addData('option1_04.stopped', option1_04.tStopRefresh)
    trials_phase1.addData('option2_04.started', option2_04.tStartRefresh)
    trials_phase1.addData('option2_04.stopped', option2_04.tStopRefresh)
    trials_phase1.addData('option3_04.started', option3_04.tStartRefresh)
    trials_phase1.addData('option3_04.stopped', option3_04.tStopRefresh)
    # the Routine "zud4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud4"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud4.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud4.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud4.setText(msg1)
    feedback0_zud4.setText(msg0)
    feedback_zud04.setText(msg)
    # keep track of which components have finished
    fb_zud4Components = [feedback1_zud4, feedback0_zud4, feedback_zud04]
    for thisComponent in fb_zud4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud4"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud4* updates
        if feedback1_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud4.frameNStart = frameN  # exact frame index
            feedback1_zud4.tStart = t  # local t and not account for scr refresh
            feedback1_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud4, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud4.setAutoDraw(True)
        if feedback1_zud4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud4.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud4.tStop = t  # not accounting for scr refresh
                feedback1_zud4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud4, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud4.setAutoDraw(False)
        
        # *feedback0_zud4* updates
        if feedback0_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud4.frameNStart = frameN  # exact frame index
            feedback0_zud4.tStart = t  # local t and not account for scr refresh
            feedback0_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud4, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud4.setAutoDraw(True)
        if feedback0_zud4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud4.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud4.tStop = t  # not accounting for scr refresh
                feedback0_zud4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud4, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud4.setAutoDraw(False)
        
        # *feedback_zud04* updates
        if feedback_zud04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud04.frameNStart = frameN  # exact frame index
            feedback_zud04.tStart = t  # local t and not account for scr refresh
            feedback_zud04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud04, 'tStartRefresh')  # time at next scr refresh
            feedback_zud04.setAutoDraw(True)
        if feedback_zud04.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud04.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud04.tStop = t  # not accounting for scr refresh
                feedback_zud04.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud04, 'tStopRefresh')  # time at next scr refresh
                feedback_zud04.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud4"-------
    for thisComponent in fb_zud4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud4.started', feedback1_zud4.tStartRefresh)
    trials_phase1.addData('feedback1_zud4.stopped', feedback1_zud4.tStopRefresh)
    trials_phase1.addData('feedback0_zud4.started', feedback0_zud4.tStartRefresh)
    trials_phase1.addData('feedback0_zud4.stopped', feedback0_zud4.tStopRefresh)
    trials_phase1.addData('feedback_zud04.started', feedback_zud04.tStartRefresh)
    trials_phase1.addData('feedback_zud04.stopped', feedback_zud04.tStopRefresh)
    
    # ------Prepare to start Routine "blicket13"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blicket13.keys = []
    key_resp_blicket13.rt = []
    _key_resp_blicket13_allKeys = []
    blicket_st_w.setFillColor('white')
    blicket_st_b.setFillColor('white')
    # keep track of which components have finished
    blicket13Components = [key_resp_blicket13, blicket1, blicket_st_w, blicket_st_b, rec_bl_2, option1_critical_3, option2_critical_3, text3]
    for thisComponent in blicket13Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicket13Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicket13"-------
    while continueRoutine:
        # get current time
        t = blicket13Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicket13Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_blicket13* updates
        waitOnFlip = False
        if key_resp_blicket13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicket13.frameNStart = frameN  # exact frame index
            key_resp_blicket13.tStart = t  # local t and not account for scr refresh
            key_resp_blicket13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicket13, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicket13.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicket13.clock.reset)  # t=0 on next screen flip
        if key_resp_blicket13.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicket13.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicket13_allKeys.extend(theseKeys)
            if len(_key_resp_blicket13_allKeys):
                key_resp_blicket13.keys = _key_resp_blicket13_allKeys[-1].name  # just the last key pressed
                key_resp_blicket13.rt = _key_resp_blicket13_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicket13.keys == str('3')) or (key_resp_blicket13.keys == '3'):
                    key_resp_blicket13.corr = 1
                else:
                    key_resp_blicket13.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1* updates
        if blicket1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1.frameNStart = frameN  # exact frame index
            blicket1.tStart = t  # local t and not account for scr refresh
            blicket1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1, 'tStartRefresh')  # time at next scr refresh
            blicket1.setAutoDraw(True)
        
        # *blicket_st_w* updates
        if blicket_st_w.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w.frameNStart = frameN  # exact frame index
            blicket_st_w.tStart = t  # local t and not account for scr refresh
            blicket_st_w.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w.setAutoDraw(True)
        
        # *blicket_st_b* updates
        if blicket_st_b.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b.frameNStart = frameN  # exact frame index
            blicket_st_b.tStart = t  # local t and not account for scr refresh
            blicket_st_b.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b.setAutoDraw(True)
        
        # *rec_bl_2* updates
        if rec_bl_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rec_bl_2.frameNStart = frameN  # exact frame index
            rec_bl_2.tStart = t  # local t and not account for scr refresh
            rec_bl_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rec_bl_2, 'tStartRefresh')  # time at next scr refresh
            rec_bl_2.setAutoDraw(True)
        
        # *option1_critical_3* updates
        if option1_critical_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_3.frameNStart = frameN  # exact frame index
            option1_critical_3.tStart = t  # local t and not account for scr refresh
            option1_critical_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_3, 'tStartRefresh')  # time at next scr refresh
            option1_critical_3.setAutoDraw(True)
        
        # *option2_critical_3* updates
        if option2_critical_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_3.frameNStart = frameN  # exact frame index
            option2_critical_3.tStart = t  # local t and not account for scr refresh
            option2_critical_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_3, 'tStartRefresh')  # time at next scr refresh
            option2_critical_3.setAutoDraw(True)
        
        # *text3* updates
        if text3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text3.frameNStart = frameN  # exact frame index
            text3.tStart = t  # local t and not account for scr refresh
            text3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text3, 'tStartRefresh')  # time at next scr refresh
            text3.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicket13Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicket13"-------
    for thisComponent in blicket13Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_blicket13.keys in ['', [], None]:  # No response was made
        key_resp_blicket13.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_blicket13.corr = 1;  # correct non-response
        else:
           key_resp_blicket13.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_blicket13.keys',key_resp_blicket13.keys)
    trials_phase1.addData('key_resp_blicket13.corr', key_resp_blicket13.corr)
    if key_resp_blicket13.keys != None:  # we had a response
        trials_phase1.addData('key_resp_blicket13.rt', key_resp_blicket13.rt)
    trials_phase1.addData('key_resp_blicket13.started', key_resp_blicket13.tStartRefresh)
    trials_phase1.addData('key_resp_blicket13.stopped', key_resp_blicket13.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('blicket1.started', blicket1.tStartRefresh)
    trials_phase1.addData('blicket1.stopped', blicket1.tStopRefresh)
    trials_phase1.addData('blicket_st_w.started', blicket_st_w.tStartRefresh)
    trials_phase1.addData('blicket_st_w.stopped', blicket_st_w.tStopRefresh)
    trials_phase1.addData('blicket_st_b.started', blicket_st_b.tStartRefresh)
    trials_phase1.addData('blicket_st_b.stopped', blicket_st_b.tStopRefresh)
    trials_phase1.addData('rec_bl_2.started', rec_bl_2.tStartRefresh)
    trials_phase1.addData('rec_bl_2.stopped', rec_bl_2.tStopRefresh)
    trials_phase1.addData('option1_critical_3.started', option1_critical_3.tStartRefresh)
    trials_phase1.addData('option1_critical_3.stopped', option1_critical_3.tStopRefresh)
    trials_phase1.addData('option2_critical_3.started', option2_critical_3.tStartRefresh)
    trials_phase1.addData('option2_critical_3.stopped', option2_critical_3.tStopRefresh)
    trials_phase1.addData('text3.started', text3.tStartRefresh)
    trials_phase1.addData('text3.stopped', text3.tStopRefresh)
    # the Routine "blicket13" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicket13"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicket13.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicket13.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_5.setText(msg1)
    feedback0_dax9_5.setText(msg0)
    feedback_dax9_5.setText(msg)
    # keep track of which components have finished
    fb_blicket13Components = [feedback1_dax9_5, feedback0_dax9_5, feedback_dax9_5]
    for thisComponent in fb_blicket13Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicket13Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicket13"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicket13Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicket13Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_5* updates
        if feedback1_dax9_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_5.frameNStart = frameN  # exact frame index
            feedback1_dax9_5.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_5, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_5.setAutoDraw(True)
        if feedback1_dax9_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_5.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_5.tStop = t  # not accounting for scr refresh
                feedback1_dax9_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_5, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_5.setAutoDraw(False)
        
        # *feedback0_dax9_5* updates
        if feedback0_dax9_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_5.frameNStart = frameN  # exact frame index
            feedback0_dax9_5.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_5, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_5.setAutoDraw(True)
        if feedback0_dax9_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_5.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_5.tStop = t  # not accounting for scr refresh
                feedback0_dax9_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_5, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_5.setAutoDraw(False)
        
        # *feedback_dax9_5* updates
        if feedback_dax9_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_5.frameNStart = frameN  # exact frame index
            feedback_dax9_5.tStart = t  # local t and not account for scr refresh
            feedback_dax9_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_5, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_5.setAutoDraw(True)
        if feedback_dax9_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_5.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_5.tStop = t  # not accounting for scr refresh
                feedback_dax9_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_5, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_5.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicket13Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicket13"-------
    for thisComponent in fb_blicket13Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_dax9_5.started', feedback1_dax9_5.tStartRefresh)
    trials_phase1.addData('feedback1_dax9_5.stopped', feedback1_dax9_5.tStopRefresh)
    trials_phase1.addData('feedback0_dax9_5.started', feedback0_dax9_5.tStartRefresh)
    trials_phase1.addData('feedback0_dax9_5.stopped', feedback0_dax9_5.tStopRefresh)
    trials_phase1.addData('feedback_dax9_5.started', feedback_dax9_5.tStartRefresh)
    trials_phase1.addData('feedback_dax9_5.stopped', feedback_dax9_5.tStopRefresh)
    
    # ------Prepare to start Routine "blicket14"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blicket14.keys = []
    key_resp_blicket14.rt = []
    _key_resp_blicket14_allKeys = []
    blicket_st_w_2.setFillColor('white')
    blicket_st_b_2.setFillColor('black')
    w_triange.setFillColor('white')
    # keep track of which components have finished
    blicket14Components = [key_resp_blicket14, blicket1_2, blicket_st_w_2, blicket_st_b_2, w_triange, option1_critical_4, option2_critical_4, bltext]
    for thisComponent in blicket14Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicket14Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicket14"-------
    while continueRoutine:
        # get current time
        t = blicket14Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicket14Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_blicket14* updates
        waitOnFlip = False
        if key_resp_blicket14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicket14.frameNStart = frameN  # exact frame index
            key_resp_blicket14.tStart = t  # local t and not account for scr refresh
            key_resp_blicket14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicket14, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicket14.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicket14.clock.reset)  # t=0 on next screen flip
        if key_resp_blicket14.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicket14.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicket14_allKeys.extend(theseKeys)
            if len(_key_resp_blicket14_allKeys):
                key_resp_blicket14.keys = _key_resp_blicket14_allKeys[-1].name  # just the last key pressed
                key_resp_blicket14.rt = _key_resp_blicket14_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicket14.keys == str('2')) or (key_resp_blicket14.keys == '2'):
                    key_resp_blicket14.corr = 1
                else:
                    key_resp_blicket14.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_2* updates
        if blicket1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_2.frameNStart = frameN  # exact frame index
            blicket1_2.tStart = t  # local t and not account for scr refresh
            blicket1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_2, 'tStartRefresh')  # time at next scr refresh
            blicket1_2.setAutoDraw(True)
        
        # *blicket_st_w_2* updates
        if blicket_st_w_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w_2.frameNStart = frameN  # exact frame index
            blicket_st_w_2.tStart = t  # local t and not account for scr refresh
            blicket_st_w_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w_2, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w_2.setAutoDraw(True)
        
        # *blicket_st_b_2* updates
        if blicket_st_b_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b_2.frameNStart = frameN  # exact frame index
            blicket_st_b_2.tStart = t  # local t and not account for scr refresh
            blicket_st_b_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b_2, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b_2.setAutoDraw(True)
        
        # *w_triange* updates
        if w_triange.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            w_triange.frameNStart = frameN  # exact frame index
            w_triange.tStart = t  # local t and not account for scr refresh
            w_triange.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(w_triange, 'tStartRefresh')  # time at next scr refresh
            w_triange.setAutoDraw(True)
        
        # *option1_critical_4* updates
        if option1_critical_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_4.frameNStart = frameN  # exact frame index
            option1_critical_4.tStart = t  # local t and not account for scr refresh
            option1_critical_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_4, 'tStartRefresh')  # time at next scr refresh
            option1_critical_4.setAutoDraw(True)
        
        # *option2_critical_4* updates
        if option2_critical_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_4.frameNStart = frameN  # exact frame index
            option2_critical_4.tStart = t  # local t and not account for scr refresh
            option2_critical_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_4, 'tStartRefresh')  # time at next scr refresh
            option2_critical_4.setAutoDraw(True)
        
        # *bltext* updates
        if bltext.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bltext.frameNStart = frameN  # exact frame index
            bltext.tStart = t  # local t and not account for scr refresh
            bltext.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bltext, 'tStartRefresh')  # time at next scr refresh
            bltext.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicket14Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicket14"-------
    for thisComponent in blicket14Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_blicket14.keys in ['', [], None]:  # No response was made
        key_resp_blicket14.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_blicket14.corr = 1;  # correct non-response
        else:
           key_resp_blicket14.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_blicket14.keys',key_resp_blicket14.keys)
    trials_phase1.addData('key_resp_blicket14.corr', key_resp_blicket14.corr)
    if key_resp_blicket14.keys != None:  # we had a response
        trials_phase1.addData('key_resp_blicket14.rt', key_resp_blicket14.rt)
    trials_phase1.addData('key_resp_blicket14.started', key_resp_blicket14.tStartRefresh)
    trials_phase1.addData('key_resp_blicket14.stopped', key_resp_blicket14.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('blicket1_2.started', blicket1_2.tStartRefresh)
    trials_phase1.addData('blicket1_2.stopped', blicket1_2.tStopRefresh)
    trials_phase1.addData('blicket_st_w_2.started', blicket_st_w_2.tStartRefresh)
    trials_phase1.addData('blicket_st_w_2.stopped', blicket_st_w_2.tStopRefresh)
    trials_phase1.addData('blicket_st_b_2.started', blicket_st_b_2.tStartRefresh)
    trials_phase1.addData('blicket_st_b_2.stopped', blicket_st_b_2.tStopRefresh)
    trials_phase1.addData('w_triange.started', w_triange.tStartRefresh)
    trials_phase1.addData('w_triange.stopped', w_triange.tStopRefresh)
    trials_phase1.addData('option1_critical_4.started', option1_critical_4.tStartRefresh)
    trials_phase1.addData('option1_critical_4.stopped', option1_critical_4.tStopRefresh)
    trials_phase1.addData('option2_critical_4.started', option2_critical_4.tStartRefresh)
    trials_phase1.addData('option2_critical_4.stopped', option2_critical_4.tStopRefresh)
    trials_phase1.addData('bltext.started', bltext.tStartRefresh)
    trials_phase1.addData('bltext.stopped', bltext.tStopRefresh)
    # the Routine "blicket14" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicket14"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicket14.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicket14.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_6.setText(msg1)
    feedback0_dax9_6.setText(msg0)
    feedback_dax9_6.setText(msg)
    # keep track of which components have finished
    fb_blicket14Components = [feedback1_dax9_6, feedback0_dax9_6, feedback_dax9_6]
    for thisComponent in fb_blicket14Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicket14Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicket14"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicket14Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicket14Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_6* updates
        if feedback1_dax9_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_6.frameNStart = frameN  # exact frame index
            feedback1_dax9_6.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_6, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_6.setAutoDraw(True)
        if feedback1_dax9_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_6.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_6.tStop = t  # not accounting for scr refresh
                feedback1_dax9_6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_6, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_6.setAutoDraw(False)
        
        # *feedback0_dax9_6* updates
        if feedback0_dax9_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_6.frameNStart = frameN  # exact frame index
            feedback0_dax9_6.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_6, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_6.setAutoDraw(True)
        if feedback0_dax9_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_6.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_6.tStop = t  # not accounting for scr refresh
                feedback0_dax9_6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_6, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_6.setAutoDraw(False)
        
        # *feedback_dax9_6* updates
        if feedback_dax9_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_6.frameNStart = frameN  # exact frame index
            feedback_dax9_6.tStart = t  # local t and not account for scr refresh
            feedback_dax9_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_6, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_6.setAutoDraw(True)
        if feedback_dax9_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_6.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_6.tStop = t  # not accounting for scr refresh
                feedback_dax9_6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_6, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_6.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicket14Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicket14"-------
    for thisComponent in fb_blicket14Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_dax9_6.started', feedback1_dax9_6.tStartRefresh)
    trials_phase1.addData('feedback1_dax9_6.stopped', feedback1_dax9_6.tStopRefresh)
    trials_phase1.addData('feedback0_dax9_6.started', feedback0_dax9_6.tStartRefresh)
    trials_phase1.addData('feedback0_dax9_6.stopped', feedback0_dax9_6.tStopRefresh)
    trials_phase1.addData('feedback_dax9_6.started', feedback_dax9_6.tStartRefresh)
    trials_phase1.addData('feedback_dax9_6.stopped', feedback_dax9_6.tStopRefresh)
    
    # ------Prepare to start Routine "smicket17"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_smicket17.keys = []
    key_resp_smicket17.rt = []
    _key_resp_smicket17_allKeys = []
    blicket_st_w_3.setFillColor('white')
    blicket_st_b_3.setFillColor('black')
    sm.setFillColor('black')
    # keep track of which components have finished
    smicket17Components = [key_resp_smicket17, blicket1_5, blicket_st_w_3, blicket_st_b_3, sm, option1_critical_7, option2_critical_7, smtext]
    for thisComponent in smicket17Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicket17Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicket17"-------
    while continueRoutine:
        # get current time
        t = smicket17Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicket17Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_smicket17* updates
        waitOnFlip = False
        if key_resp_smicket17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicket17.frameNStart = frameN  # exact frame index
            key_resp_smicket17.tStart = t  # local t and not account for scr refresh
            key_resp_smicket17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicket17, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicket17.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicket17.clock.reset)  # t=0 on next screen flip
        if key_resp_smicket17.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicket17.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_smicket17_allKeys.extend(theseKeys)
            if len(_key_resp_smicket17_allKeys):
                key_resp_smicket17.keys = _key_resp_smicket17_allKeys[-1].name  # just the last key pressed
                key_resp_smicket17.rt = _key_resp_smicket17_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicket17.keys == str('1')) or (key_resp_smicket17.keys == '1'):
                    key_resp_smicket17.corr = 1
                else:
                    key_resp_smicket17.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_5* updates
        if blicket1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_5.frameNStart = frameN  # exact frame index
            blicket1_5.tStart = t  # local t and not account for scr refresh
            blicket1_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_5, 'tStartRefresh')  # time at next scr refresh
            blicket1_5.setAutoDraw(True)
        
        # *blicket_st_w_3* updates
        if blicket_st_w_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w_3.frameNStart = frameN  # exact frame index
            blicket_st_w_3.tStart = t  # local t and not account for scr refresh
            blicket_st_w_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w_3, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w_3.setAutoDraw(True)
        
        # *blicket_st_b_3* updates
        if blicket_st_b_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b_3.frameNStart = frameN  # exact frame index
            blicket_st_b_3.tStart = t  # local t and not account for scr refresh
            blicket_st_b_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b_3, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b_3.setAutoDraw(True)
        
        # *sm* updates
        if sm.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            sm.frameNStart = frameN  # exact frame index
            sm.tStart = t  # local t and not account for scr refresh
            sm.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(sm, 'tStartRefresh')  # time at next scr refresh
            sm.setAutoDraw(True)
        
        # *option1_critical_7* updates
        if option1_critical_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_7.frameNStart = frameN  # exact frame index
            option1_critical_7.tStart = t  # local t and not account for scr refresh
            option1_critical_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_7, 'tStartRefresh')  # time at next scr refresh
            option1_critical_7.setAutoDraw(True)
        
        # *option2_critical_7* updates
        if option2_critical_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_7.frameNStart = frameN  # exact frame index
            option2_critical_7.tStart = t  # local t and not account for scr refresh
            option2_critical_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_7, 'tStartRefresh')  # time at next scr refresh
            option2_critical_7.setAutoDraw(True)
        
        # *smtext* updates
        if smtext.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            smtext.frameNStart = frameN  # exact frame index
            smtext.tStart = t  # local t and not account for scr refresh
            smtext.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(smtext, 'tStartRefresh')  # time at next scr refresh
            smtext.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicket17Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicket17"-------
    for thisComponent in smicket17Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_smicket17.keys in ['', [], None]:  # No response was made
        key_resp_smicket17.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_smicket17.corr = 1;  # correct non-response
        else:
           key_resp_smicket17.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_smicket17.keys',key_resp_smicket17.keys)
    trials_phase1.addData('key_resp_smicket17.corr', key_resp_smicket17.corr)
    if key_resp_smicket17.keys != None:  # we had a response
        trials_phase1.addData('key_resp_smicket17.rt', key_resp_smicket17.rt)
    trials_phase1.addData('key_resp_smicket17.started', key_resp_smicket17.tStartRefresh)
    trials_phase1.addData('key_resp_smicket17.stopped', key_resp_smicket17.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('blicket1_5.started', blicket1_5.tStartRefresh)
    trials_phase1.addData('blicket1_5.stopped', blicket1_5.tStopRefresh)
    trials_phase1.addData('blicket_st_w_3.started', blicket_st_w_3.tStartRefresh)
    trials_phase1.addData('blicket_st_w_3.stopped', blicket_st_w_3.tStopRefresh)
    trials_phase1.addData('blicket_st_b_3.started', blicket_st_b_3.tStartRefresh)
    trials_phase1.addData('blicket_st_b_3.stopped', blicket_st_b_3.tStopRefresh)
    trials_phase1.addData('sm.started', sm.tStartRefresh)
    trials_phase1.addData('sm.stopped', sm.tStopRefresh)
    trials_phase1.addData('option1_critical_7.started', option1_critical_7.tStartRefresh)
    trials_phase1.addData('option1_critical_7.stopped', option1_critical_7.tStopRefresh)
    trials_phase1.addData('option2_critical_7.started', option2_critical_7.tStartRefresh)
    trials_phase1.addData('option2_critical_7.stopped', option2_critical_7.tStopRefresh)
    trials_phase1.addData('smtext.started', smtext.tStartRefresh)
    trials_phase1.addData('smtext.stopped', smtext.tStopRefresh)
    # the Routine "smicket17" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicket17"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicket17.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicket17.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_9.setText(msg1)
    feedback0_dax9_9.setText(msg0)
    feedback_dax9_9.setText(msg)
    # keep track of which components have finished
    fb_smicket17Components = [feedback1_dax9_9, feedback0_dax9_9, feedback_dax9_9]
    for thisComponent in fb_smicket17Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicket17Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicket17"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicket17Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicket17Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_9* updates
        if feedback1_dax9_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_9.frameNStart = frameN  # exact frame index
            feedback1_dax9_9.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_9, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_9.setAutoDraw(True)
        if feedback1_dax9_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_9.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_9.tStop = t  # not accounting for scr refresh
                feedback1_dax9_9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_9, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_9.setAutoDraw(False)
        
        # *feedback0_dax9_9* updates
        if feedback0_dax9_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_9.frameNStart = frameN  # exact frame index
            feedback0_dax9_9.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_9, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_9.setAutoDraw(True)
        if feedback0_dax9_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_9.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_9.tStop = t  # not accounting for scr refresh
                feedback0_dax9_9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_9, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_9.setAutoDraw(False)
        
        # *feedback_dax9_9* updates
        if feedback_dax9_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_9.frameNStart = frameN  # exact frame index
            feedback_dax9_9.tStart = t  # local t and not account for scr refresh
            feedback_dax9_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_9, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_9.setAutoDraw(True)
        if feedback_dax9_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_9.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_9.tStop = t  # not accounting for scr refresh
                feedback_dax9_9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_9, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_9.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicket17Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicket17"-------
    for thisComponent in fb_smicket17Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_dax9_9.started', feedback1_dax9_9.tStartRefresh)
    trials_phase1.addData('feedback1_dax9_9.stopped', feedback1_dax9_9.tStopRefresh)
    trials_phase1.addData('feedback0_dax9_9.started', feedback0_dax9_9.tStartRefresh)
    trials_phase1.addData('feedback0_dax9_9.stopped', feedback0_dax9_9.tStopRefresh)
    trials_phase1.addData('feedback_dax9_9.started', feedback_dax9_9.tStartRefresh)
    trials_phase1.addData('feedback_dax9_9.stopped', feedback_dax9_9.tStopRefresh)
    
    # ------Prepare to start Routine "smicket18"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_smicket18.keys = []
    key_resp_smicket18.rt = []
    _key_resp_smicket18_allKeys = []
    blicket_st_w_4.setFillColor('black')
    blicket_st_b_4.setFillColor('white')
    sm2.setFillColor('black')
    # keep track of which components have finished
    smicket18Components = [key_resp_smicket18, blicket1_6, blicket_st_w_4, blicket_st_b_4, sm2, option1_critical_8, option2_critical_8, smtext2]
    for thisComponent in smicket18Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicket18Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicket18"-------
    while continueRoutine:
        # get current time
        t = smicket18Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicket18Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_smicket18* updates
        waitOnFlip = False
        if key_resp_smicket18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicket18.frameNStart = frameN  # exact frame index
            key_resp_smicket18.tStart = t  # local t and not account for scr refresh
            key_resp_smicket18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicket18, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicket18.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicket18.clock.reset)  # t=0 on next screen flip
        if key_resp_smicket18.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicket18.getKeys(keyList=['1', '2'], waitRelease=False)
            _key_resp_smicket18_allKeys.extend(theseKeys)
            if len(_key_resp_smicket18_allKeys):
                key_resp_smicket18.keys = _key_resp_smicket18_allKeys[-1].name  # just the last key pressed
                key_resp_smicket18.rt = _key_resp_smicket18_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicket18.keys == str('2')) or (key_resp_smicket18.keys == '2'):
                    key_resp_smicket18.corr = 1
                else:
                    key_resp_smicket18.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_6* updates
        if blicket1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_6.frameNStart = frameN  # exact frame index
            blicket1_6.tStart = t  # local t and not account for scr refresh
            blicket1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_6, 'tStartRefresh')  # time at next scr refresh
            blicket1_6.setAutoDraw(True)
        
        # *blicket_st_w_4* updates
        if blicket_st_w_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w_4.frameNStart = frameN  # exact frame index
            blicket_st_w_4.tStart = t  # local t and not account for scr refresh
            blicket_st_w_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w_4, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w_4.setAutoDraw(True)
        
        # *blicket_st_b_4* updates
        if blicket_st_b_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b_4.frameNStart = frameN  # exact frame index
            blicket_st_b_4.tStart = t  # local t and not account for scr refresh
            blicket_st_b_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b_4, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b_4.setAutoDraw(True)
        
        # *sm2* updates
        if sm2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            sm2.frameNStart = frameN  # exact frame index
            sm2.tStart = t  # local t and not account for scr refresh
            sm2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(sm2, 'tStartRefresh')  # time at next scr refresh
            sm2.setAutoDraw(True)
        
        # *option1_critical_8* updates
        if option1_critical_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_8.frameNStart = frameN  # exact frame index
            option1_critical_8.tStart = t  # local t and not account for scr refresh
            option1_critical_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_8, 'tStartRefresh')  # time at next scr refresh
            option1_critical_8.setAutoDraw(True)
        
        # *option2_critical_8* updates
        if option2_critical_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_8.frameNStart = frameN  # exact frame index
            option2_critical_8.tStart = t  # local t and not account for scr refresh
            option2_critical_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_8, 'tStartRefresh')  # time at next scr refresh
            option2_critical_8.setAutoDraw(True)
        
        # *smtext2* updates
        if smtext2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            smtext2.frameNStart = frameN  # exact frame index
            smtext2.tStart = t  # local t and not account for scr refresh
            smtext2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(smtext2, 'tStartRefresh')  # time at next scr refresh
            smtext2.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicket18Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicket18"-------
    for thisComponent in smicket18Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_smicket18.keys in ['', [], None]:  # No response was made
        key_resp_smicket18.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_smicket18.corr = 1;  # correct non-response
        else:
           key_resp_smicket18.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_smicket18.keys',key_resp_smicket18.keys)
    trials_phase1.addData('key_resp_smicket18.corr', key_resp_smicket18.corr)
    if key_resp_smicket18.keys != None:  # we had a response
        trials_phase1.addData('key_resp_smicket18.rt', key_resp_smicket18.rt)
    trials_phase1.addData('key_resp_smicket18.started', key_resp_smicket18.tStartRefresh)
    trials_phase1.addData('key_resp_smicket18.stopped', key_resp_smicket18.tStopRefresh)
    
    number_correct = number_correct + 1
    print('number_Correct: ' + str(number_correct))
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('blicket1_6.started', blicket1_6.tStartRefresh)
    trials_phase1.addData('blicket1_6.stopped', blicket1_6.tStopRefresh)
    trials_phase1.addData('blicket_st_w_4.started', blicket_st_w_4.tStartRefresh)
    trials_phase1.addData('blicket_st_w_4.stopped', blicket_st_w_4.tStopRefresh)
    trials_phase1.addData('blicket_st_b_4.started', blicket_st_b_4.tStartRefresh)
    trials_phase1.addData('blicket_st_b_4.stopped', blicket_st_b_4.tStopRefresh)
    trials_phase1.addData('sm2.started', sm2.tStartRefresh)
    trials_phase1.addData('sm2.stopped', sm2.tStopRefresh)
    trials_phase1.addData('option1_critical_8.started', option1_critical_8.tStartRefresh)
    trials_phase1.addData('option1_critical_8.stopped', option1_critical_8.tStopRefresh)
    trials_phase1.addData('option2_critical_8.started', option2_critical_8.tStartRefresh)
    trials_phase1.addData('option2_critical_8.stopped', option2_critical_8.tStopRefresh)
    trials_phase1.addData('smtext2.started', smtext2.tStartRefresh)
    trials_phase1.addData('smtext2.stopped', smtext2.tStopRefresh)
    # the Routine "smicket18" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicket18"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicket18.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicket18.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_10.setText(msg1)
    feedback0_dax9_10.setText(msg0)
    feedback_dax9_10.setText(msg)
    # keep track of which components have finished
    fb_smicket18Components = [feedback1_dax9_10, feedback0_dax9_10, feedback_dax9_10]
    for thisComponent in fb_smicket18Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicket18Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicket18"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicket18Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicket18Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_10* updates
        if feedback1_dax9_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_10.frameNStart = frameN  # exact frame index
            feedback1_dax9_10.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_10, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_10.setAutoDraw(True)
        if feedback1_dax9_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_10.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_10.tStop = t  # not accounting for scr refresh
                feedback1_dax9_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_10, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_10.setAutoDraw(False)
        
        # *feedback0_dax9_10* updates
        if feedback0_dax9_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_10.frameNStart = frameN  # exact frame index
            feedback0_dax9_10.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_10, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_10.setAutoDraw(True)
        if feedback0_dax9_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_10.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_10.tStop = t  # not accounting for scr refresh
                feedback0_dax9_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_10, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_10.setAutoDraw(False)
        
        # *feedback_dax9_10* updates
        if feedback_dax9_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_10.frameNStart = frameN  # exact frame index
            feedback_dax9_10.tStart = t  # local t and not account for scr refresh
            feedback_dax9_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_10, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_10.setAutoDraw(True)
        if feedback_dax9_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_10.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_10.tStop = t  # not accounting for scr refresh
                feedback_dax9_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_10, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_10.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicket18Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicket18"-------
    for thisComponent in fb_smicket18Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_dax9_10.started', feedback1_dax9_10.tStartRefresh)
    trials_phase1.addData('feedback1_dax9_10.stopped', feedback1_dax9_10.tStopRefresh)
    trials_phase1.addData('feedback0_dax9_10.started', feedback0_dax9_10.tStartRefresh)
    trials_phase1.addData('feedback0_dax9_10.stopped', feedback0_dax9_10.tStopRefresh)
    trials_phase1.addData('feedback_dax9_10.started', feedback_dax9_10.tStartRefresh)
    trials_phase1.addData('feedback_dax9_10.stopped', feedback_dax9_10.tStopRefresh)
    
    # ------Prepare to start Routine "bosa1"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_bosa.keys = []
    key_resp_bosa.rt = []
    _key_resp_bosa_allKeys = []
    # keep track of which components have finished
    bosa1Components = [key_resp_bosa, blicket1_11, option1_critical_14, option2_critical_14, bosa3, polygon_5, polygon_6, polygon_7]
    for thisComponent in bosa1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    bosa1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "bosa1"-------
    while continueRoutine:
        # get current time
        t = bosa1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=bosa1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_bosa* updates
        waitOnFlip = False
        if key_resp_bosa.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_bosa.frameNStart = frameN  # exact frame index
            key_resp_bosa.tStart = t  # local t and not account for scr refresh
            key_resp_bosa.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_bosa, 'tStartRefresh')  # time at next scr refresh
            key_resp_bosa.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_bosa.clock.reset)  # t=0 on next screen flip
        if key_resp_bosa.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_bosa.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_bosa_allKeys.extend(theseKeys)
            if len(_key_resp_bosa_allKeys):
                key_resp_bosa.keys = _key_resp_bosa_allKeys[-1].name  # just the last key pressed
                key_resp_bosa.rt = _key_resp_bosa_allKeys[-1].rt
                # was this correct?
                if (key_resp_bosa.keys == str('3')) or (key_resp_bosa.keys == '3'):
                    key_resp_bosa.corr = 1
                else:
                    key_resp_bosa.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_11* updates
        if blicket1_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_11.frameNStart = frameN  # exact frame index
            blicket1_11.tStart = t  # local t and not account for scr refresh
            blicket1_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_11, 'tStartRefresh')  # time at next scr refresh
            blicket1_11.setAutoDraw(True)
        
        # *option1_critical_14* updates
        if option1_critical_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_14.frameNStart = frameN  # exact frame index
            option1_critical_14.tStart = t  # local t and not account for scr refresh
            option1_critical_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_14, 'tStartRefresh')  # time at next scr refresh
            option1_critical_14.setAutoDraw(True)
        
        # *option2_critical_14* updates
        if option2_critical_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_14.frameNStart = frameN  # exact frame index
            option2_critical_14.tStart = t  # local t and not account for scr refresh
            option2_critical_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_14, 'tStartRefresh')  # time at next scr refresh
            option2_critical_14.setAutoDraw(True)
        
        # *bosa3* updates
        if bosa3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bosa3.frameNStart = frameN  # exact frame index
            bosa3.tStart = t  # local t and not account for scr refresh
            bosa3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bosa3, 'tStartRefresh')  # time at next scr refresh
            bosa3.setAutoDraw(True)
        
        # *polygon_5* updates
        if polygon_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_5.frameNStart = frameN  # exact frame index
            polygon_5.tStart = t  # local t and not account for scr refresh
            polygon_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_5, 'tStartRefresh')  # time at next scr refresh
            polygon_5.setAutoDraw(True)
        
        # *polygon_6* updates
        if polygon_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_6.frameNStart = frameN  # exact frame index
            polygon_6.tStart = t  # local t and not account for scr refresh
            polygon_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_6, 'tStartRefresh')  # time at next scr refresh
            polygon_6.setAutoDraw(True)
        
        # *polygon_7* updates
        if polygon_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_7.frameNStart = frameN  # exact frame index
            polygon_7.tStart = t  # local t and not account for scr refresh
            polygon_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_7, 'tStartRefresh')  # time at next scr refresh
            polygon_7.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in bosa1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "bosa1"-------
    for thisComponent in bosa1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_bosa.keys in ['', [], None]:  # No response was made
        key_resp_bosa.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_bosa.corr = 1;  # correct non-response
        else:
           key_resp_bosa.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_bosa.keys',key_resp_bosa.keys)
    trials_phase1.addData('key_resp_bosa.corr', key_resp_bosa.corr)
    if key_resp_bosa.keys != None:  # we had a response
        trials_phase1.addData('key_resp_bosa.rt', key_resp_bosa.rt)
    trials_phase1.addData('key_resp_bosa.started', key_resp_bosa.tStartRefresh)
    trials_phase1.addData('key_resp_bosa.stopped', key_resp_bosa.tStopRefresh)
    number_correct = number_correct + 1
    print('number_Correct: ' + str(number_correct))
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('blicket1_11.started', blicket1_11.tStartRefresh)
    trials_phase1.addData('blicket1_11.stopped', blicket1_11.tStopRefresh)
    trials_phase1.addData('option1_critical_14.started', option1_critical_14.tStartRefresh)
    trials_phase1.addData('option1_critical_14.stopped', option1_critical_14.tStopRefresh)
    trials_phase1.addData('option2_critical_14.started', option2_critical_14.tStartRefresh)
    trials_phase1.addData('option2_critical_14.stopped', option2_critical_14.tStopRefresh)
    trials_phase1.addData('bosa3.started', bosa3.tStartRefresh)
    trials_phase1.addData('bosa3.stopped', bosa3.tStopRefresh)
    trials_phase1.addData('polygon_5.started', polygon_5.tStartRefresh)
    trials_phase1.addData('polygon_5.stopped', polygon_5.tStopRefresh)
    trials_phase1.addData('polygon_6.started', polygon_6.tStartRefresh)
    trials_phase1.addData('polygon_6.stopped', polygon_6.tStopRefresh)
    trials_phase1.addData('polygon_7.started', polygon_7.tStartRefresh)
    trials_phase1.addData('polygon_7.stopped', polygon_7.tStopRefresh)
    # the Routine "bosa1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_bosa1"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_bosa.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_bosa.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1_2.setText(msg1)
    feedback0_zud1_2.setText(msg0)
    feedback_zud01_2.setText(msg)
    # keep track of which components have finished
    fb_bosa1Components = [feedback1_zud1_2, feedback0_zud1_2, feedback_zud01_2]
    for thisComponent in fb_bosa1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_bosa1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_bosa1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_bosa1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_bosa1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1_2* updates
        if feedback1_zud1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1_2.frameNStart = frameN  # exact frame index
            feedback1_zud1_2.tStart = t  # local t and not account for scr refresh
            feedback1_zud1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1_2, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1_2.setAutoDraw(True)
        if feedback1_zud1_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1_2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1_2.tStop = t  # not accounting for scr refresh
                feedback1_zud1_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1_2, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1_2.setAutoDraw(False)
        
        # *feedback0_zud1_2* updates
        if feedback0_zud1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1_2.frameNStart = frameN  # exact frame index
            feedback0_zud1_2.tStart = t  # local t and not account for scr refresh
            feedback0_zud1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1_2, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1_2.setAutoDraw(True)
        if feedback0_zud1_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1_2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1_2.tStop = t  # not accounting for scr refresh
                feedback0_zud1_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1_2, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1_2.setAutoDraw(False)
        
        # *feedback_zud01_2* updates
        if feedback_zud01_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01_2.frameNStart = frameN  # exact frame index
            feedback_zud01_2.tStart = t  # local t and not account for scr refresh
            feedback_zud01_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01_2, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01_2.setAutoDraw(True)
        if feedback_zud01_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01_2.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01_2.tStop = t  # not accounting for scr refresh
                feedback_zud01_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01_2, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01_2.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_bosa1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_bosa1"-------
    for thisComponent in fb_bosa1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud1_2.started', feedback1_zud1_2.tStartRefresh)
    trials_phase1.addData('feedback1_zud1_2.stopped', feedback1_zud1_2.tStopRefresh)
    trials_phase1.addData('feedback0_zud1_2.started', feedback0_zud1_2.tStartRefresh)
    trials_phase1.addData('feedback0_zud1_2.stopped', feedback0_zud1_2.tStopRefresh)
    trials_phase1.addData('feedback_zud01_2.started', feedback_zud01_2.tStartRefresh)
    trials_phase1.addData('feedback_zud01_2.stopped', feedback_zud01_2.tStopRefresh)
    
    # ------Prepare to start Routine "bosa2"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_bosa2.keys = []
    key_resp_bosa2.rt = []
    _key_resp_bosa2_allKeys = []
    number_correct = number_correct + 1
    print('number_Correct: ' + str(number_correct))
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    # keep track of which components have finished
    bosa2Components = [key_resp_bosa2, blicket1_13, option1_critical_16, option2_critical_16, bosa2text2, polygon_2, polygon_3, polygon_4]
    for thisComponent in bosa2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    bosa2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "bosa2"-------
    while continueRoutine:
        # get current time
        t = bosa2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=bosa2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_bosa2* updates
        waitOnFlip = False
        if key_resp_bosa2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_bosa2.frameNStart = frameN  # exact frame index
            key_resp_bosa2.tStart = t  # local t and not account for scr refresh
            key_resp_bosa2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_bosa2, 'tStartRefresh')  # time at next scr refresh
            key_resp_bosa2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_bosa2.clock.reset)  # t=0 on next screen flip
        if key_resp_bosa2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_bosa2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_bosa2_allKeys.extend(theseKeys)
            if len(_key_resp_bosa2_allKeys):
                key_resp_bosa2.keys = _key_resp_bosa2_allKeys[-1].name  # just the last key pressed
                key_resp_bosa2.rt = _key_resp_bosa2_allKeys[-1].rt
                # was this correct?
                if (key_resp_bosa2.keys == str('2')) or (key_resp_bosa2.keys == '2'):
                    key_resp_bosa2.corr = 1
                else:
                    key_resp_bosa2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_13* updates
        if blicket1_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_13.frameNStart = frameN  # exact frame index
            blicket1_13.tStart = t  # local t and not account for scr refresh
            blicket1_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_13, 'tStartRefresh')  # time at next scr refresh
            blicket1_13.setAutoDraw(True)
        
        # *option1_critical_16* updates
        if option1_critical_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_16.frameNStart = frameN  # exact frame index
            option1_critical_16.tStart = t  # local t and not account for scr refresh
            option1_critical_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_16, 'tStartRefresh')  # time at next scr refresh
            option1_critical_16.setAutoDraw(True)
        
        # *option2_critical_16* updates
        if option2_critical_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_16.frameNStart = frameN  # exact frame index
            option2_critical_16.tStart = t  # local t and not account for scr refresh
            option2_critical_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_16, 'tStartRefresh')  # time at next scr refresh
            option2_critical_16.setAutoDraw(True)
        
        # *bosa2text2* updates
        if bosa2text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bosa2text2.frameNStart = frameN  # exact frame index
            bosa2text2.tStart = t  # local t and not account for scr refresh
            bosa2text2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bosa2text2, 'tStartRefresh')  # time at next scr refresh
            bosa2text2.setAutoDraw(True)
        
        # *polygon_2* updates
        if polygon_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_2.frameNStart = frameN  # exact frame index
            polygon_2.tStart = t  # local t and not account for scr refresh
            polygon_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_2, 'tStartRefresh')  # time at next scr refresh
            polygon_2.setAutoDraw(True)
        
        # *polygon_3* updates
        if polygon_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_3.frameNStart = frameN  # exact frame index
            polygon_3.tStart = t  # local t and not account for scr refresh
            polygon_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_3, 'tStartRefresh')  # time at next scr refresh
            polygon_3.setAutoDraw(True)
        
        # *polygon_4* updates
        if polygon_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_4.frameNStart = frameN  # exact frame index
            polygon_4.tStart = t  # local t and not account for scr refresh
            polygon_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_4, 'tStartRefresh')  # time at next scr refresh
            polygon_4.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in bosa2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "bosa2"-------
    for thisComponent in bosa2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_bosa2.keys in ['', [], None]:  # No response was made
        key_resp_bosa2.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_bosa2.corr = 1;  # correct non-response
        else:
           key_resp_bosa2.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_bosa2.keys',key_resp_bosa2.keys)
    trials_phase1.addData('key_resp_bosa2.corr', key_resp_bosa2.corr)
    if key_resp_bosa2.keys != None:  # we had a response
        trials_phase1.addData('key_resp_bosa2.rt', key_resp_bosa2.rt)
    trials_phase1.addData('key_resp_bosa2.started', key_resp_bosa2.tStartRefresh)
    trials_phase1.addData('key_resp_bosa2.stopped', key_resp_bosa2.tStopRefresh)
    trials_phase1.addData('blicket1_13.started', blicket1_13.tStartRefresh)
    trials_phase1.addData('blicket1_13.stopped', blicket1_13.tStopRefresh)
    trials_phase1.addData('option1_critical_16.started', option1_critical_16.tStartRefresh)
    trials_phase1.addData('option1_critical_16.stopped', option1_critical_16.tStopRefresh)
    trials_phase1.addData('option2_critical_16.started', option2_critical_16.tStartRefresh)
    trials_phase1.addData('option2_critical_16.stopped', option2_critical_16.tStopRefresh)
    trials_phase1.addData('bosa2text2.started', bosa2text2.tStartRefresh)
    trials_phase1.addData('bosa2text2.stopped', bosa2text2.tStopRefresh)
    trials_phase1.addData('polygon_2.started', polygon_2.tStartRefresh)
    trials_phase1.addData('polygon_2.stopped', polygon_2.tStopRefresh)
    trials_phase1.addData('polygon_3.started', polygon_3.tStartRefresh)
    trials_phase1.addData('polygon_3.stopped', polygon_3.tStopRefresh)
    trials_phase1.addData('polygon_4.started', polygon_4.tStartRefresh)
    trials_phase1.addData('polygon_4.stopped', polygon_4.tStopRefresh)
    # the Routine "bosa2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_bosa2"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_bosa2.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_bosa2.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1_3.setText(msg1)
    feedback0_zud1_3.setText(msg0)
    feedback_zud01_3.setText(msg)
    # keep track of which components have finished
    fb_bosa2Components = [feedback1_zud1_3, feedback0_zud1_3, feedback_zud01_3]
    for thisComponent in fb_bosa2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_bosa2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_bosa2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_bosa2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_bosa2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1_3* updates
        if feedback1_zud1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1_3.frameNStart = frameN  # exact frame index
            feedback1_zud1_3.tStart = t  # local t and not account for scr refresh
            feedback1_zud1_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1_3, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1_3.setAutoDraw(True)
        if feedback1_zud1_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1_3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1_3.tStop = t  # not accounting for scr refresh
                feedback1_zud1_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1_3, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1_3.setAutoDraw(False)
        
        # *feedback0_zud1_3* updates
        if feedback0_zud1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1_3.frameNStart = frameN  # exact frame index
            feedback0_zud1_3.tStart = t  # local t and not account for scr refresh
            feedback0_zud1_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1_3, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1_3.setAutoDraw(True)
        if feedback0_zud1_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1_3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1_3.tStop = t  # not accounting for scr refresh
                feedback0_zud1_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1_3, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1_3.setAutoDraw(False)
        
        # *feedback_zud01_3* updates
        if feedback_zud01_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01_3.frameNStart = frameN  # exact frame index
            feedback_zud01_3.tStart = t  # local t and not account for scr refresh
            feedback_zud01_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01_3, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01_3.setAutoDraw(True)
        if feedback_zud01_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01_3.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01_3.tStop = t  # not accounting for scr refresh
                feedback_zud01_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01_3, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_bosa2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_bosa2"-------
    for thisComponent in fb_bosa2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud1_3.started', feedback1_zud1_3.tStartRefresh)
    trials_phase1.addData('feedback1_zud1_3.stopped', feedback1_zud1_3.tStopRefresh)
    trials_phase1.addData('feedback0_zud1_3.started', feedback0_zud1_3.tStartRefresh)
    trials_phase1.addData('feedback0_zud1_3.stopped', feedback0_zud1_3.tStopRefresh)
    trials_phase1.addData('feedback_zud01_3.started', feedback_zud01_3.tStartRefresh)
    trials_phase1.addData('feedback_zud01_3.stopped', feedback_zud01_3.tStopRefresh)
    
    # ------Prepare to start Routine "bosa1"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_bosa.keys = []
    key_resp_bosa.rt = []
    _key_resp_bosa_allKeys = []
    # keep track of which components have finished
    bosa1Components = [key_resp_bosa, blicket1_11, option1_critical_14, option2_critical_14, bosa3, polygon_5, polygon_6, polygon_7]
    for thisComponent in bosa1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    bosa1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "bosa1"-------
    while continueRoutine:
        # get current time
        t = bosa1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=bosa1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_bosa* updates
        waitOnFlip = False
        if key_resp_bosa.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_bosa.frameNStart = frameN  # exact frame index
            key_resp_bosa.tStart = t  # local t and not account for scr refresh
            key_resp_bosa.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_bosa, 'tStartRefresh')  # time at next scr refresh
            key_resp_bosa.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_bosa.clock.reset)  # t=0 on next screen flip
        if key_resp_bosa.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_bosa.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_bosa_allKeys.extend(theseKeys)
            if len(_key_resp_bosa_allKeys):
                key_resp_bosa.keys = _key_resp_bosa_allKeys[-1].name  # just the last key pressed
                key_resp_bosa.rt = _key_resp_bosa_allKeys[-1].rt
                # was this correct?
                if (key_resp_bosa.keys == str('3')) or (key_resp_bosa.keys == '3'):
                    key_resp_bosa.corr = 1
                else:
                    key_resp_bosa.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_11* updates
        if blicket1_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_11.frameNStart = frameN  # exact frame index
            blicket1_11.tStart = t  # local t and not account for scr refresh
            blicket1_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_11, 'tStartRefresh')  # time at next scr refresh
            blicket1_11.setAutoDraw(True)
        
        # *option1_critical_14* updates
        if option1_critical_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_14.frameNStart = frameN  # exact frame index
            option1_critical_14.tStart = t  # local t and not account for scr refresh
            option1_critical_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_14, 'tStartRefresh')  # time at next scr refresh
            option1_critical_14.setAutoDraw(True)
        
        # *option2_critical_14* updates
        if option2_critical_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_14.frameNStart = frameN  # exact frame index
            option2_critical_14.tStart = t  # local t and not account for scr refresh
            option2_critical_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_14, 'tStartRefresh')  # time at next scr refresh
            option2_critical_14.setAutoDraw(True)
        
        # *bosa3* updates
        if bosa3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bosa3.frameNStart = frameN  # exact frame index
            bosa3.tStart = t  # local t and not account for scr refresh
            bosa3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bosa3, 'tStartRefresh')  # time at next scr refresh
            bosa3.setAutoDraw(True)
        
        # *polygon_5* updates
        if polygon_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_5.frameNStart = frameN  # exact frame index
            polygon_5.tStart = t  # local t and not account for scr refresh
            polygon_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_5, 'tStartRefresh')  # time at next scr refresh
            polygon_5.setAutoDraw(True)
        
        # *polygon_6* updates
        if polygon_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_6.frameNStart = frameN  # exact frame index
            polygon_6.tStart = t  # local t and not account for scr refresh
            polygon_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_6, 'tStartRefresh')  # time at next scr refresh
            polygon_6.setAutoDraw(True)
        
        # *polygon_7* updates
        if polygon_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_7.frameNStart = frameN  # exact frame index
            polygon_7.tStart = t  # local t and not account for scr refresh
            polygon_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_7, 'tStartRefresh')  # time at next scr refresh
            polygon_7.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in bosa1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "bosa1"-------
    for thisComponent in bosa1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_bosa.keys in ['', [], None]:  # No response was made
        key_resp_bosa.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_bosa.corr = 1;  # correct non-response
        else:
           key_resp_bosa.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_bosa.keys',key_resp_bosa.keys)
    trials_phase1.addData('key_resp_bosa.corr', key_resp_bosa.corr)
    if key_resp_bosa.keys != None:  # we had a response
        trials_phase1.addData('key_resp_bosa.rt', key_resp_bosa.rt)
    trials_phase1.addData('key_resp_bosa.started', key_resp_bosa.tStartRefresh)
    trials_phase1.addData('key_resp_bosa.stopped', key_resp_bosa.tStopRefresh)
    number_correct = number_correct + 1
    print('number_Correct: ' + str(number_correct))
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase1.addData('blicket1_11.started', blicket1_11.tStartRefresh)
    trials_phase1.addData('blicket1_11.stopped', blicket1_11.tStopRefresh)
    trials_phase1.addData('option1_critical_14.started', option1_critical_14.tStartRefresh)
    trials_phase1.addData('option1_critical_14.stopped', option1_critical_14.tStopRefresh)
    trials_phase1.addData('option2_critical_14.started', option2_critical_14.tStartRefresh)
    trials_phase1.addData('option2_critical_14.stopped', option2_critical_14.tStopRefresh)
    trials_phase1.addData('bosa3.started', bosa3.tStartRefresh)
    trials_phase1.addData('bosa3.stopped', bosa3.tStopRefresh)
    trials_phase1.addData('polygon_5.started', polygon_5.tStartRefresh)
    trials_phase1.addData('polygon_5.stopped', polygon_5.tStopRefresh)
    trials_phase1.addData('polygon_6.started', polygon_6.tStartRefresh)
    trials_phase1.addData('polygon_6.stopped', polygon_6.tStopRefresh)
    trials_phase1.addData('polygon_7.started', polygon_7.tStartRefresh)
    trials_phase1.addData('polygon_7.stopped', polygon_7.tStopRefresh)
    # the Routine "bosa1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_bosa1"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_bosa.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_bosa.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1_2.setText(msg1)
    feedback0_zud1_2.setText(msg0)
    feedback_zud01_2.setText(msg)
    # keep track of which components have finished
    fb_bosa1Components = [feedback1_zud1_2, feedback0_zud1_2, feedback_zud01_2]
    for thisComponent in fb_bosa1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_bosa1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_bosa1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_bosa1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_bosa1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1_2* updates
        if feedback1_zud1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1_2.frameNStart = frameN  # exact frame index
            feedback1_zud1_2.tStart = t  # local t and not account for scr refresh
            feedback1_zud1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1_2, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1_2.setAutoDraw(True)
        if feedback1_zud1_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1_2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1_2.tStop = t  # not accounting for scr refresh
                feedback1_zud1_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1_2, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1_2.setAutoDraw(False)
        
        # *feedback0_zud1_2* updates
        if feedback0_zud1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1_2.frameNStart = frameN  # exact frame index
            feedback0_zud1_2.tStart = t  # local t and not account for scr refresh
            feedback0_zud1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1_2, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1_2.setAutoDraw(True)
        if feedback0_zud1_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1_2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1_2.tStop = t  # not accounting for scr refresh
                feedback0_zud1_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1_2, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1_2.setAutoDraw(False)
        
        # *feedback_zud01_2* updates
        if feedback_zud01_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01_2.frameNStart = frameN  # exact frame index
            feedback_zud01_2.tStart = t  # local t and not account for scr refresh
            feedback_zud01_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01_2, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01_2.setAutoDraw(True)
        if feedback_zud01_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01_2.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01_2.tStop = t  # not accounting for scr refresh
                feedback_zud01_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01_2, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01_2.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_bosa1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_bosa1"-------
    for thisComponent in fb_bosa1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud1_2.started', feedback1_zud1_2.tStartRefresh)
    trials_phase1.addData('feedback1_zud1_2.stopped', feedback1_zud1_2.tStopRefresh)
    trials_phase1.addData('feedback0_zud1_2.started', feedback0_zud1_2.tStartRefresh)
    trials_phase1.addData('feedback0_zud1_2.stopped', feedback0_zud1_2.tStopRefresh)
    trials_phase1.addData('feedback_zud01_2.started', feedback_zud01_2.tStartRefresh)
    trials_phase1.addData('feedback_zud01_2.stopped', feedback_zud01_2.tStopRefresh)
    
    # ------Prepare to start Routine "bosa2"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_bosa2.keys = []
    key_resp_bosa2.rt = []
    _key_resp_bosa2_allKeys = []
    number_correct = number_correct + 1
    print('number_Correct: ' + str(number_correct))
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    # keep track of which components have finished
    bosa2Components = [key_resp_bosa2, blicket1_13, option1_critical_16, option2_critical_16, bosa2text2, polygon_2, polygon_3, polygon_4]
    for thisComponent in bosa2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    bosa2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "bosa2"-------
    while continueRoutine:
        # get current time
        t = bosa2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=bosa2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_bosa2* updates
        waitOnFlip = False
        if key_resp_bosa2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_bosa2.frameNStart = frameN  # exact frame index
            key_resp_bosa2.tStart = t  # local t and not account for scr refresh
            key_resp_bosa2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_bosa2, 'tStartRefresh')  # time at next scr refresh
            key_resp_bosa2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_bosa2.clock.reset)  # t=0 on next screen flip
        if key_resp_bosa2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_bosa2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_bosa2_allKeys.extend(theseKeys)
            if len(_key_resp_bosa2_allKeys):
                key_resp_bosa2.keys = _key_resp_bosa2_allKeys[-1].name  # just the last key pressed
                key_resp_bosa2.rt = _key_resp_bosa2_allKeys[-1].rt
                # was this correct?
                if (key_resp_bosa2.keys == str('2')) or (key_resp_bosa2.keys == '2'):
                    key_resp_bosa2.corr = 1
                else:
                    key_resp_bosa2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_13* updates
        if blicket1_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_13.frameNStart = frameN  # exact frame index
            blicket1_13.tStart = t  # local t and not account for scr refresh
            blicket1_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_13, 'tStartRefresh')  # time at next scr refresh
            blicket1_13.setAutoDraw(True)
        
        # *option1_critical_16* updates
        if option1_critical_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_16.frameNStart = frameN  # exact frame index
            option1_critical_16.tStart = t  # local t and not account for scr refresh
            option1_critical_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_16, 'tStartRefresh')  # time at next scr refresh
            option1_critical_16.setAutoDraw(True)
        
        # *option2_critical_16* updates
        if option2_critical_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_16.frameNStart = frameN  # exact frame index
            option2_critical_16.tStart = t  # local t and not account for scr refresh
            option2_critical_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_16, 'tStartRefresh')  # time at next scr refresh
            option2_critical_16.setAutoDraw(True)
        
        # *bosa2text2* updates
        if bosa2text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bosa2text2.frameNStart = frameN  # exact frame index
            bosa2text2.tStart = t  # local t and not account for scr refresh
            bosa2text2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bosa2text2, 'tStartRefresh')  # time at next scr refresh
            bosa2text2.setAutoDraw(True)
        
        # *polygon_2* updates
        if polygon_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_2.frameNStart = frameN  # exact frame index
            polygon_2.tStart = t  # local t and not account for scr refresh
            polygon_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_2, 'tStartRefresh')  # time at next scr refresh
            polygon_2.setAutoDraw(True)
        
        # *polygon_3* updates
        if polygon_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_3.frameNStart = frameN  # exact frame index
            polygon_3.tStart = t  # local t and not account for scr refresh
            polygon_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_3, 'tStartRefresh')  # time at next scr refresh
            polygon_3.setAutoDraw(True)
        
        # *polygon_4* updates
        if polygon_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            polygon_4.frameNStart = frameN  # exact frame index
            polygon_4.tStart = t  # local t and not account for scr refresh
            polygon_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(polygon_4, 'tStartRefresh')  # time at next scr refresh
            polygon_4.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in bosa2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "bosa2"-------
    for thisComponent in bosa2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_bosa2.keys in ['', [], None]:  # No response was made
        key_resp_bosa2.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_bosa2.corr = 1;  # correct non-response
        else:
           key_resp_bosa2.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase1 (TrialHandler)
    trials_phase1.addData('key_resp_bosa2.keys',key_resp_bosa2.keys)
    trials_phase1.addData('key_resp_bosa2.corr', key_resp_bosa2.corr)
    if key_resp_bosa2.keys != None:  # we had a response
        trials_phase1.addData('key_resp_bosa2.rt', key_resp_bosa2.rt)
    trials_phase1.addData('key_resp_bosa2.started', key_resp_bosa2.tStartRefresh)
    trials_phase1.addData('key_resp_bosa2.stopped', key_resp_bosa2.tStopRefresh)
    trials_phase1.addData('blicket1_13.started', blicket1_13.tStartRefresh)
    trials_phase1.addData('blicket1_13.stopped', blicket1_13.tStopRefresh)
    trials_phase1.addData('option1_critical_16.started', option1_critical_16.tStartRefresh)
    trials_phase1.addData('option1_critical_16.stopped', option1_critical_16.tStopRefresh)
    trials_phase1.addData('option2_critical_16.started', option2_critical_16.tStartRefresh)
    trials_phase1.addData('option2_critical_16.stopped', option2_critical_16.tStopRefresh)
    trials_phase1.addData('bosa2text2.started', bosa2text2.tStartRefresh)
    trials_phase1.addData('bosa2text2.stopped', bosa2text2.tStopRefresh)
    trials_phase1.addData('polygon_2.started', polygon_2.tStartRefresh)
    trials_phase1.addData('polygon_2.stopped', polygon_2.tStopRefresh)
    trials_phase1.addData('polygon_3.started', polygon_3.tStartRefresh)
    trials_phase1.addData('polygon_3.stopped', polygon_3.tStopRefresh)
    trials_phase1.addData('polygon_4.started', polygon_4.tStartRefresh)
    trials_phase1.addData('polygon_4.stopped', polygon_4.tStopRefresh)
    # the Routine "bosa2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_bosa2"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_bosa2.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_bosa2.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1_3.setText(msg1)
    feedback0_zud1_3.setText(msg0)
    feedback_zud01_3.setText(msg)
    # keep track of which components have finished
    fb_bosa2Components = [feedback1_zud1_3, feedback0_zud1_3, feedback_zud01_3]
    for thisComponent in fb_bosa2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_bosa2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_bosa2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_bosa2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_bosa2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1_3* updates
        if feedback1_zud1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1_3.frameNStart = frameN  # exact frame index
            feedback1_zud1_3.tStart = t  # local t and not account for scr refresh
            feedback1_zud1_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1_3, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1_3.setAutoDraw(True)
        if feedback1_zud1_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1_3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1_3.tStop = t  # not accounting for scr refresh
                feedback1_zud1_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1_3, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1_3.setAutoDraw(False)
        
        # *feedback0_zud1_3* updates
        if feedback0_zud1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1_3.frameNStart = frameN  # exact frame index
            feedback0_zud1_3.tStart = t  # local t and not account for scr refresh
            feedback0_zud1_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1_3, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1_3.setAutoDraw(True)
        if feedback0_zud1_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1_3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1_3.tStop = t  # not accounting for scr refresh
                feedback0_zud1_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1_3, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1_3.setAutoDraw(False)
        
        # *feedback_zud01_3* updates
        if feedback_zud01_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01_3.frameNStart = frameN  # exact frame index
            feedback_zud01_3.tStart = t  # local t and not account for scr refresh
            feedback_zud01_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01_3, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01_3.setAutoDraw(True)
        if feedback_zud01_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01_3.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01_3.tStop = t  # not accounting for scr refresh
                feedback_zud01_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01_3, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_bosa2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_bosa2"-------
    for thisComponent in fb_bosa2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase1.addData('feedback1_zud1_3.started', feedback1_zud1_3.tStartRefresh)
    trials_phase1.addData('feedback1_zud1_3.stopped', feedback1_zud1_3.tStopRefresh)
    trials_phase1.addData('feedback0_zud1_3.started', feedback0_zud1_3.tStartRefresh)
    trials_phase1.addData('feedback0_zud1_3.stopped', feedback0_zud1_3.tStopRefresh)
    trials_phase1.addData('feedback_zud01_3.started', feedback_zud01_3.tStartRefresh)
    trials_phase1.addData('feedback_zud01_3.stopped', feedback_zud01_3.tStopRefresh)
    thisExp.nextEntry()
    
# completed 4.0 repeats of 'trials_phase1'


# ------Prepare to start Routine "proceed"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_6.keys = []
key_resp_6.rt = []
_key_resp_6_allKeys = []
# keep track of which components have finished
proceedComponents = [text2, key_resp_6]
for thisComponent in proceedComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
proceedClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "proceed"-------
while continueRoutine:
    # get current time
    t = proceedClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=proceedClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text2* updates
    if text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text2.frameNStart = frameN  # exact frame index
        text2.tStart = t  # local t and not account for scr refresh
        text2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text2, 'tStartRefresh')  # time at next scr refresh
        text2.setAutoDraw(True)
    
    # *key_resp_6* updates
    waitOnFlip = False
    if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_6.frameNStart = frameN  # exact frame index
        key_resp_6.tStart = t  # local t and not account for scr refresh
        key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
        key_resp_6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_6.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_6_allKeys.extend(theseKeys)
        if len(_key_resp_6_allKeys):
            key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
            key_resp_6.rt = _key_resp_6_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in proceedComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "proceed"-------
for thisComponent in proceedComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text2.started', text2.tStartRefresh)
thisExp.addData('text2.stopped', text2.tStopRefresh)
# check responses
if key_resp_6.keys in ['', [], None]:  # No response was made
    key_resp_6.keys = None
thisExp.addData('key_resp_6.keys',key_resp_6.keys)
if key_resp_6.keys != None:  # we had a response
    thisExp.addData('key_resp_6.rt', key_resp_6.rt)
thisExp.addData('key_resp_6.started', key_resp_6.tStartRefresh)
thisExp.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
thisExp.nextEntry()
# the Routine "proceed" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "blank"-------
continueRoutine = True
routineTimer.add(0.200000)
# update component parameters for each repeat
# keep track of which components have finished
blankComponents = [blank500ms]
for thisComponent in blankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
blankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = blankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=blankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *blank500ms* updates
    if blank500ms.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        blank500ms.frameNStart = frameN  # exact frame index
        blank500ms.tStart = t  # local t and not account for scr refresh
        blank500ms.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(blank500ms, 'tStartRefresh')  # time at next scr refresh
        blank500ms.setAutoDraw(True)
    if blank500ms.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > blank500ms.tStartRefresh + 0.2-frameTolerance:
            # keep track of stop time/frame for later
            blank500ms.tStop = t  # not accounting for scr refresh
            blank500ms.frameNStop = frameN  # exact frame index
            win.timeOnFlip(blank500ms, 'tStopRefresh')  # time at next scr refresh
            blank500ms.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in blankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "blank"-------
for thisComponent in blankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('blank500ms.started', blank500ms.tStartRefresh)
thisExp.addData('blank500ms.stopped', blank500ms.tStopRefresh)

# ------Prepare to start Routine "test"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_t1_3.keys = []
key_resp_t1_3.rt = []
_key_resp_t1_3_allKeys = []
t1_triangle1_3.setFillColor('black')
t1_rectangle1_3.setFillColor('black')
# keep track of which components have finished
testComponents = [key_resp_t1_3, t1_zud_3, t1_triangle1_3, t1_rectangle1_3, option1_critical_13, option2_critical_13]
for thisComponent in testComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
testClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "test"-------
while continueRoutine:
    # get current time
    t = testClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=testClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *key_resp_t1_3* updates
    waitOnFlip = False
    if key_resp_t1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_t1_3.frameNStart = frameN  # exact frame index
        key_resp_t1_3.tStart = t  # local t and not account for scr refresh
        key_resp_t1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_t1_3, 'tStartRefresh')  # time at next scr refresh
        key_resp_t1_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_t1_3.clock.reset)  # t=0 on next screen flip
    if key_resp_t1_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_t1_3.getKeys(keyList=['1', '2'], waitRelease=False)
        _key_resp_t1_3_allKeys.extend(theseKeys)
        if len(_key_resp_t1_3_allKeys):
            key_resp_t1_3.keys = _key_resp_t1_3_allKeys[-1].name  # just the last key pressed
            key_resp_t1_3.rt = _key_resp_t1_3_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *t1_zud_3* updates
    if t1_zud_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_zud_3.frameNStart = frameN  # exact frame index
        t1_zud_3.tStart = t  # local t and not account for scr refresh
        t1_zud_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_zud_3, 'tStartRefresh')  # time at next scr refresh
        t1_zud_3.setAutoDraw(True)
    
    # *t1_triangle1_3* updates
    if t1_triangle1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_triangle1_3.frameNStart = frameN  # exact frame index
        t1_triangle1_3.tStart = t  # local t and not account for scr refresh
        t1_triangle1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_triangle1_3, 'tStartRefresh')  # time at next scr refresh
        t1_triangle1_3.setAutoDraw(True)
    
    # *t1_rectangle1_3* updates
    if t1_rectangle1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_rectangle1_3.frameNStart = frameN  # exact frame index
        t1_rectangle1_3.tStart = t  # local t and not account for scr refresh
        t1_rectangle1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_rectangle1_3, 'tStartRefresh')  # time at next scr refresh
        t1_rectangle1_3.setAutoDraw(True)
    
    # *option1_critical_13* updates
    if option1_critical_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option1_critical_13.frameNStart = frameN  # exact frame index
        option1_critical_13.tStart = t  # local t and not account for scr refresh
        option1_critical_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option1_critical_13, 'tStartRefresh')  # time at next scr refresh
        option1_critical_13.setAutoDraw(True)
    
    # *option2_critical_13* updates
    if option2_critical_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option2_critical_13.frameNStart = frameN  # exact frame index
        option2_critical_13.tStart = t  # local t and not account for scr refresh
        option2_critical_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option2_critical_13, 'tStartRefresh')  # time at next scr refresh
        option2_critical_13.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in testComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "test"-------
for thisComponent in testComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if key_resp_t1_3.keys in ['', [], None]:  # No response was made
    key_resp_t1_3.keys = None
thisExp.addData('key_resp_t1_3.keys',key_resp_t1_3.keys)
if key_resp_t1_3.keys != None:  # we had a response
    thisExp.addData('key_resp_t1_3.rt', key_resp_t1_3.rt)
thisExp.addData('key_resp_t1_3.started', key_resp_t1_3.tStartRefresh)
thisExp.addData('key_resp_t1_3.stopped', key_resp_t1_3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('t1_zud_3.started', t1_zud_3.tStartRefresh)
thisExp.addData('t1_zud_3.stopped', t1_zud_3.tStopRefresh)
thisExp.addData('t1_triangle1_3.started', t1_triangle1_3.tStartRefresh)
thisExp.addData('t1_triangle1_3.stopped', t1_triangle1_3.tStopRefresh)
thisExp.addData('t1_rectangle1_3.started', t1_rectangle1_3.tStartRefresh)
thisExp.addData('t1_rectangle1_3.stopped', t1_rectangle1_3.tStopRefresh)
thisExp.addData('option1_critical_13.started', option1_critical_13.tStartRefresh)
thisExp.addData('option1_critical_13.stopped', option1_critical_13.tStopRefresh)
thisExp.addData('option2_critical_13.started', option2_critical_13.tStartRefresh)
thisExp.addData('option2_critical_13.stopped', option2_critical_13.tStopRefresh)
# the Routine "test" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "phase2"-------
continueRoutine = True
routineTimer.add(2.000000)
# update component parameters for each repeat
p2.setText('Phase 2')
# keep track of which components have finished
phase2Components = [p2]
for thisComponent in phase2Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
phase2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "phase2"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = phase2Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=phase2Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *p2* updates
    if p2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        p2.frameNStart = frameN  # exact frame index
        p2.tStart = t  # local t and not account for scr refresh
        p2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(p2, 'tStartRefresh')  # time at next scr refresh
        p2.setAutoDraw(True)
    if p2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > p2.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            p2.tStop = t  # not accounting for scr refresh
            p2.frameNStop = frameN  # exact frame index
            win.timeOnFlip(p2, 'tStopRefresh')  # time at next scr refresh
            p2.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in phase2Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "phase2"-------
for thisComponent in phase2Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('p2.started', p2.tStartRefresh)
thisExp.addData('p2.stopped', p2.tStopRefresh)

# set up handler to look after randomisation of conditions etc
trials_phase_2 = data.TrialHandler(nReps=4.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=[None],
    seed=None, name='trials_phase_2')
thisExp.addLoop(trials_phase_2)  # add the loop to the experiment
thisTrials_phase_2 = trials_phase_2.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTrials_phase_2.rgb)
if thisTrials_phase_2 != None:
    for paramName in thisTrials_phase_2:
        exec('{} = thisTrials_phase_2[paramName]'.format(paramName))

for thisTrials_phase_2 in trials_phase_2:
    currentLoop = trials_phase_2
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_phase_2.rgb)
    if thisTrials_phase_2 != None:
        for paramName in thisTrials_phase_2:
            exec('{} = thisTrials_phase_2[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "start_2"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # keep track of which components have finished
    start_2Components = [text1, key_resp_7]
    for thisComponent in start_2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    start_2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "start_2"-------
    while continueRoutine:
        # get current time
        t = start_2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=start_2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text1* updates
        if text1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text1.frameNStart = frameN  # exact frame index
            text1.tStart = t  # local t and not account for scr refresh
            text1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text1, 'tStartRefresh')  # time at next scr refresh
            text1.setAutoDraw(True)
        
        # *key_resp_7* updates
        waitOnFlip = False
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "start_2"-------
    for thisComponent in start_2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('text1.started', text1.tStartRefresh)
    trials_phase_2.addData('text1.stopped', text1.tStopRefresh)
    # check responses
    if key_resp_7.keys in ['', [], None]:  # No response was made
        key_resp_7.keys = None
    trials_phase_2.addData('key_resp_7.keys',key_resp_7.keys)
    if key_resp_7.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_7.rt', key_resp_7.rt)
    trials_phase_2.addData('key_resp_7.started', key_resp_7.tStartRefresh)
    trials_phase_2.addData('key_resp_7.stopped', key_resp_7.tStopRefresh)
    # the Routine "start_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "zud1"-------
    continueRoutine = True
    # update component parameters for each repeat
    number_correct=0
    star_1.setFillColor('black')
    triangle_1.setFillColor('black')
    cross_1.setFillColor('black')
    key_resp_zud1.keys = []
    key_resp_zud1.rt = []
    _key_resp_zud1_allKeys = []
    # keep track of which components have finished
    zud1Components = [zud1_corr2, star_1, triangle_1, cross_1, option1_01, option2_01, option3_01, key_resp_zud1]
    for thisComponent in zud1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud1"-------
    while continueRoutine:
        # get current time
        t = zud1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud1_corr2* updates
        if zud1_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud1_corr2.frameNStart = frameN  # exact frame index
            zud1_corr2.tStart = t  # local t and not account for scr refresh
            zud1_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud1_corr2, 'tStartRefresh')  # time at next scr refresh
            zud1_corr2.setAutoDraw(True)
        
        # *star_1* updates
        if star_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_1.frameNStart = frameN  # exact frame index
            star_1.tStart = t  # local t and not account for scr refresh
            star_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_1, 'tStartRefresh')  # time at next scr refresh
            star_1.setAutoDraw(True)
        
        # *triangle_1* updates
        if triangle_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_1.frameNStart = frameN  # exact frame index
            triangle_1.tStart = t  # local t and not account for scr refresh
            triangle_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_1, 'tStartRefresh')  # time at next scr refresh
            triangle_1.setAutoDraw(True)
        
        # *cross_1* updates
        if cross_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_1.frameNStart = frameN  # exact frame index
            cross_1.tStart = t  # local t and not account for scr refresh
            cross_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_1, 'tStartRefresh')  # time at next scr refresh
            cross_1.setAutoDraw(True)
        
        # *option1_01* updates
        if option1_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_01.frameNStart = frameN  # exact frame index
            option1_01.tStart = t  # local t and not account for scr refresh
            option1_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_01, 'tStartRefresh')  # time at next scr refresh
            option1_01.setAutoDraw(True)
        
        # *option2_01* updates
        if option2_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_01.frameNStart = frameN  # exact frame index
            option2_01.tStart = t  # local t and not account for scr refresh
            option2_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_01, 'tStartRefresh')  # time at next scr refresh
            option2_01.setAutoDraw(True)
        
        # *option3_01* updates
        if option3_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_01.frameNStart = frameN  # exact frame index
            option3_01.tStart = t  # local t and not account for scr refresh
            option3_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_01, 'tStartRefresh')  # time at next scr refresh
            option3_01.setAutoDraw(True)
        
        # *key_resp_zud1* updates
        waitOnFlip = False
        if key_resp_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud1.frameNStart = frameN  # exact frame index
            key_resp_zud1.tStart = t  # local t and not account for scr refresh
            key_resp_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud1, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud1.clock.reset)  # t=0 on next screen flip
        if key_resp_zud1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud1.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud1_allKeys.extend(theseKeys)
            if len(_key_resp_zud1_allKeys):
                key_resp_zud1.keys = _key_resp_zud1_allKeys[-1].name  # just the last key pressed
                key_resp_zud1.rt = _key_resp_zud1_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud1.keys == str('2')) or (key_resp_zud1.keys == '2'):
                    key_resp_zud1.corr = 1
                else:
                    key_resp_zud1.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud1"-------
    for thisComponent in zud1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud1_corr2.started', zud1_corr2.tStartRefresh)
    trials_phase_2.addData('zud1_corr2.stopped', zud1_corr2.tStopRefresh)
    number_correct = number_correct + 1
    
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('star_1.started', star_1.tStartRefresh)
    trials_phase_2.addData('star_1.stopped', star_1.tStopRefresh)
    trials_phase_2.addData('triangle_1.started', triangle_1.tStartRefresh)
    trials_phase_2.addData('triangle_1.stopped', triangle_1.tStopRefresh)
    trials_phase_2.addData('cross_1.started', cross_1.tStartRefresh)
    trials_phase_2.addData('cross_1.stopped', cross_1.tStopRefresh)
    trials_phase_2.addData('option1_01.started', option1_01.tStartRefresh)
    trials_phase_2.addData('option1_01.stopped', option1_01.tStopRefresh)
    trials_phase_2.addData('option2_01.started', option2_01.tStartRefresh)
    trials_phase_2.addData('option2_01.stopped', option2_01.tStopRefresh)
    trials_phase_2.addData('option3_01.started', option3_01.tStartRefresh)
    trials_phase_2.addData('option3_01.stopped', option3_01.tStopRefresh)
    # check responses
    if key_resp_zud1.keys in ['', [], None]:  # No response was made
        key_resp_zud1.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_zud1.corr = 1;  # correct non-response
        else:
           key_resp_zud1.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud1.keys',key_resp_zud1.keys)
    trials_phase_2.addData('key_resp_zud1.corr', key_resp_zud1.corr)
    if key_resp_zud1.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud1.rt', key_resp_zud1.rt)
    trials_phase_2.addData('key_resp_zud1.started', key_resp_zud1.tStartRefresh)
    trials_phase_2.addData('key_resp_zud1.stopped', key_resp_zud1.tStopRefresh)
    # the Routine "zud1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud1"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud1.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud1.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1.setText(msg1)
    feedback0_zud1.setText(msg0)
    feedback_zud01.setText(msg)
    # keep track of which components have finished
    fb_zud1Components = [feedback1_zud1, feedback0_zud1, feedback_zud01]
    for thisComponent in fb_zud1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1* updates
        if feedback1_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1.frameNStart = frameN  # exact frame index
            feedback1_zud1.tStart = t  # local t and not account for scr refresh
            feedback1_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1.setAutoDraw(True)
        if feedback1_zud1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1.tStop = t  # not accounting for scr refresh
                feedback1_zud1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1.setAutoDraw(False)
        
        # *feedback0_zud1* updates
        if feedback0_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1.frameNStart = frameN  # exact frame index
            feedback0_zud1.tStart = t  # local t and not account for scr refresh
            feedback0_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1.setAutoDraw(True)
        if feedback0_zud1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1.tStop = t  # not accounting for scr refresh
                feedback0_zud1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1.setAutoDraw(False)
        
        # *feedback_zud01* updates
        if feedback_zud01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01.frameNStart = frameN  # exact frame index
            feedback_zud01.tStart = t  # local t and not account for scr refresh
            feedback_zud01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01.setAutoDraw(True)
        if feedback_zud01.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01.tStop = t  # not accounting for scr refresh
                feedback_zud01.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud1"-------
    for thisComponent in fb_zud1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud1.started', feedback1_zud1.tStartRefresh)
    trials_phase_2.addData('feedback1_zud1.stopped', feedback1_zud1.tStopRefresh)
    trials_phase_2.addData('feedback0_zud1.started', feedback0_zud1.tStartRefresh)
    trials_phase_2.addData('feedback0_zud1.stopped', feedback0_zud1.tStopRefresh)
    trials_phase_2.addData('feedback_zud01.started', feedback_zud01.tStartRefresh)
    trials_phase_2.addData('feedback_zud01.stopped', feedback_zud01.tStopRefresh)
    
    # ------Prepare to start Routine "zud2"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_2.setFillColor('black')
    star_2.setFillColor('black')
    cross_2.setFillColor('black')
    key_resp_zud2.keys = []
    key_resp_zud2.rt = []
    _key_resp_zud2_allKeys = []
    # keep track of which components have finished
    zud2Components = [zud2_corr1, triangle_2, star_2, cross_2, key_resp_zud2, option1_02, option2_02, option3_02]
    for thisComponent in zud2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud2"-------
    while continueRoutine:
        # get current time
        t = zud2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud2_corr1* updates
        if zud2_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud2_corr1.frameNStart = frameN  # exact frame index
            zud2_corr1.tStart = t  # local t and not account for scr refresh
            zud2_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud2_corr1, 'tStartRefresh')  # time at next scr refresh
            zud2_corr1.setAutoDraw(True)
        
        # *triangle_2* updates
        if triangle_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_2.frameNStart = frameN  # exact frame index
            triangle_2.tStart = t  # local t and not account for scr refresh
            triangle_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_2, 'tStartRefresh')  # time at next scr refresh
            triangle_2.setAutoDraw(True)
        
        # *star_2* updates
        if star_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_2.frameNStart = frameN  # exact frame index
            star_2.tStart = t  # local t and not account for scr refresh
            star_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_2, 'tStartRefresh')  # time at next scr refresh
            star_2.setAutoDraw(True)
        
        # *cross_2* updates
        if cross_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_2.frameNStart = frameN  # exact frame index
            cross_2.tStart = t  # local t and not account for scr refresh
            cross_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_2, 'tStartRefresh')  # time at next scr refresh
            cross_2.setAutoDraw(True)
        
        # *key_resp_zud2* updates
        waitOnFlip = False
        if key_resp_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud2.frameNStart = frameN  # exact frame index
            key_resp_zud2.tStart = t  # local t and not account for scr refresh
            key_resp_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud2, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud2.clock.reset)  # t=0 on next screen flip
        if key_resp_zud2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud2_allKeys.extend(theseKeys)
            if len(_key_resp_zud2_allKeys):
                key_resp_zud2.keys = _key_resp_zud2_allKeys[-1].name  # just the last key pressed
                key_resp_zud2.rt = _key_resp_zud2_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud2.keys == str('1')) or (key_resp_zud2.keys == '1'):
                    key_resp_zud2.corr = 1
                else:
                    key_resp_zud2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_02* updates
        if option1_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_02.frameNStart = frameN  # exact frame index
            option1_02.tStart = t  # local t and not account for scr refresh
            option1_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_02, 'tStartRefresh')  # time at next scr refresh
            option1_02.setAutoDraw(True)
        
        # *option2_02* updates
        if option2_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_02.frameNStart = frameN  # exact frame index
            option2_02.tStart = t  # local t and not account for scr refresh
            option2_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_02, 'tStartRefresh')  # time at next scr refresh
            option2_02.setAutoDraw(True)
        
        # *option3_02* updates
        if option3_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_02.frameNStart = frameN  # exact frame index
            option3_02.tStart = t  # local t and not account for scr refresh
            option3_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_02, 'tStartRefresh')  # time at next scr refresh
            option3_02.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud2"-------
    for thisComponent in zud2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud2_corr1.started', zud2_corr1.tStartRefresh)
    trials_phase_2.addData('zud2_corr1.stopped', zud2_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('triangle_2.started', triangle_2.tStartRefresh)
    trials_phase_2.addData('triangle_2.stopped', triangle_2.tStopRefresh)
    trials_phase_2.addData('star_2.started', star_2.tStartRefresh)
    trials_phase_2.addData('star_2.stopped', star_2.tStopRefresh)
    trials_phase_2.addData('cross_2.started', cross_2.tStartRefresh)
    trials_phase_2.addData('cross_2.stopped', cross_2.tStopRefresh)
    # check responses
    if key_resp_zud2.keys in ['', [], None]:  # No response was made
        key_resp_zud2.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud2.corr = 1;  # correct non-response
        else:
           key_resp_zud2.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud2.keys',key_resp_zud2.keys)
    trials_phase_2.addData('key_resp_zud2.corr', key_resp_zud2.corr)
    if key_resp_zud2.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud2.rt', key_resp_zud2.rt)
    trials_phase_2.addData('key_resp_zud2.started', key_resp_zud2.tStartRefresh)
    trials_phase_2.addData('key_resp_zud2.stopped', key_resp_zud2.tStopRefresh)
    trials_phase_2.addData('option1_02.started', option1_02.tStartRefresh)
    trials_phase_2.addData('option1_02.stopped', option1_02.tStopRefresh)
    trials_phase_2.addData('option2_02.started', option2_02.tStartRefresh)
    trials_phase_2.addData('option2_02.stopped', option2_02.tStopRefresh)
    trials_phase_2.addData('option3_02.started', option3_02.tStartRefresh)
    trials_phase_2.addData('option3_02.stopped', option3_02.tStopRefresh)
    # the Routine "zud2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud2"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud2.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud2.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud2.setText(msg1)
    feedback0_zud2.setText(msg0)
    feedback_zud02.setText(msg)
    # keep track of which components have finished
    fb_zud2Components = [feedback1_zud2, feedback0_zud2, feedback_zud02]
    for thisComponent in fb_zud2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud2* updates
        if feedback1_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud2.frameNStart = frameN  # exact frame index
            feedback1_zud2.tStart = t  # local t and not account for scr refresh
            feedback1_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud2, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud2.setAutoDraw(True)
        if feedback1_zud2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud2.tStop = t  # not accounting for scr refresh
                feedback1_zud2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud2, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud2.setAutoDraw(False)
        
        # *feedback0_zud2* updates
        if feedback0_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud2.frameNStart = frameN  # exact frame index
            feedback0_zud2.tStart = t  # local t and not account for scr refresh
            feedback0_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud2, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud2.setAutoDraw(True)
        if feedback0_zud2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud2.tStop = t  # not accounting for scr refresh
                feedback0_zud2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud2, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud2.setAutoDraw(False)
        
        # *feedback_zud02* updates
        if feedback_zud02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud02.frameNStart = frameN  # exact frame index
            feedback_zud02.tStart = t  # local t and not account for scr refresh
            feedback_zud02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud02, 'tStartRefresh')  # time at next scr refresh
            feedback_zud02.setAutoDraw(True)
        if feedback_zud02.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud02.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud02.tStop = t  # not accounting for scr refresh
                feedback_zud02.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud02, 'tStopRefresh')  # time at next scr refresh
                feedback_zud02.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud2"-------
    for thisComponent in fb_zud2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud2.started', feedback1_zud2.tStartRefresh)
    trials_phase_2.addData('feedback1_zud2.stopped', feedback1_zud2.tStopRefresh)
    trials_phase_2.addData('feedback0_zud2.started', feedback0_zud2.tStartRefresh)
    trials_phase_2.addData('feedback0_zud2.stopped', feedback0_zud2.tStopRefresh)
    trials_phase_2.addData('feedback_zud02.started', feedback_zud02.tStartRefresh)
    trials_phase_2.addData('feedback_zud02.stopped', feedback_zud02.tStopRefresh)
    
    # ------Prepare to start Routine "zud3"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_3.setFillColor('white')
    star_3.setFillColor('white')
    cross_3.setFillColor('white')
    key_resp_zud3.keys = []
    key_resp_zud3.rt = []
    _key_resp_zud3_allKeys = []
    # keep track of which components have finished
    zud3Components = [zud3_corr1, triangle_3, star_3, cross_3, key_resp_zud3, option1_03, option2_03, option3_03]
    for thisComponent in zud3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud3"-------
    while continueRoutine:
        # get current time
        t = zud3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud3_corr1* updates
        if zud3_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud3_corr1.frameNStart = frameN  # exact frame index
            zud3_corr1.tStart = t  # local t and not account for scr refresh
            zud3_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud3_corr1, 'tStartRefresh')  # time at next scr refresh
            zud3_corr1.setAutoDraw(True)
        
        # *triangle_3* updates
        if triangle_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_3.frameNStart = frameN  # exact frame index
            triangle_3.tStart = t  # local t and not account for scr refresh
            triangle_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_3, 'tStartRefresh')  # time at next scr refresh
            triangle_3.setAutoDraw(True)
        
        # *star_3* updates
        if star_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_3.frameNStart = frameN  # exact frame index
            star_3.tStart = t  # local t and not account for scr refresh
            star_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_3, 'tStartRefresh')  # time at next scr refresh
            star_3.setAutoDraw(True)
        
        # *cross_3* updates
        if cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_3.frameNStart = frameN  # exact frame index
            cross_3.tStart = t  # local t and not account for scr refresh
            cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_3, 'tStartRefresh')  # time at next scr refresh
            cross_3.setAutoDraw(True)
        
        # *key_resp_zud3* updates
        waitOnFlip = False
        if key_resp_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud3.frameNStart = frameN  # exact frame index
            key_resp_zud3.tStart = t  # local t and not account for scr refresh
            key_resp_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud3, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud3.clock.reset)  # t=0 on next screen flip
        if key_resp_zud3.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud3.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud3_allKeys.extend(theseKeys)
            if len(_key_resp_zud3_allKeys):
                key_resp_zud3.keys = _key_resp_zud3_allKeys[-1].name  # just the last key pressed
                key_resp_zud3.rt = _key_resp_zud3_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud3.keys == str('1')) or (key_resp_zud3.keys == '1'):
                    key_resp_zud3.corr = 1
                else:
                    key_resp_zud3.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_03* updates
        if option1_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_03.frameNStart = frameN  # exact frame index
            option1_03.tStart = t  # local t and not account for scr refresh
            option1_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_03, 'tStartRefresh')  # time at next scr refresh
            option1_03.setAutoDraw(True)
        
        # *option2_03* updates
        if option2_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_03.frameNStart = frameN  # exact frame index
            option2_03.tStart = t  # local t and not account for scr refresh
            option2_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_03, 'tStartRefresh')  # time at next scr refresh
            option2_03.setAutoDraw(True)
        
        # *option3_03* updates
        if option3_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_03.frameNStart = frameN  # exact frame index
            option3_03.tStart = t  # local t and not account for scr refresh
            option3_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_03, 'tStartRefresh')  # time at next scr refresh
            option3_03.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud3"-------
    for thisComponent in zud3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud3_corr1.started', zud3_corr1.tStartRefresh)
    trials_phase_2.addData('zud3_corr1.stopped', zud3_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('triangle_3.started', triangle_3.tStartRefresh)
    trials_phase_2.addData('triangle_3.stopped', triangle_3.tStopRefresh)
    trials_phase_2.addData('star_3.started', star_3.tStartRefresh)
    trials_phase_2.addData('star_3.stopped', star_3.tStopRefresh)
    trials_phase_2.addData('cross_3.started', cross_3.tStartRefresh)
    trials_phase_2.addData('cross_3.stopped', cross_3.tStopRefresh)
    # check responses
    if key_resp_zud3.keys in ['', [], None]:  # No response was made
        key_resp_zud3.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud3.corr = 1;  # correct non-response
        else:
           key_resp_zud3.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud3.keys',key_resp_zud3.keys)
    trials_phase_2.addData('key_resp_zud3.corr', key_resp_zud3.corr)
    if key_resp_zud3.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud3.rt', key_resp_zud3.rt)
    trials_phase_2.addData('key_resp_zud3.started', key_resp_zud3.tStartRefresh)
    trials_phase_2.addData('key_resp_zud3.stopped', key_resp_zud3.tStopRefresh)
    trials_phase_2.addData('option1_03.started', option1_03.tStartRefresh)
    trials_phase_2.addData('option1_03.stopped', option1_03.tStopRefresh)
    trials_phase_2.addData('option2_03.started', option2_03.tStartRefresh)
    trials_phase_2.addData('option2_03.stopped', option2_03.tStopRefresh)
    trials_phase_2.addData('option3_03.started', option3_03.tStartRefresh)
    trials_phase_2.addData('option3_03.stopped', option3_03.tStopRefresh)
    # the Routine "zud3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud3"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud3.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud3.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud3.setText(msg1)
    feedback0_zud3.setText(msg0)
    feedback_zud03.setText(msg)
    # keep track of which components have finished
    fb_zud3Components = [feedback1_zud3, feedback0_zud3, feedback_zud03]
    for thisComponent in fb_zud3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud3"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud3* updates
        if feedback1_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud3.frameNStart = frameN  # exact frame index
            feedback1_zud3.tStart = t  # local t and not account for scr refresh
            feedback1_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud3, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud3.setAutoDraw(True)
        if feedback1_zud3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud3.tStop = t  # not accounting for scr refresh
                feedback1_zud3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud3, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud3.setAutoDraw(False)
        
        # *feedback0_zud3* updates
        if feedback0_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud3.frameNStart = frameN  # exact frame index
            feedback0_zud3.tStart = t  # local t and not account for scr refresh
            feedback0_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud3, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud3.setAutoDraw(True)
        if feedback0_zud3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud3.tStop = t  # not accounting for scr refresh
                feedback0_zud3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud3, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud3.setAutoDraw(False)
        
        # *feedback_zud03* updates
        if feedback_zud03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud03.frameNStart = frameN  # exact frame index
            feedback_zud03.tStart = t  # local t and not account for scr refresh
            feedback_zud03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud03, 'tStartRefresh')  # time at next scr refresh
            feedback_zud03.setAutoDraw(True)
        if feedback_zud03.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud03.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud03.tStop = t  # not accounting for scr refresh
                feedback_zud03.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud03, 'tStopRefresh')  # time at next scr refresh
                feedback_zud03.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud3"-------
    for thisComponent in fb_zud3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud3.started', feedback1_zud3.tStartRefresh)
    trials_phase_2.addData('feedback1_zud3.stopped', feedback1_zud3.tStopRefresh)
    trials_phase_2.addData('feedback0_zud3.started', feedback0_zud3.tStartRefresh)
    trials_phase_2.addData('feedback0_zud3.stopped', feedback0_zud3.tStopRefresh)
    trials_phase_2.addData('feedback_zud03.started', feedback_zud03.tStartRefresh)
    trials_phase_2.addData('feedback_zud03.stopped', feedback_zud03.tStopRefresh)
    
    # ------Prepare to start Routine "zud4"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_4.setFillColor('white')
    star_4.setFillColor('white')
    cross_4.setFillColor('white')
    key_resp_zud4.keys = []
    key_resp_zud4.rt = []
    _key_resp_zud4_allKeys = []
    # keep track of which components have finished
    zud4Components = [zud4_corr1, triangle_4, star_4, cross_4, key_resp_zud4, option1_04, option2_04, option3_04]
    for thisComponent in zud4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud4"-------
    while continueRoutine:
        # get current time
        t = zud4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud4_corr1* updates
        if zud4_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud4_corr1.frameNStart = frameN  # exact frame index
            zud4_corr1.tStart = t  # local t and not account for scr refresh
            zud4_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud4_corr1, 'tStartRefresh')  # time at next scr refresh
            zud4_corr1.setAutoDraw(True)
        
        # *triangle_4* updates
        if triangle_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_4.frameNStart = frameN  # exact frame index
            triangle_4.tStart = t  # local t and not account for scr refresh
            triangle_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_4, 'tStartRefresh')  # time at next scr refresh
            triangle_4.setAutoDraw(True)
        
        # *star_4* updates
        if star_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_4.frameNStart = frameN  # exact frame index
            star_4.tStart = t  # local t and not account for scr refresh
            star_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_4, 'tStartRefresh')  # time at next scr refresh
            star_4.setAutoDraw(True)
        
        # *cross_4* updates
        if cross_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_4.frameNStart = frameN  # exact frame index
            cross_4.tStart = t  # local t and not account for scr refresh
            cross_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_4, 'tStartRefresh')  # time at next scr refresh
            cross_4.setAutoDraw(True)
        
        # *key_resp_zud4* updates
        waitOnFlip = False
        if key_resp_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud4.frameNStart = frameN  # exact frame index
            key_resp_zud4.tStart = t  # local t and not account for scr refresh
            key_resp_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud4, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud4.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud4.clock.reset)  # t=0 on next screen flip
        if key_resp_zud4.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud4.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud4_allKeys.extend(theseKeys)
            if len(_key_resp_zud4_allKeys):
                key_resp_zud4.keys = _key_resp_zud4_allKeys[-1].name  # just the last key pressed
                key_resp_zud4.rt = _key_resp_zud4_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud4.keys == str('1')) or (key_resp_zud4.keys == '1'):
                    key_resp_zud4.corr = 1
                else:
                    key_resp_zud4.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_04* updates
        if option1_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_04.frameNStart = frameN  # exact frame index
            option1_04.tStart = t  # local t and not account for scr refresh
            option1_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_04, 'tStartRefresh')  # time at next scr refresh
            option1_04.setAutoDraw(True)
        
        # *option2_04* updates
        if option2_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_04.frameNStart = frameN  # exact frame index
            option2_04.tStart = t  # local t and not account for scr refresh
            option2_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_04, 'tStartRefresh')  # time at next scr refresh
            option2_04.setAutoDraw(True)
        
        # *option3_04* updates
        if option3_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_04.frameNStart = frameN  # exact frame index
            option3_04.tStart = t  # local t and not account for scr refresh
            option3_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_04, 'tStartRefresh')  # time at next scr refresh
            option3_04.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud4"-------
    for thisComponent in zud4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud4_corr1.started', zud4_corr1.tStartRefresh)
    trials_phase_2.addData('zud4_corr1.stopped', zud4_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('triangle_4.started', triangle_4.tStartRefresh)
    trials_phase_2.addData('triangle_4.stopped', triangle_4.tStopRefresh)
    trials_phase_2.addData('star_4.started', star_4.tStartRefresh)
    trials_phase_2.addData('star_4.stopped', star_4.tStopRefresh)
    trials_phase_2.addData('cross_4.started', cross_4.tStartRefresh)
    trials_phase_2.addData('cross_4.stopped', cross_4.tStopRefresh)
    # check responses
    if key_resp_zud4.keys in ['', [], None]:  # No response was made
        key_resp_zud4.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud4.corr = 1;  # correct non-response
        else:
           key_resp_zud4.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud4.keys',key_resp_zud4.keys)
    trials_phase_2.addData('key_resp_zud4.corr', key_resp_zud4.corr)
    if key_resp_zud4.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud4.rt', key_resp_zud4.rt)
    trials_phase_2.addData('key_resp_zud4.started', key_resp_zud4.tStartRefresh)
    trials_phase_2.addData('key_resp_zud4.stopped', key_resp_zud4.tStopRefresh)
    trials_phase_2.addData('option1_04.started', option1_04.tStartRefresh)
    trials_phase_2.addData('option1_04.stopped', option1_04.tStopRefresh)
    trials_phase_2.addData('option2_04.started', option2_04.tStartRefresh)
    trials_phase_2.addData('option2_04.stopped', option2_04.tStopRefresh)
    trials_phase_2.addData('option3_04.started', option3_04.tStartRefresh)
    trials_phase_2.addData('option3_04.stopped', option3_04.tStopRefresh)
    # the Routine "zud4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud4"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud4.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud4.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud4.setText(msg1)
    feedback0_zud4.setText(msg0)
    feedback_zud04.setText(msg)
    # keep track of which components have finished
    fb_zud4Components = [feedback1_zud4, feedback0_zud4, feedback_zud04]
    for thisComponent in fb_zud4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud4"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud4* updates
        if feedback1_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud4.frameNStart = frameN  # exact frame index
            feedback1_zud4.tStart = t  # local t and not account for scr refresh
            feedback1_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud4, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud4.setAutoDraw(True)
        if feedback1_zud4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud4.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud4.tStop = t  # not accounting for scr refresh
                feedback1_zud4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud4, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud4.setAutoDraw(False)
        
        # *feedback0_zud4* updates
        if feedback0_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud4.frameNStart = frameN  # exact frame index
            feedback0_zud4.tStart = t  # local t and not account for scr refresh
            feedback0_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud4, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud4.setAutoDraw(True)
        if feedback0_zud4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud4.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud4.tStop = t  # not accounting for scr refresh
                feedback0_zud4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud4, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud4.setAutoDraw(False)
        
        # *feedback_zud04* updates
        if feedback_zud04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud04.frameNStart = frameN  # exact frame index
            feedback_zud04.tStart = t  # local t and not account for scr refresh
            feedback_zud04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud04, 'tStartRefresh')  # time at next scr refresh
            feedback_zud04.setAutoDraw(True)
        if feedback_zud04.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud04.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud04.tStop = t  # not accounting for scr refresh
                feedback_zud04.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud04, 'tStopRefresh')  # time at next scr refresh
                feedback_zud04.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud4"-------
    for thisComponent in fb_zud4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud4.started', feedback1_zud4.tStartRefresh)
    trials_phase_2.addData('feedback1_zud4.stopped', feedback1_zud4.tStopRefresh)
    trials_phase_2.addData('feedback0_zud4.started', feedback0_zud4.tStartRefresh)
    trials_phase_2.addData('feedback0_zud4.stopped', feedback0_zud4.tStopRefresh)
    trials_phase_2.addData('feedback_zud04.started', feedback_zud04.tStartRefresh)
    trials_phase_2.addData('feedback_zud04.stopped', feedback_zud04.tStopRefresh)
    
    # ------Prepare to start Routine "zud5"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud5.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_5.setFillColor('black')
    cross_5.setFillColor('black')
    rectangle_5.setFillColor('black')
    key_resp_zud5.keys = []
    key_resp_zud5.rt = []
    _key_resp_zud5_allKeys = []
    # keep track of which components have finished
    zud5Components = [zud5_corr3, star_5, cross_5, rectangle_5, key_resp_zud5, option1_05, option2_05, option3_05]
    for thisComponent in zud5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud5"-------
    while continueRoutine:
        # get current time
        t = zud5Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud5Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud5_corr3* updates
        if zud5_corr3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud5_corr3.frameNStart = frameN  # exact frame index
            zud5_corr3.tStart = t  # local t and not account for scr refresh
            zud5_corr3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud5_corr3, 'tStartRefresh')  # time at next scr refresh
            zud5_corr3.setAutoDraw(True)
        
        # *star_5* updates
        if star_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_5.frameNStart = frameN  # exact frame index
            star_5.tStart = t  # local t and not account for scr refresh
            star_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_5, 'tStartRefresh')  # time at next scr refresh
            star_5.setAutoDraw(True)
        
        # *cross_5* updates
        if cross_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_5.frameNStart = frameN  # exact frame index
            cross_5.tStart = t  # local t and not account for scr refresh
            cross_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_5, 'tStartRefresh')  # time at next scr refresh
            cross_5.setAutoDraw(True)
        
        # *rectangle_5* updates
        if rectangle_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_5.frameNStart = frameN  # exact frame index
            rectangle_5.tStart = t  # local t and not account for scr refresh
            rectangle_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_5, 'tStartRefresh')  # time at next scr refresh
            rectangle_5.setAutoDraw(True)
        
        # *key_resp_zud5* updates
        waitOnFlip = False
        if key_resp_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud5.frameNStart = frameN  # exact frame index
            key_resp_zud5.tStart = t  # local t and not account for scr refresh
            key_resp_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud5, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud5.clock.reset)  # t=0 on next screen flip
        if key_resp_zud5.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud5.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud5_allKeys.extend(theseKeys)
            if len(_key_resp_zud5_allKeys):
                key_resp_zud5.keys = _key_resp_zud5_allKeys[-1].name  # just the last key pressed
                key_resp_zud5.rt = _key_resp_zud5_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud5.keys == str('3')) or (key_resp_zud5.keys == '3'):
                    key_resp_zud5.corr = 1
                else:
                    key_resp_zud5.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_05* updates
        if option1_05.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_05.frameNStart = frameN  # exact frame index
            option1_05.tStart = t  # local t and not account for scr refresh
            option1_05.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_05, 'tStartRefresh')  # time at next scr refresh
            option1_05.setAutoDraw(True)
        
        # *option2_05* updates
        if option2_05.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_05.frameNStart = frameN  # exact frame index
            option2_05.tStart = t  # local t and not account for scr refresh
            option2_05.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_05, 'tStartRefresh')  # time at next scr refresh
            option2_05.setAutoDraw(True)
        
        # *option3_05* updates
        if option3_05.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_05.frameNStart = frameN  # exact frame index
            option3_05.tStart = t  # local t and not account for scr refresh
            option3_05.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_05, 'tStartRefresh')  # time at next scr refresh
            option3_05.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud5"-------
    for thisComponent in zud5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud5_corr3.started', zud5_corr3.tStartRefresh)
    trials_phase_2.addData('zud5_corr3.stopped', zud5_corr3.tStopRefresh)
    trials_phase_2.addData('star_5.started', star_5.tStartRefresh)
    trials_phase_2.addData('star_5.stopped', star_5.tStopRefresh)
    trials_phase_2.addData('cross_5.started', cross_5.tStartRefresh)
    trials_phase_2.addData('cross_5.stopped', cross_5.tStopRefresh)
    trials_phase_2.addData('rectangle_5.started', rectangle_5.tStartRefresh)
    trials_phase_2.addData('rectangle_5.stopped', rectangle_5.tStopRefresh)
    # check responses
    if key_resp_zud5.keys in ['', [], None]:  # No response was made
        key_resp_zud5.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_zud5.corr = 1;  # correct non-response
        else:
           key_resp_zud5.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud5.keys',key_resp_zud5.keys)
    trials_phase_2.addData('key_resp_zud5.corr', key_resp_zud5.corr)
    if key_resp_zud5.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud5.rt', key_resp_zud5.rt)
    trials_phase_2.addData('key_resp_zud5.started', key_resp_zud5.tStartRefresh)
    trials_phase_2.addData('key_resp_zud5.stopped', key_resp_zud5.tStopRefresh)
    trials_phase_2.addData('option1_05.started', option1_05.tStartRefresh)
    trials_phase_2.addData('option1_05.stopped', option1_05.tStopRefresh)
    trials_phase_2.addData('option2_05.started', option2_05.tStartRefresh)
    trials_phase_2.addData('option2_05.stopped', option2_05.tStopRefresh)
    trials_phase_2.addData('option3_05.started', option3_05.tStartRefresh)
    trials_phase_2.addData('option3_05.stopped', option3_05.tStopRefresh)
    # the Routine "zud5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud5"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud5.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud5.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud5.setText(msg1)
    feedback0_zud5.setText(msg0)
    feedback_zud5.setText(msg)
    # keep track of which components have finished
    fb_zud5Components = [feedback1_zud5, feedback0_zud5, feedback_zud5]
    for thisComponent in fb_zud5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud5"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud5Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud5Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud5* updates
        if feedback1_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud5.frameNStart = frameN  # exact frame index
            feedback1_zud5.tStart = t  # local t and not account for scr refresh
            feedback1_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud5, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud5.setAutoDraw(True)
        if feedback1_zud5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud5.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud5.tStop = t  # not accounting for scr refresh
                feedback1_zud5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud5, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud5.setAutoDraw(False)
        
        # *feedback0_zud5* updates
        if feedback0_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud5.frameNStart = frameN  # exact frame index
            feedback0_zud5.tStart = t  # local t and not account for scr refresh
            feedback0_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud5, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud5.setAutoDraw(True)
        if feedback0_zud5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud5.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud5.tStop = t  # not accounting for scr refresh
                feedback0_zud5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud5, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud5.setAutoDraw(False)
        
        # *feedback_zud5* updates
        if feedback_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud5.frameNStart = frameN  # exact frame index
            feedback_zud5.tStart = t  # local t and not account for scr refresh
            feedback_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud5, 'tStartRefresh')  # time at next scr refresh
            feedback_zud5.setAutoDraw(True)
        if feedback_zud5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud5.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud5.tStop = t  # not accounting for scr refresh
                feedback_zud5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud5, 'tStopRefresh')  # time at next scr refresh
                feedback_zud5.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud5"-------
    for thisComponent in fb_zud5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud5.started', feedback1_zud5.tStartRefresh)
    trials_phase_2.addData('feedback1_zud5.stopped', feedback1_zud5.tStopRefresh)
    trials_phase_2.addData('feedback0_zud5.started', feedback0_zud5.tStartRefresh)
    trials_phase_2.addData('feedback0_zud5.stopped', feedback0_zud5.tStopRefresh)
    trials_phase_2.addData('feedback_zud5.started', feedback_zud5.tStartRefresh)
    trials_phase_2.addData('feedback_zud5.stopped', feedback_zud5.tStopRefresh)
    
    # ------Prepare to start Routine "zud6"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud6.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_6.setFillColor('black')
    cross_6.setFillColor('black')
    rectangle_6.setFillColor('black')
    key_resp_zud6.keys = []
    key_resp_zud6.rt = []
    _key_resp_zud6_allKeys = []
    # keep track of which components have finished
    zud6Components = [zud6_corr3, star_6, cross_6, rectangle_6, key_resp_zud6, option1_06, option2_06, option3_06]
    for thisComponent in zud6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud6"-------
    while continueRoutine:
        # get current time
        t = zud6Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud6Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud6_corr3* updates
        if zud6_corr3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud6_corr3.frameNStart = frameN  # exact frame index
            zud6_corr3.tStart = t  # local t and not account for scr refresh
            zud6_corr3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud6_corr3, 'tStartRefresh')  # time at next scr refresh
            zud6_corr3.setAutoDraw(True)
        
        # *star_6* updates
        if star_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_6.frameNStart = frameN  # exact frame index
            star_6.tStart = t  # local t and not account for scr refresh
            star_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_6, 'tStartRefresh')  # time at next scr refresh
            star_6.setAutoDraw(True)
        
        # *cross_6* updates
        if cross_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_6.frameNStart = frameN  # exact frame index
            cross_6.tStart = t  # local t and not account for scr refresh
            cross_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_6, 'tStartRefresh')  # time at next scr refresh
            cross_6.setAutoDraw(True)
        
        # *rectangle_6* updates
        if rectangle_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_6.frameNStart = frameN  # exact frame index
            rectangle_6.tStart = t  # local t and not account for scr refresh
            rectangle_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_6, 'tStartRefresh')  # time at next scr refresh
            rectangle_6.setAutoDraw(True)
        
        # *key_resp_zud6* updates
        waitOnFlip = False
        if key_resp_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud6.frameNStart = frameN  # exact frame index
            key_resp_zud6.tStart = t  # local t and not account for scr refresh
            key_resp_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud6, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud6.clock.reset)  # t=0 on next screen flip
        if key_resp_zud6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud6.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud6_allKeys.extend(theseKeys)
            if len(_key_resp_zud6_allKeys):
                key_resp_zud6.keys = _key_resp_zud6_allKeys[-1].name  # just the last key pressed
                key_resp_zud6.rt = _key_resp_zud6_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud6.keys == str('3')) or (key_resp_zud6.keys == '3'):
                    key_resp_zud6.corr = 1
                else:
                    key_resp_zud6.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_06* updates
        if option1_06.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_06.frameNStart = frameN  # exact frame index
            option1_06.tStart = t  # local t and not account for scr refresh
            option1_06.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_06, 'tStartRefresh')  # time at next scr refresh
            option1_06.setAutoDraw(True)
        
        # *option2_06* updates
        if option2_06.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_06.frameNStart = frameN  # exact frame index
            option2_06.tStart = t  # local t and not account for scr refresh
            option2_06.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_06, 'tStartRefresh')  # time at next scr refresh
            option2_06.setAutoDraw(True)
        
        # *option3_06* updates
        if option3_06.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_06.frameNStart = frameN  # exact frame index
            option3_06.tStart = t  # local t and not account for scr refresh
            option3_06.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_06, 'tStartRefresh')  # time at next scr refresh
            option3_06.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud6"-------
    for thisComponent in zud6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud6_corr3.started', zud6_corr3.tStartRefresh)
    trials_phase_2.addData('zud6_corr3.stopped', zud6_corr3.tStopRefresh)
    trials_phase_2.addData('star_6.started', star_6.tStartRefresh)
    trials_phase_2.addData('star_6.stopped', star_6.tStopRefresh)
    trials_phase_2.addData('cross_6.started', cross_6.tStartRefresh)
    trials_phase_2.addData('cross_6.stopped', cross_6.tStopRefresh)
    trials_phase_2.addData('rectangle_6.started', rectangle_6.tStartRefresh)
    trials_phase_2.addData('rectangle_6.stopped', rectangle_6.tStopRefresh)
    # check responses
    if key_resp_zud6.keys in ['', [], None]:  # No response was made
        key_resp_zud6.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_zud6.corr = 1;  # correct non-response
        else:
           key_resp_zud6.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud6.keys',key_resp_zud6.keys)
    trials_phase_2.addData('key_resp_zud6.corr', key_resp_zud6.corr)
    if key_resp_zud6.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud6.rt', key_resp_zud6.rt)
    trials_phase_2.addData('key_resp_zud6.started', key_resp_zud6.tStartRefresh)
    trials_phase_2.addData('key_resp_zud6.stopped', key_resp_zud6.tStopRefresh)
    trials_phase_2.addData('option1_06.started', option1_06.tStartRefresh)
    trials_phase_2.addData('option1_06.stopped', option1_06.tStopRefresh)
    trials_phase_2.addData('option2_06.started', option2_06.tStartRefresh)
    trials_phase_2.addData('option2_06.stopped', option2_06.tStopRefresh)
    trials_phase_2.addData('option3_06.started', option3_06.tStartRefresh)
    trials_phase_2.addData('option3_06.stopped', option3_06.tStopRefresh)
    # the Routine "zud6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud6"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud6.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud6.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud6.setText(msg1)
    feedback0_zud6.setText(msg0)
    feedback_zud6.setText(msg)
    # keep track of which components have finished
    fb_zud6Components = [feedback1_zud6, feedback0_zud6, feedback_zud6]
    for thisComponent in fb_zud6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud6"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud6Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud6Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud6* updates
        if feedback1_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud6.frameNStart = frameN  # exact frame index
            feedback1_zud6.tStart = t  # local t and not account for scr refresh
            feedback1_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud6, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud6.setAutoDraw(True)
        if feedback1_zud6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud6.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud6.tStop = t  # not accounting for scr refresh
                feedback1_zud6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud6, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud6.setAutoDraw(False)
        
        # *feedback0_zud6* updates
        if feedback0_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud6.frameNStart = frameN  # exact frame index
            feedback0_zud6.tStart = t  # local t and not account for scr refresh
            feedback0_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud6, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud6.setAutoDraw(True)
        if feedback0_zud6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud6.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud6.tStop = t  # not accounting for scr refresh
                feedback0_zud6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud6, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud6.setAutoDraw(False)
        
        # *feedback_zud6* updates
        if feedback_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud6.frameNStart = frameN  # exact frame index
            feedback_zud6.tStart = t  # local t and not account for scr refresh
            feedback_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud6, 'tStartRefresh')  # time at next scr refresh
            feedback_zud6.setAutoDraw(True)
        if feedback_zud6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud6.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud6.tStop = t  # not accounting for scr refresh
                feedback_zud6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud6, 'tStopRefresh')  # time at next scr refresh
                feedback_zud6.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud6"-------
    for thisComponent in fb_zud6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud6.started', feedback1_zud6.tStartRefresh)
    trials_phase_2.addData('feedback1_zud6.stopped', feedback1_zud6.tStopRefresh)
    trials_phase_2.addData('feedback0_zud6.started', feedback0_zud6.tStartRefresh)
    trials_phase_2.addData('feedback0_zud6.stopped', feedback0_zud6.tStopRefresh)
    trials_phase_2.addData('feedback_zud6.started', feedback_zud6.tStartRefresh)
    trials_phase_2.addData('feedback_zud6.stopped', feedback_zud6.tStopRefresh)
    
    # ------Prepare to start Routine "zud7"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud7.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    rectangle_7.setFillColor('white')
    cross_7.setFillColor('white')
    star_7.setFillColor('white')
    key_resp_zud7.keys = []
    key_resp_zud7.rt = []
    _key_resp_zud7_allKeys = []
    # keep track of which components have finished
    zud7Components = [zud7_corr1, rectangle_7, cross_7, star_7, key_resp_zud7, option1_07, option2_07, option3_07]
    for thisComponent in zud7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud7"-------
    while continueRoutine:
        # get current time
        t = zud7Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud7Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud7_corr1* updates
        if zud7_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud7_corr1.frameNStart = frameN  # exact frame index
            zud7_corr1.tStart = t  # local t and not account for scr refresh
            zud7_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud7_corr1, 'tStartRefresh')  # time at next scr refresh
            zud7_corr1.setAutoDraw(True)
        
        # *rectangle_7* updates
        if rectangle_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_7.frameNStart = frameN  # exact frame index
            rectangle_7.tStart = t  # local t and not account for scr refresh
            rectangle_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_7, 'tStartRefresh')  # time at next scr refresh
            rectangle_7.setAutoDraw(True)
        
        # *cross_7* updates
        if cross_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_7.frameNStart = frameN  # exact frame index
            cross_7.tStart = t  # local t and not account for scr refresh
            cross_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_7, 'tStartRefresh')  # time at next scr refresh
            cross_7.setAutoDraw(True)
        
        # *star_7* updates
        if star_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_7.frameNStart = frameN  # exact frame index
            star_7.tStart = t  # local t and not account for scr refresh
            star_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_7, 'tStartRefresh')  # time at next scr refresh
            star_7.setAutoDraw(True)
        
        # *key_resp_zud7* updates
        waitOnFlip = False
        if key_resp_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud7.frameNStart = frameN  # exact frame index
            key_resp_zud7.tStart = t  # local t and not account for scr refresh
            key_resp_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud7, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud7.clock.reset)  # t=0 on next screen flip
        if key_resp_zud7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud7.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud7_allKeys.extend(theseKeys)
            if len(_key_resp_zud7_allKeys):
                key_resp_zud7.keys = _key_resp_zud7_allKeys[-1].name  # just the last key pressed
                key_resp_zud7.rt = _key_resp_zud7_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud7.keys == str('1')) or (key_resp_zud7.keys == '1'):
                    key_resp_zud7.corr = 1
                else:
                    key_resp_zud7.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_07* updates
        if option1_07.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_07.frameNStart = frameN  # exact frame index
            option1_07.tStart = t  # local t and not account for scr refresh
            option1_07.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_07, 'tStartRefresh')  # time at next scr refresh
            option1_07.setAutoDraw(True)
        
        # *option2_07* updates
        if option2_07.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_07.frameNStart = frameN  # exact frame index
            option2_07.tStart = t  # local t and not account for scr refresh
            option2_07.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_07, 'tStartRefresh')  # time at next scr refresh
            option2_07.setAutoDraw(True)
        
        # *option3_07* updates
        if option3_07.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_07.frameNStart = frameN  # exact frame index
            option3_07.tStart = t  # local t and not account for scr refresh
            option3_07.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_07, 'tStartRefresh')  # time at next scr refresh
            option3_07.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud7"-------
    for thisComponent in zud7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud7_corr1.started', zud7_corr1.tStartRefresh)
    trials_phase_2.addData('zud7_corr1.stopped', zud7_corr1.tStopRefresh)
    trials_phase_2.addData('rectangle_7.started', rectangle_7.tStartRefresh)
    trials_phase_2.addData('rectangle_7.stopped', rectangle_7.tStopRefresh)
    trials_phase_2.addData('cross_7.started', cross_7.tStartRefresh)
    trials_phase_2.addData('cross_7.stopped', cross_7.tStopRefresh)
    trials_phase_2.addData('star_7.started', star_7.tStartRefresh)
    trials_phase_2.addData('star_7.stopped', star_7.tStopRefresh)
    # check responses
    if key_resp_zud7.keys in ['', [], None]:  # No response was made
        key_resp_zud7.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud7.corr = 1;  # correct non-response
        else:
           key_resp_zud7.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud7.keys',key_resp_zud7.keys)
    trials_phase_2.addData('key_resp_zud7.corr', key_resp_zud7.corr)
    if key_resp_zud7.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud7.rt', key_resp_zud7.rt)
    trials_phase_2.addData('key_resp_zud7.started', key_resp_zud7.tStartRefresh)
    trials_phase_2.addData('key_resp_zud7.stopped', key_resp_zud7.tStopRefresh)
    trials_phase_2.addData('option1_07.started', option1_07.tStartRefresh)
    trials_phase_2.addData('option1_07.stopped', option1_07.tStopRefresh)
    trials_phase_2.addData('option2_07.started', option2_07.tStartRefresh)
    trials_phase_2.addData('option2_07.stopped', option2_07.tStopRefresh)
    trials_phase_2.addData('option3_07.started', option3_07.tStartRefresh)
    trials_phase_2.addData('option3_07.stopped', option3_07.tStopRefresh)
    # the Routine "zud7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud7"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud7.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud7.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud7.setText(msg1)
    feedback0_zud7.setText(msg0)
    feedback_zud7.setText(msg)
    # keep track of which components have finished
    fb_zud7Components = [feedback1_zud7, feedback0_zud7, feedback_zud7]
    for thisComponent in fb_zud7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud7"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud7Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud7Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud7* updates
        if feedback1_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud7.frameNStart = frameN  # exact frame index
            feedback1_zud7.tStart = t  # local t and not account for scr refresh
            feedback1_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud7, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud7.setAutoDraw(True)
        if feedback1_zud7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud7.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud7.tStop = t  # not accounting for scr refresh
                feedback1_zud7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud7, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud7.setAutoDraw(False)
        
        # *feedback0_zud7* updates
        if feedback0_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud7.frameNStart = frameN  # exact frame index
            feedback0_zud7.tStart = t  # local t and not account for scr refresh
            feedback0_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud7, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud7.setAutoDraw(True)
        if feedback0_zud7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud7.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud7.tStop = t  # not accounting for scr refresh
                feedback0_zud7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud7, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud7.setAutoDraw(False)
        
        # *feedback_zud7* updates
        if feedback_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud7.frameNStart = frameN  # exact frame index
            feedback_zud7.tStart = t  # local t and not account for scr refresh
            feedback_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud7, 'tStartRefresh')  # time at next scr refresh
            feedback_zud7.setAutoDraw(True)
        if feedback_zud7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud7.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud7.tStop = t  # not accounting for scr refresh
                feedback_zud7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud7, 'tStopRefresh')  # time at next scr refresh
                feedback_zud7.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud7"-------
    for thisComponent in fb_zud7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud7.started', feedback1_zud7.tStartRefresh)
    trials_phase_2.addData('feedback1_zud7.stopped', feedback1_zud7.tStopRefresh)
    trials_phase_2.addData('feedback0_zud7.started', feedback0_zud7.tStartRefresh)
    trials_phase_2.addData('feedback0_zud7.stopped', feedback0_zud7.tStopRefresh)
    trials_phase_2.addData('feedback_zud7.started', feedback_zud7.tStartRefresh)
    trials_phase_2.addData('feedback_zud7.stopped', feedback_zud7.tStopRefresh)
    
    # ------Prepare to start Routine "zud8"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud8.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_8.setFillColor('white')
    rectangle_8.setFillColor('white')
    cross_8.setFillColor('white')
    key_resp_zud8.keys = []
    key_resp_zud8.rt = []
    _key_resp_zud8_allKeys = []
    # keep track of which components have finished
    zud8Components = [zud8_corr2, star_8, rectangle_8, cross_8, key_resp_zud8, option1_9, option2_9, option3_8]
    for thisComponent in zud8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud8"-------
    while continueRoutine:
        # get current time
        t = zud8Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud8Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud8_corr2* updates
        if zud8_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud8_corr2.frameNStart = frameN  # exact frame index
            zud8_corr2.tStart = t  # local t and not account for scr refresh
            zud8_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud8_corr2, 'tStartRefresh')  # time at next scr refresh
            zud8_corr2.setAutoDraw(True)
        
        # *star_8* updates
        if star_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_8.frameNStart = frameN  # exact frame index
            star_8.tStart = t  # local t and not account for scr refresh
            star_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_8, 'tStartRefresh')  # time at next scr refresh
            star_8.setAutoDraw(True)
        
        # *rectangle_8* updates
        if rectangle_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_8.frameNStart = frameN  # exact frame index
            rectangle_8.tStart = t  # local t and not account for scr refresh
            rectangle_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_8, 'tStartRefresh')  # time at next scr refresh
            rectangle_8.setAutoDraw(True)
        
        # *cross_8* updates
        if cross_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_8.frameNStart = frameN  # exact frame index
            cross_8.tStart = t  # local t and not account for scr refresh
            cross_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_8, 'tStartRefresh')  # time at next scr refresh
            cross_8.setAutoDraw(True)
        
        # *key_resp_zud8* updates
        waitOnFlip = False
        if key_resp_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud8.frameNStart = frameN  # exact frame index
            key_resp_zud8.tStart = t  # local t and not account for scr refresh
            key_resp_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud8, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud8.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud8.clock.reset)  # t=0 on next screen flip
        if key_resp_zud8.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud8.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud8_allKeys.extend(theseKeys)
            if len(_key_resp_zud8_allKeys):
                key_resp_zud8.keys = _key_resp_zud8_allKeys[-1].name  # just the last key pressed
                key_resp_zud8.rt = _key_resp_zud8_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud8.keys == str('2')) or (key_resp_zud8.keys == '2'):
                    key_resp_zud8.corr = 1
                else:
                    key_resp_zud8.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_9* updates
        if option1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_9.frameNStart = frameN  # exact frame index
            option1_9.tStart = t  # local t and not account for scr refresh
            option1_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_9, 'tStartRefresh')  # time at next scr refresh
            option1_9.setAutoDraw(True)
        
        # *option2_9* updates
        if option2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_9.frameNStart = frameN  # exact frame index
            option2_9.tStart = t  # local t and not account for scr refresh
            option2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_9, 'tStartRefresh')  # time at next scr refresh
            option2_9.setAutoDraw(True)
        
        # *option3_8* updates
        if option3_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_8.frameNStart = frameN  # exact frame index
            option3_8.tStart = t  # local t and not account for scr refresh
            option3_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_8, 'tStartRefresh')  # time at next scr refresh
            option3_8.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud8"-------
    for thisComponent in zud8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('zud8_corr2.started', zud8_corr2.tStartRefresh)
    trials_phase_2.addData('zud8_corr2.stopped', zud8_corr2.tStopRefresh)
    trials_phase_2.addData('star_8.started', star_8.tStartRefresh)
    trials_phase_2.addData('star_8.stopped', star_8.tStopRefresh)
    trials_phase_2.addData('rectangle_8.started', rectangle_8.tStartRefresh)
    trials_phase_2.addData('rectangle_8.stopped', rectangle_8.tStopRefresh)
    trials_phase_2.addData('cross_8.started', cross_8.tStartRefresh)
    trials_phase_2.addData('cross_8.stopped', cross_8.tStopRefresh)
    # check responses
    if key_resp_zud8.keys in ['', [], None]:  # No response was made
        key_resp_zud8.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_zud8.corr = 1;  # correct non-response
        else:
           key_resp_zud8.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_zud8.keys',key_resp_zud8.keys)
    trials_phase_2.addData('key_resp_zud8.corr', key_resp_zud8.corr)
    if key_resp_zud8.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_zud8.rt', key_resp_zud8.rt)
    trials_phase_2.addData('key_resp_zud8.started', key_resp_zud8.tStartRefresh)
    trials_phase_2.addData('key_resp_zud8.stopped', key_resp_zud8.tStopRefresh)
    trials_phase_2.addData('option1_9.started', option1_9.tStartRefresh)
    trials_phase_2.addData('option1_9.stopped', option1_9.tStopRefresh)
    trials_phase_2.addData('option2_9.started', option2_9.tStartRefresh)
    trials_phase_2.addData('option2_9.stopped', option2_9.tStopRefresh)
    trials_phase_2.addData('option3_8.started', option3_8.tStartRefresh)
    trials_phase_2.addData('option3_8.stopped', option3_8.tStopRefresh)
    # the Routine "zud8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud8"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud8.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_zud8.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud8.setText(msg1)
    feedback0_zud8.setText(msg0)
    feedback_zud8.setText(msg)
    # keep track of which components have finished
    fb_zud8Components = [feedback1_zud8, feedback0_zud8, feedback_zud8]
    for thisComponent in fb_zud8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud8"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud8Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud8Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud8* updates
        if feedback1_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud8.frameNStart = frameN  # exact frame index
            feedback1_zud8.tStart = t  # local t and not account for scr refresh
            feedback1_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud8, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud8.setAutoDraw(True)
        if feedback1_zud8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud8.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud8.tStop = t  # not accounting for scr refresh
                feedback1_zud8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud8, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud8.setAutoDraw(False)
        
        # *feedback0_zud8* updates
        if feedback0_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud8.frameNStart = frameN  # exact frame index
            feedback0_zud8.tStart = t  # local t and not account for scr refresh
            feedback0_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud8, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud8.setAutoDraw(True)
        if feedback0_zud8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud8.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud8.tStop = t  # not accounting for scr refresh
                feedback0_zud8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud8, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud8.setAutoDraw(False)
        
        # *feedback_zud8* updates
        if feedback_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud8.frameNStart = frameN  # exact frame index
            feedback_zud8.tStart = t  # local t and not account for scr refresh
            feedback_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud8, 'tStartRefresh')  # time at next scr refresh
            feedback_zud8.setAutoDraw(True)
        if feedback_zud8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud8.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud8.tStop = t  # not accounting for scr refresh
                feedback_zud8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud8, 'tStopRefresh')  # time at next scr refresh
                feedback_zud8.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud8"-------
    for thisComponent in fb_zud8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_zud8.started', feedback1_zud8.tStartRefresh)
    trials_phase_2.addData('feedback1_zud8.stopped', feedback1_zud8.tStopRefresh)
    trials_phase_2.addData('feedback0_zud8.started', feedback0_zud8.tStartRefresh)
    trials_phase_2.addData('feedback0_zud8.stopped', feedback0_zud8.tStopRefresh)
    trials_phase_2.addData('feedback_zud8.started', feedback_zud8.tStartRefresh)
    trials_phase_2.addData('feedback_zud8.stopped', feedback_zud8.tStopRefresh)
    
    # ------Prepare to start Routine "dax9"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax9.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_9.setFillColor('black')
    triange_9.setFillColor('black')
    cross_9.setFillColor('black')
    key_resp_dax9.keys = []
    key_resp_dax9.rt = []
    _key_resp_dax9_allKeys = []
    # keep track of which components have finished
    dax9Components = [dax9_corr2, star_9, triange_9, cross_9, key_resp_dax9, option1, option2, option3]
    for thisComponent in dax9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax9"-------
    while continueRoutine:
        # get current time
        t = dax9Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax9Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2* updates
        if dax9_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2.frameNStart = frameN  # exact frame index
            dax9_corr2.tStart = t  # local t and not account for scr refresh
            dax9_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2.setAutoDraw(True)
        
        # *star_9* updates
        if star_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_9.frameNStart = frameN  # exact frame index
            star_9.tStart = t  # local t and not account for scr refresh
            star_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_9, 'tStartRefresh')  # time at next scr refresh
            star_9.setAutoDraw(True)
        
        # *triange_9* updates
        if triange_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_9.frameNStart = frameN  # exact frame index
            triange_9.tStart = t  # local t and not account for scr refresh
            triange_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_9, 'tStartRefresh')  # time at next scr refresh
            triange_9.setAutoDraw(True)
        
        # *cross_9* updates
        if cross_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_9.frameNStart = frameN  # exact frame index
            cross_9.tStart = t  # local t and not account for scr refresh
            cross_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_9, 'tStartRefresh')  # time at next scr refresh
            cross_9.setAutoDraw(True)
        
        # *key_resp_dax9* updates
        waitOnFlip = False
        if key_resp_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax9.frameNStart = frameN  # exact frame index
            key_resp_dax9.tStart = t  # local t and not account for scr refresh
            key_resp_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax9, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax9.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax9.clock.reset)  # t=0 on next screen flip
        if key_resp_dax9.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax9.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax9_allKeys.extend(theseKeys)
            if len(_key_resp_dax9_allKeys):
                key_resp_dax9.keys = _key_resp_dax9_allKeys[-1].name  # just the last key pressed
                key_resp_dax9.rt = _key_resp_dax9_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax9.keys == str('2')) or (key_resp_dax9.keys == '2'):
                    key_resp_dax9.corr = 1
                else:
                    key_resp_dax9.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1* updates
        if option1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1.frameNStart = frameN  # exact frame index
            option1.tStart = t  # local t and not account for scr refresh
            option1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1, 'tStartRefresh')  # time at next scr refresh
            option1.setAutoDraw(True)
        
        # *option2* updates
        if option2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2.frameNStart = frameN  # exact frame index
            option2.tStart = t  # local t and not account for scr refresh
            option2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2, 'tStartRefresh')  # time at next scr refresh
            option2.setAutoDraw(True)
        
        # *option3* updates
        if option3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3.frameNStart = frameN  # exact frame index
            option3.tStart = t  # local t and not account for scr refresh
            option3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3, 'tStartRefresh')  # time at next scr refresh
            option3.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax9"-------
    for thisComponent in dax9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2.started', dax9_corr2.tStartRefresh)
    trials_phase_2.addData('dax9_corr2.stopped', dax9_corr2.tStopRefresh)
    trials_phase_2.addData('star_9.started', star_9.tStartRefresh)
    trials_phase_2.addData('star_9.stopped', star_9.tStopRefresh)
    trials_phase_2.addData('triange_9.started', triange_9.tStartRefresh)
    trials_phase_2.addData('triange_9.stopped', triange_9.tStopRefresh)
    trials_phase_2.addData('cross_9.started', cross_9.tStartRefresh)
    trials_phase_2.addData('cross_9.stopped', cross_9.tStopRefresh)
    # check responses
    if key_resp_dax9.keys in ['', [], None]:  # No response was made
        key_resp_dax9.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_dax9.corr = 1;  # correct non-response
        else:
           key_resp_dax9.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_dax9.keys',key_resp_dax9.keys)
    trials_phase_2.addData('key_resp_dax9.corr', key_resp_dax9.corr)
    if key_resp_dax9.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_dax9.rt', key_resp_dax9.rt)
    trials_phase_2.addData('key_resp_dax9.started', key_resp_dax9.tStartRefresh)
    trials_phase_2.addData('key_resp_dax9.stopped', key_resp_dax9.tStopRefresh)
    trials_phase_2.addData('option1.started', option1.tStartRefresh)
    trials_phase_2.addData('option1.stopped', option1.tStopRefresh)
    trials_phase_2.addData('option2.started', option2.tStartRefresh)
    trials_phase_2.addData('option2.stopped', option2.tStopRefresh)
    trials_phase_2.addData('option3.started', option3.tStartRefresh)
    trials_phase_2.addData('option3.stopped', option3.tStopRefresh)
    # the Routine "dax9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax9"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax9.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax9.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9.setText(msg1)
    feedback0_dax9.setText(msg0)
    feedback_dax9.setText(msg)
    # keep track of which components have finished
    fb_dax9Components = [feedback1_dax9, feedback0_dax9, feedback_dax9]
    for thisComponent in fb_dax9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax9"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax9Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax9Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9* updates
        if feedback1_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9.frameNStart = frameN  # exact frame index
            feedback1_dax9.tStart = t  # local t and not account for scr refresh
            feedback1_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9.setAutoDraw(True)
        if feedback1_dax9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9.tStop = t  # not accounting for scr refresh
                feedback1_dax9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9.setAutoDraw(False)
        
        # *feedback0_dax9* updates
        if feedback0_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9.frameNStart = frameN  # exact frame index
            feedback0_dax9.tStart = t  # local t and not account for scr refresh
            feedback0_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9.setAutoDraw(True)
        if feedback0_dax9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9.tStop = t  # not accounting for scr refresh
                feedback0_dax9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9.setAutoDraw(False)
        
        # *feedback_dax9* updates
        if feedback_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9.frameNStart = frameN  # exact frame index
            feedback_dax9.tStart = t  # local t and not account for scr refresh
            feedback_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9.setAutoDraw(True)
        if feedback_dax9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9.tStop = t  # not accounting for scr refresh
                feedback_dax9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax9"-------
    for thisComponent in fb_dax9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9.started', feedback1_dax9.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9.stopped', feedback1_dax9.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9.started', feedback0_dax9.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9.stopped', feedback0_dax9.tStopRefresh)
    trials_phase_2.addData('feedback_dax9.started', feedback_dax9.tStartRefresh)
    trials_phase_2.addData('feedback_dax9.stopped', feedback_dax9.tStopRefresh)
    
    # ------Prepare to start Routine "dax10"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud7.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    triangle_10.setFillColor('black')
    cross_10.setFillColor('black')
    star_10.setFillColor('black')
    key_resp_dax10.keys = []
    key_resp_dax10.rt = []
    _key_resp_dax10_allKeys = []
    # keep track of which components have finished
    dax10Components = [dax10_corr1, triangle_10, cross_10, star_10, key_resp_dax10, option1_8, option2_8, option3_10]
    for thisComponent in dax10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax10"-------
    while continueRoutine:
        # get current time
        t = dax10Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax10Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax10_corr1* updates
        if dax10_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax10_corr1.frameNStart = frameN  # exact frame index
            dax10_corr1.tStart = t  # local t and not account for scr refresh
            dax10_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax10_corr1, 'tStartRefresh')  # time at next scr refresh
            dax10_corr1.setAutoDraw(True)
        
        # *triangle_10* updates
        if triangle_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_10.frameNStart = frameN  # exact frame index
            triangle_10.tStart = t  # local t and not account for scr refresh
            triangle_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_10, 'tStartRefresh')  # time at next scr refresh
            triangle_10.setAutoDraw(True)
        
        # *cross_10* updates
        if cross_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_10.frameNStart = frameN  # exact frame index
            cross_10.tStart = t  # local t and not account for scr refresh
            cross_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_10, 'tStartRefresh')  # time at next scr refresh
            cross_10.setAutoDraw(True)
        
        # *star_10* updates
        if star_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_10.frameNStart = frameN  # exact frame index
            star_10.tStart = t  # local t and not account for scr refresh
            star_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_10, 'tStartRefresh')  # time at next scr refresh
            star_10.setAutoDraw(True)
        
        # *key_resp_dax10* updates
        waitOnFlip = False
        if key_resp_dax10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax10.frameNStart = frameN  # exact frame index
            key_resp_dax10.tStart = t  # local t and not account for scr refresh
            key_resp_dax10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax10, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax10.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax10.clock.reset)  # t=0 on next screen flip
        if key_resp_dax10.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax10.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax10_allKeys.extend(theseKeys)
            if len(_key_resp_dax10_allKeys):
                key_resp_dax10.keys = _key_resp_dax10_allKeys[-1].name  # just the last key pressed
                key_resp_dax10.rt = _key_resp_dax10_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax10.keys == str('1')) or (key_resp_dax10.keys == '1'):
                    key_resp_dax10.corr = 1
                else:
                    key_resp_dax10.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_8* updates
        if option1_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_8.frameNStart = frameN  # exact frame index
            option1_8.tStart = t  # local t and not account for scr refresh
            option1_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_8, 'tStartRefresh')  # time at next scr refresh
            option1_8.setAutoDraw(True)
        
        # *option2_8* updates
        if option2_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_8.frameNStart = frameN  # exact frame index
            option2_8.tStart = t  # local t and not account for scr refresh
            option2_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_8, 'tStartRefresh')  # time at next scr refresh
            option2_8.setAutoDraw(True)
        
        # *option3_10* updates
        if option3_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_10.frameNStart = frameN  # exact frame index
            option3_10.tStart = t  # local t and not account for scr refresh
            option3_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_10, 'tStartRefresh')  # time at next scr refresh
            option3_10.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax10"-------
    for thisComponent in dax10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax10_corr1.started', dax10_corr1.tStartRefresh)
    trials_phase_2.addData('dax10_corr1.stopped', dax10_corr1.tStopRefresh)
    trials_phase_2.addData('triangle_10.started', triangle_10.tStartRefresh)
    trials_phase_2.addData('triangle_10.stopped', triangle_10.tStopRefresh)
    trials_phase_2.addData('cross_10.started', cross_10.tStartRefresh)
    trials_phase_2.addData('cross_10.stopped', cross_10.tStopRefresh)
    trials_phase_2.addData('star_10.started', star_10.tStartRefresh)
    trials_phase_2.addData('star_10.stopped', star_10.tStopRefresh)
    # check responses
    if key_resp_dax10.keys in ['', [], None]:  # No response was made
        key_resp_dax10.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_dax10.corr = 1;  # correct non-response
        else:
           key_resp_dax10.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_dax10.keys',key_resp_dax10.keys)
    trials_phase_2.addData('key_resp_dax10.corr', key_resp_dax10.corr)
    if key_resp_dax10.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_dax10.rt', key_resp_dax10.rt)
    trials_phase_2.addData('key_resp_dax10.started', key_resp_dax10.tStartRefresh)
    trials_phase_2.addData('key_resp_dax10.stopped', key_resp_dax10.tStopRefresh)
    trials_phase_2.addData('option1_8.started', option1_8.tStartRefresh)
    trials_phase_2.addData('option1_8.stopped', option1_8.tStopRefresh)
    trials_phase_2.addData('option2_8.started', option2_8.tStartRefresh)
    trials_phase_2.addData('option2_8.stopped', option2_8.tStopRefresh)
    trials_phase_2.addData('option3_10.started', option3_10.tStartRefresh)
    trials_phase_2.addData('option3_10.stopped', option3_10.tStopRefresh)
    # the Routine "dax10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax10"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax10.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax10.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_2.setText(msg1)
    feedback0_dax9_2.setText(msg0)
    feedback_dax9_2.setText(msg)
    # keep track of which components have finished
    fb_dax10Components = [feedback1_dax9_2, feedback0_dax9_2, feedback_dax9_2]
    for thisComponent in fb_dax10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax10"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax10Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax10Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_2* updates
        if feedback1_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_2.frameNStart = frameN  # exact frame index
            feedback1_dax9_2.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_2, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_2.setAutoDraw(True)
        if feedback1_dax9_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_2.tStop = t  # not accounting for scr refresh
                feedback1_dax9_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_2, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_2.setAutoDraw(False)
        
        # *feedback0_dax9_2* updates
        if feedback0_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_2.frameNStart = frameN  # exact frame index
            feedback0_dax9_2.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_2, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_2.setAutoDraw(True)
        if feedback0_dax9_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_2.tStop = t  # not accounting for scr refresh
                feedback0_dax9_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_2, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_2.setAutoDraw(False)
        
        # *feedback_dax9_2* updates
        if feedback_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_2.frameNStart = frameN  # exact frame index
            feedback_dax9_2.tStart = t  # local t and not account for scr refresh
            feedback_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_2, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_2.setAutoDraw(True)
        if feedback_dax9_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_2.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_2.tStop = t  # not accounting for scr refresh
                feedback_dax9_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_2, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_2.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax10"-------
    for thisComponent in fb_dax10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_2.started', feedback1_dax9_2.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_2.stopped', feedback1_dax9_2.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_2.started', feedback0_dax9_2.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_2.stopped', feedback0_dax9_2.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_2.started', feedback_dax9_2.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_2.stopped', feedback_dax9_2.tStopRefresh)
    
    # ------Prepare to start Routine "dax11"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax11.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_11.setFillColor('white')
    cross_11.setFillColor('white')
    triangle_11.setFillColor('white')
    key_resp_dax11.keys = []
    key_resp_dax11.rt = []
    _key_resp_dax11_allKeys = []
    # keep track of which components have finished
    dax11Components = [dax11_corr3, star_11, cross_11, triangle_11, key_resp_dax11, option1_6, option2_6, option3_6]
    for thisComponent in dax11Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax11"-------
    while continueRoutine:
        # get current time
        t = dax11Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax11Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax11_corr3* updates
        if dax11_corr3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax11_corr3.frameNStart = frameN  # exact frame index
            dax11_corr3.tStart = t  # local t and not account for scr refresh
            dax11_corr3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax11_corr3, 'tStartRefresh')  # time at next scr refresh
            dax11_corr3.setAutoDraw(True)
        
        # *star_11* updates
        if star_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_11.frameNStart = frameN  # exact frame index
            star_11.tStart = t  # local t and not account for scr refresh
            star_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_11, 'tStartRefresh')  # time at next scr refresh
            star_11.setAutoDraw(True)
        
        # *cross_11* updates
        if cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_11.frameNStart = frameN  # exact frame index
            cross_11.tStart = t  # local t and not account for scr refresh
            cross_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_11, 'tStartRefresh')  # time at next scr refresh
            cross_11.setAutoDraw(True)
        
        # *triangle_11* updates
        if triangle_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_11.frameNStart = frameN  # exact frame index
            triangle_11.tStart = t  # local t and not account for scr refresh
            triangle_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_11, 'tStartRefresh')  # time at next scr refresh
            triangle_11.setAutoDraw(True)
        
        # *key_resp_dax11* updates
        waitOnFlip = False
        if key_resp_dax11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax11.frameNStart = frameN  # exact frame index
            key_resp_dax11.tStart = t  # local t and not account for scr refresh
            key_resp_dax11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax11, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax11.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax11.clock.reset)  # t=0 on next screen flip
        if key_resp_dax11.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax11.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax11_allKeys.extend(theseKeys)
            if len(_key_resp_dax11_allKeys):
                key_resp_dax11.keys = _key_resp_dax11_allKeys[-1].name  # just the last key pressed
                key_resp_dax11.rt = _key_resp_dax11_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax11.keys == str('3')) or (key_resp_dax11.keys == '3'):
                    key_resp_dax11.corr = 1
                else:
                    key_resp_dax11.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_6* updates
        if option1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_6.frameNStart = frameN  # exact frame index
            option1_6.tStart = t  # local t and not account for scr refresh
            option1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_6, 'tStartRefresh')  # time at next scr refresh
            option1_6.setAutoDraw(True)
        
        # *option2_6* updates
        if option2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_6.frameNStart = frameN  # exact frame index
            option2_6.tStart = t  # local t and not account for scr refresh
            option2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_6, 'tStartRefresh')  # time at next scr refresh
            option2_6.setAutoDraw(True)
        
        # *option3_6* updates
        if option3_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_6.frameNStart = frameN  # exact frame index
            option3_6.tStart = t  # local t and not account for scr refresh
            option3_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_6, 'tStartRefresh')  # time at next scr refresh
            option3_6.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax11Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax11"-------
    for thisComponent in dax11Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax11_corr3.started', dax11_corr3.tStartRefresh)
    trials_phase_2.addData('dax11_corr3.stopped', dax11_corr3.tStopRefresh)
    trials_phase_2.addData('star_11.started', star_11.tStartRefresh)
    trials_phase_2.addData('star_11.stopped', star_11.tStopRefresh)
    trials_phase_2.addData('cross_11.started', cross_11.tStartRefresh)
    trials_phase_2.addData('cross_11.stopped', cross_11.tStopRefresh)
    trials_phase_2.addData('triangle_11.started', triangle_11.tStartRefresh)
    trials_phase_2.addData('triangle_11.stopped', triangle_11.tStopRefresh)
    # check responses
    if key_resp_dax11.keys in ['', [], None]:  # No response was made
        key_resp_dax11.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_dax11.corr = 1;  # correct non-response
        else:
           key_resp_dax11.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_dax11.keys',key_resp_dax11.keys)
    trials_phase_2.addData('key_resp_dax11.corr', key_resp_dax11.corr)
    if key_resp_dax11.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_dax11.rt', key_resp_dax11.rt)
    trials_phase_2.addData('key_resp_dax11.started', key_resp_dax11.tStartRefresh)
    trials_phase_2.addData('key_resp_dax11.stopped', key_resp_dax11.tStopRefresh)
    trials_phase_2.addData('option1_6.started', option1_6.tStartRefresh)
    trials_phase_2.addData('option1_6.stopped', option1_6.tStopRefresh)
    trials_phase_2.addData('option2_6.started', option2_6.tStartRefresh)
    trials_phase_2.addData('option2_6.stopped', option2_6.tStopRefresh)
    trials_phase_2.addData('option3_6.started', option3_6.tStartRefresh)
    trials_phase_2.addData('option3_6.stopped', option3_6.tStopRefresh)
    # the Routine "dax11" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax11"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax11.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax11.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_3.setText(msg1)
    feedback0_dax9_3.setText(msg0)
    feedback_dax9_3.setText(msg)
    # keep track of which components have finished
    fb_dax11Components = [feedback1_dax9_3, feedback0_dax9_3, feedback_dax9_3]
    for thisComponent in fb_dax11Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax11"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax11Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax11Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_3* updates
        if feedback1_dax9_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_3.frameNStart = frameN  # exact frame index
            feedback1_dax9_3.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_3, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_3.setAutoDraw(True)
        if feedback1_dax9_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_3.tStop = t  # not accounting for scr refresh
                feedback1_dax9_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_3, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_3.setAutoDraw(False)
        
        # *feedback0_dax9_3* updates
        if feedback0_dax9_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_3.frameNStart = frameN  # exact frame index
            feedback0_dax9_3.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_3, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_3.setAutoDraw(True)
        if feedback0_dax9_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_3.tStop = t  # not accounting for scr refresh
                feedback0_dax9_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_3, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_3.setAutoDraw(False)
        
        # *feedback_dax9_3* updates
        if feedback_dax9_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_3.frameNStart = frameN  # exact frame index
            feedback_dax9_3.tStart = t  # local t and not account for scr refresh
            feedback_dax9_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_3, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_3.setAutoDraw(True)
        if feedback_dax9_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_3.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_3.tStop = t  # not accounting for scr refresh
                feedback_dax9_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_3, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax11Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax11"-------
    for thisComponent in fb_dax11Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_3.started', feedback1_dax9_3.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_3.stopped', feedback1_dax9_3.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_3.started', feedback0_dax9_3.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_3.stopped', feedback0_dax9_3.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_3.started', feedback_dax9_3.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_3.stopped', feedback_dax9_3.tStopRefresh)
    
    # ------Prepare to start Routine "dax12"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax12.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_12.setFillColor('white')
    tr_12.setFillColor('white')
    cr_12.setFillColor('white')
    key_resp_dax12.keys = []
    key_resp_dax12.rt = []
    _key_resp_dax12_allKeys = []
    # keep track of which components have finished
    dax12Components = [dax11_corr2, star_12, tr_12, cr_12, key_resp_dax12, option1_7, option2_7, option3_7]
    for thisComponent in dax12Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax12"-------
    while continueRoutine:
        # get current time
        t = dax12Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax12Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax11_corr2* updates
        if dax11_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax11_corr2.frameNStart = frameN  # exact frame index
            dax11_corr2.tStart = t  # local t and not account for scr refresh
            dax11_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax11_corr2, 'tStartRefresh')  # time at next scr refresh
            dax11_corr2.setAutoDraw(True)
        
        # *star_12* updates
        if star_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_12.frameNStart = frameN  # exact frame index
            star_12.tStart = t  # local t and not account for scr refresh
            star_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_12, 'tStartRefresh')  # time at next scr refresh
            star_12.setAutoDraw(True)
        
        # *tr_12* updates
        if tr_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            tr_12.frameNStart = frameN  # exact frame index
            tr_12.tStart = t  # local t and not account for scr refresh
            tr_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(tr_12, 'tStartRefresh')  # time at next scr refresh
            tr_12.setAutoDraw(True)
        
        # *cr_12* updates
        if cr_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cr_12.frameNStart = frameN  # exact frame index
            cr_12.tStart = t  # local t and not account for scr refresh
            cr_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cr_12, 'tStartRefresh')  # time at next scr refresh
            cr_12.setAutoDraw(True)
        
        # *key_resp_dax12* updates
        waitOnFlip = False
        if key_resp_dax12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax12.frameNStart = frameN  # exact frame index
            key_resp_dax12.tStart = t  # local t and not account for scr refresh
            key_resp_dax12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax12, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax12.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax12.clock.reset)  # t=0 on next screen flip
        if key_resp_dax12.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax12.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax12_allKeys.extend(theseKeys)
            if len(_key_resp_dax12_allKeys):
                key_resp_dax12.keys = _key_resp_dax12_allKeys[-1].name  # just the last key pressed
                key_resp_dax12.rt = _key_resp_dax12_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax12.keys == str('2')) or (key_resp_dax12.keys == '2'):
                    key_resp_dax12.corr = 1
                else:
                    key_resp_dax12.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_7* updates
        if option1_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_7.frameNStart = frameN  # exact frame index
            option1_7.tStart = t  # local t and not account for scr refresh
            option1_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_7, 'tStartRefresh')  # time at next scr refresh
            option1_7.setAutoDraw(True)
        
        # *option2_7* updates
        if option2_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_7.frameNStart = frameN  # exact frame index
            option2_7.tStart = t  # local t and not account for scr refresh
            option2_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_7, 'tStartRefresh')  # time at next scr refresh
            option2_7.setAutoDraw(True)
        
        # *option3_7* updates
        if option3_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_7.frameNStart = frameN  # exact frame index
            option3_7.tStart = t  # local t and not account for scr refresh
            option3_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_7, 'tStartRefresh')  # time at next scr refresh
            option3_7.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax12Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax12"-------
    for thisComponent in dax12Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax11_corr2.started', dax11_corr2.tStartRefresh)
    trials_phase_2.addData('dax11_corr2.stopped', dax11_corr2.tStopRefresh)
    trials_phase_2.addData('star_12.started', star_12.tStartRefresh)
    trials_phase_2.addData('star_12.stopped', star_12.tStopRefresh)
    trials_phase_2.addData('tr_12.started', tr_12.tStartRefresh)
    trials_phase_2.addData('tr_12.stopped', tr_12.tStopRefresh)
    trials_phase_2.addData('cr_12.started', cr_12.tStartRefresh)
    trials_phase_2.addData('cr_12.stopped', cr_12.tStopRefresh)
    # check responses
    if key_resp_dax12.keys in ['', [], None]:  # No response was made
        key_resp_dax12.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_dax12.corr = 1;  # correct non-response
        else:
           key_resp_dax12.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_dax12.keys',key_resp_dax12.keys)
    trials_phase_2.addData('key_resp_dax12.corr', key_resp_dax12.corr)
    if key_resp_dax12.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_dax12.rt', key_resp_dax12.rt)
    trials_phase_2.addData('key_resp_dax12.started', key_resp_dax12.tStartRefresh)
    trials_phase_2.addData('key_resp_dax12.stopped', key_resp_dax12.tStopRefresh)
    trials_phase_2.addData('option1_7.started', option1_7.tStartRefresh)
    trials_phase_2.addData('option1_7.stopped', option1_7.tStopRefresh)
    trials_phase_2.addData('option2_7.started', option2_7.tStartRefresh)
    trials_phase_2.addData('option2_7.stopped', option2_7.tStopRefresh)
    trials_phase_2.addData('option3_7.started', option3_7.tStartRefresh)
    trials_phase_2.addData('option3_7.stopped', option3_7.tStopRefresh)
    # the Routine "dax12" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax12"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax12.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax12.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_4.setText(msg1)
    feedback0_dax9_4.setText(msg0)
    feedback_dax9_4.setText(msg)
    # keep track of which components have finished
    fb_dax12Components = [feedback1_dax9_4, feedback0_dax9_4, feedback_dax9_4]
    for thisComponent in fb_dax12Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax12"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax12Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax12Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_4* updates
        if feedback1_dax9_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_4.frameNStart = frameN  # exact frame index
            feedback1_dax9_4.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_4, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_4.setAutoDraw(True)
        if feedback1_dax9_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_4.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_4.tStop = t  # not accounting for scr refresh
                feedback1_dax9_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_4, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_4.setAutoDraw(False)
        
        # *feedback0_dax9_4* updates
        if feedback0_dax9_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_4.frameNStart = frameN  # exact frame index
            feedback0_dax9_4.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_4, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_4.setAutoDraw(True)
        if feedback0_dax9_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_4.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_4.tStop = t  # not accounting for scr refresh
                feedback0_dax9_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_4, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_4.setAutoDraw(False)
        
        # *feedback_dax9_4* updates
        if feedback_dax9_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_4.frameNStart = frameN  # exact frame index
            feedback_dax9_4.tStart = t  # local t and not account for scr refresh
            feedback_dax9_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_4, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_4.setAutoDraw(True)
        if feedback_dax9_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_4.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_4.tStop = t  # not accounting for scr refresh
                feedback_dax9_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_4, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_4.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax12Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax12"-------
    for thisComponent in fb_dax12Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_4.started', feedback1_dax9_4.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_4.stopped', feedback1_dax9_4.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_4.started', feedback0_dax9_4.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_4.stopped', feedback0_dax9_4.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_4.started', feedback_dax9_4.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_4.stopped', feedback_dax9_4.tStopRefresh)
    
    # ------Prepare to start Routine "blicket13"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blicket13.keys = []
    key_resp_blicket13.rt = []
    _key_resp_blicket13_allKeys = []
    blicket_st_w.setFillColor('white')
    blicket_st_b.setFillColor('white')
    # keep track of which components have finished
    blicket13Components = [key_resp_blicket13, blicket1, blicket_st_w, blicket_st_b, rec_bl_2, option1_critical_3, option2_critical_3, text3]
    for thisComponent in blicket13Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicket13Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicket13"-------
    while continueRoutine:
        # get current time
        t = blicket13Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicket13Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_blicket13* updates
        waitOnFlip = False
        if key_resp_blicket13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicket13.frameNStart = frameN  # exact frame index
            key_resp_blicket13.tStart = t  # local t and not account for scr refresh
            key_resp_blicket13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicket13, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicket13.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicket13.clock.reset)  # t=0 on next screen flip
        if key_resp_blicket13.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicket13.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicket13_allKeys.extend(theseKeys)
            if len(_key_resp_blicket13_allKeys):
                key_resp_blicket13.keys = _key_resp_blicket13_allKeys[-1].name  # just the last key pressed
                key_resp_blicket13.rt = _key_resp_blicket13_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicket13.keys == str('3')) or (key_resp_blicket13.keys == '3'):
                    key_resp_blicket13.corr = 1
                else:
                    key_resp_blicket13.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1* updates
        if blicket1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1.frameNStart = frameN  # exact frame index
            blicket1.tStart = t  # local t and not account for scr refresh
            blicket1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1, 'tStartRefresh')  # time at next scr refresh
            blicket1.setAutoDraw(True)
        
        # *blicket_st_w* updates
        if blicket_st_w.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w.frameNStart = frameN  # exact frame index
            blicket_st_w.tStart = t  # local t and not account for scr refresh
            blicket_st_w.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w.setAutoDraw(True)
        
        # *blicket_st_b* updates
        if blicket_st_b.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b.frameNStart = frameN  # exact frame index
            blicket_st_b.tStart = t  # local t and not account for scr refresh
            blicket_st_b.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b.setAutoDraw(True)
        
        # *rec_bl_2* updates
        if rec_bl_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rec_bl_2.frameNStart = frameN  # exact frame index
            rec_bl_2.tStart = t  # local t and not account for scr refresh
            rec_bl_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rec_bl_2, 'tStartRefresh')  # time at next scr refresh
            rec_bl_2.setAutoDraw(True)
        
        # *option1_critical_3* updates
        if option1_critical_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_3.frameNStart = frameN  # exact frame index
            option1_critical_3.tStart = t  # local t and not account for scr refresh
            option1_critical_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_3, 'tStartRefresh')  # time at next scr refresh
            option1_critical_3.setAutoDraw(True)
        
        # *option2_critical_3* updates
        if option2_critical_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_3.frameNStart = frameN  # exact frame index
            option2_critical_3.tStart = t  # local t and not account for scr refresh
            option2_critical_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_3, 'tStartRefresh')  # time at next scr refresh
            option2_critical_3.setAutoDraw(True)
        
        # *text3* updates
        if text3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text3.frameNStart = frameN  # exact frame index
            text3.tStart = t  # local t and not account for scr refresh
            text3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text3, 'tStartRefresh')  # time at next scr refresh
            text3.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicket13Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicket13"-------
    for thisComponent in blicket13Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_blicket13.keys in ['', [], None]:  # No response was made
        key_resp_blicket13.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_blicket13.corr = 1;  # correct non-response
        else:
           key_resp_blicket13.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicket13.keys',key_resp_blicket13.keys)
    trials_phase_2.addData('key_resp_blicket13.corr', key_resp_blicket13.corr)
    if key_resp_blicket13.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicket13.rt', key_resp_blicket13.rt)
    trials_phase_2.addData('key_resp_blicket13.started', key_resp_blicket13.tStartRefresh)
    trials_phase_2.addData('key_resp_blicket13.stopped', key_resp_blicket13.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('blicket1.started', blicket1.tStartRefresh)
    trials_phase_2.addData('blicket1.stopped', blicket1.tStopRefresh)
    trials_phase_2.addData('blicket_st_w.started', blicket_st_w.tStartRefresh)
    trials_phase_2.addData('blicket_st_w.stopped', blicket_st_w.tStopRefresh)
    trials_phase_2.addData('blicket_st_b.started', blicket_st_b.tStartRefresh)
    trials_phase_2.addData('blicket_st_b.stopped', blicket_st_b.tStopRefresh)
    trials_phase_2.addData('rec_bl_2.started', rec_bl_2.tStartRefresh)
    trials_phase_2.addData('rec_bl_2.stopped', rec_bl_2.tStopRefresh)
    trials_phase_2.addData('option1_critical_3.started', option1_critical_3.tStartRefresh)
    trials_phase_2.addData('option1_critical_3.stopped', option1_critical_3.tStopRefresh)
    trials_phase_2.addData('option2_critical_3.started', option2_critical_3.tStartRefresh)
    trials_phase_2.addData('option2_critical_3.stopped', option2_critical_3.tStopRefresh)
    trials_phase_2.addData('text3.started', text3.tStartRefresh)
    trials_phase_2.addData('text3.stopped', text3.tStopRefresh)
    # the Routine "blicket13" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicket13"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicket13.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicket13.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_5.setText(msg1)
    feedback0_dax9_5.setText(msg0)
    feedback_dax9_5.setText(msg)
    # keep track of which components have finished
    fb_blicket13Components = [feedback1_dax9_5, feedback0_dax9_5, feedback_dax9_5]
    for thisComponent in fb_blicket13Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicket13Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicket13"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicket13Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicket13Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_5* updates
        if feedback1_dax9_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_5.frameNStart = frameN  # exact frame index
            feedback1_dax9_5.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_5, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_5.setAutoDraw(True)
        if feedback1_dax9_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_5.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_5.tStop = t  # not accounting for scr refresh
                feedback1_dax9_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_5, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_5.setAutoDraw(False)
        
        # *feedback0_dax9_5* updates
        if feedback0_dax9_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_5.frameNStart = frameN  # exact frame index
            feedback0_dax9_5.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_5, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_5.setAutoDraw(True)
        if feedback0_dax9_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_5.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_5.tStop = t  # not accounting for scr refresh
                feedback0_dax9_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_5, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_5.setAutoDraw(False)
        
        # *feedback_dax9_5* updates
        if feedback_dax9_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_5.frameNStart = frameN  # exact frame index
            feedback_dax9_5.tStart = t  # local t and not account for scr refresh
            feedback_dax9_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_5, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_5.setAutoDraw(True)
        if feedback_dax9_5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_5.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_5.tStop = t  # not accounting for scr refresh
                feedback_dax9_5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_5, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_5.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicket13Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicket13"-------
    for thisComponent in fb_blicket13Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_5.started', feedback1_dax9_5.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_5.stopped', feedback1_dax9_5.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_5.started', feedback0_dax9_5.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_5.stopped', feedback0_dax9_5.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_5.started', feedback_dax9_5.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_5.stopped', feedback_dax9_5.tStopRefresh)
    
    # ------Prepare to start Routine "blicket14"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blicket14.keys = []
    key_resp_blicket14.rt = []
    _key_resp_blicket14_allKeys = []
    blicket_st_w_2.setFillColor('white')
    blicket_st_b_2.setFillColor('black')
    w_triange.setFillColor('white')
    # keep track of which components have finished
    blicket14Components = [key_resp_blicket14, blicket1_2, blicket_st_w_2, blicket_st_b_2, w_triange, option1_critical_4, option2_critical_4, bltext]
    for thisComponent in blicket14Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicket14Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicket14"-------
    while continueRoutine:
        # get current time
        t = blicket14Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicket14Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_blicket14* updates
        waitOnFlip = False
        if key_resp_blicket14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicket14.frameNStart = frameN  # exact frame index
            key_resp_blicket14.tStart = t  # local t and not account for scr refresh
            key_resp_blicket14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicket14, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicket14.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicket14.clock.reset)  # t=0 on next screen flip
        if key_resp_blicket14.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicket14.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicket14_allKeys.extend(theseKeys)
            if len(_key_resp_blicket14_allKeys):
                key_resp_blicket14.keys = _key_resp_blicket14_allKeys[-1].name  # just the last key pressed
                key_resp_blicket14.rt = _key_resp_blicket14_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicket14.keys == str('2')) or (key_resp_blicket14.keys == '2'):
                    key_resp_blicket14.corr = 1
                else:
                    key_resp_blicket14.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_2* updates
        if blicket1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_2.frameNStart = frameN  # exact frame index
            blicket1_2.tStart = t  # local t and not account for scr refresh
            blicket1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_2, 'tStartRefresh')  # time at next scr refresh
            blicket1_2.setAutoDraw(True)
        
        # *blicket_st_w_2* updates
        if blicket_st_w_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w_2.frameNStart = frameN  # exact frame index
            blicket_st_w_2.tStart = t  # local t and not account for scr refresh
            blicket_st_w_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w_2, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w_2.setAutoDraw(True)
        
        # *blicket_st_b_2* updates
        if blicket_st_b_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b_2.frameNStart = frameN  # exact frame index
            blicket_st_b_2.tStart = t  # local t and not account for scr refresh
            blicket_st_b_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b_2, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b_2.setAutoDraw(True)
        
        # *w_triange* updates
        if w_triange.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            w_triange.frameNStart = frameN  # exact frame index
            w_triange.tStart = t  # local t and not account for scr refresh
            w_triange.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(w_triange, 'tStartRefresh')  # time at next scr refresh
            w_triange.setAutoDraw(True)
        
        # *option1_critical_4* updates
        if option1_critical_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_4.frameNStart = frameN  # exact frame index
            option1_critical_4.tStart = t  # local t and not account for scr refresh
            option1_critical_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_4, 'tStartRefresh')  # time at next scr refresh
            option1_critical_4.setAutoDraw(True)
        
        # *option2_critical_4* updates
        if option2_critical_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_4.frameNStart = frameN  # exact frame index
            option2_critical_4.tStart = t  # local t and not account for scr refresh
            option2_critical_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_4, 'tStartRefresh')  # time at next scr refresh
            option2_critical_4.setAutoDraw(True)
        
        # *bltext* updates
        if bltext.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            bltext.frameNStart = frameN  # exact frame index
            bltext.tStart = t  # local t and not account for scr refresh
            bltext.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(bltext, 'tStartRefresh')  # time at next scr refresh
            bltext.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicket14Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicket14"-------
    for thisComponent in blicket14Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_blicket14.keys in ['', [], None]:  # No response was made
        key_resp_blicket14.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_blicket14.corr = 1;  # correct non-response
        else:
           key_resp_blicket14.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicket14.keys',key_resp_blicket14.keys)
    trials_phase_2.addData('key_resp_blicket14.corr', key_resp_blicket14.corr)
    if key_resp_blicket14.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicket14.rt', key_resp_blicket14.rt)
    trials_phase_2.addData('key_resp_blicket14.started', key_resp_blicket14.tStartRefresh)
    trials_phase_2.addData('key_resp_blicket14.stopped', key_resp_blicket14.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('blicket1_2.started', blicket1_2.tStartRefresh)
    trials_phase_2.addData('blicket1_2.stopped', blicket1_2.tStopRefresh)
    trials_phase_2.addData('blicket_st_w_2.started', blicket_st_w_2.tStartRefresh)
    trials_phase_2.addData('blicket_st_w_2.stopped', blicket_st_w_2.tStopRefresh)
    trials_phase_2.addData('blicket_st_b_2.started', blicket_st_b_2.tStartRefresh)
    trials_phase_2.addData('blicket_st_b_2.stopped', blicket_st_b_2.tStopRefresh)
    trials_phase_2.addData('w_triange.started', w_triange.tStartRefresh)
    trials_phase_2.addData('w_triange.stopped', w_triange.tStopRefresh)
    trials_phase_2.addData('option1_critical_4.started', option1_critical_4.tStartRefresh)
    trials_phase_2.addData('option1_critical_4.stopped', option1_critical_4.tStopRefresh)
    trials_phase_2.addData('option2_critical_4.started', option2_critical_4.tStartRefresh)
    trials_phase_2.addData('option2_critical_4.stopped', option2_critical_4.tStopRefresh)
    trials_phase_2.addData('bltext.started', bltext.tStartRefresh)
    trials_phase_2.addData('bltext.stopped', bltext.tStopRefresh)
    # the Routine "blicket14" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicket14"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicket14.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicket14.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_6.setText(msg1)
    feedback0_dax9_6.setText(msg0)
    feedback_dax9_6.setText(msg)
    # keep track of which components have finished
    fb_blicket14Components = [feedback1_dax9_6, feedback0_dax9_6, feedback_dax9_6]
    for thisComponent in fb_blicket14Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicket14Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicket14"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicket14Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicket14Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_6* updates
        if feedback1_dax9_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_6.frameNStart = frameN  # exact frame index
            feedback1_dax9_6.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_6, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_6.setAutoDraw(True)
        if feedback1_dax9_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_6.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_6.tStop = t  # not accounting for scr refresh
                feedback1_dax9_6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_6, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_6.setAutoDraw(False)
        
        # *feedback0_dax9_6* updates
        if feedback0_dax9_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_6.frameNStart = frameN  # exact frame index
            feedback0_dax9_6.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_6, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_6.setAutoDraw(True)
        if feedback0_dax9_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_6.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_6.tStop = t  # not accounting for scr refresh
                feedback0_dax9_6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_6, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_6.setAutoDraw(False)
        
        # *feedback_dax9_6* updates
        if feedback_dax9_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_6.frameNStart = frameN  # exact frame index
            feedback_dax9_6.tStart = t  # local t and not account for scr refresh
            feedback_dax9_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_6, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_6.setAutoDraw(True)
        if feedback_dax9_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_6.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_6.tStop = t  # not accounting for scr refresh
                feedback_dax9_6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_6, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_6.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicket14Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicket14"-------
    for thisComponent in fb_blicket14Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_6.started', feedback1_dax9_6.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_6.stopped', feedback1_dax9_6.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_6.started', feedback0_dax9_6.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_6.stopped', feedback0_dax9_6.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_6.started', feedback_dax9_6.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_6.stopped', feedback_dax9_6.tStopRefresh)
    
    # ------Prepare to start Routine "blicket15"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blicket15.keys = []
    key_resp_blicket15.rt = []
    _key_resp_blicket15_allKeys = []
    blicket_st_b15.setFillColor('black')
    blicket_st_w15.setFillColor('white')
    # keep track of which components have finished
    blicket15Components = [key_resp_blicket15, blicket1_3, blicket_st_b15, blicket_st_w15, option1_critical_5, option2_critical_5]
    for thisComponent in blicket15Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicket15Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicket15"-------
    while continueRoutine:
        # get current time
        t = blicket15Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicket15Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_blicket15* updates
        waitOnFlip = False
        if key_resp_blicket15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicket15.frameNStart = frameN  # exact frame index
            key_resp_blicket15.tStart = t  # local t and not account for scr refresh
            key_resp_blicket15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicket15, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicket15.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicket15.clock.reset)  # t=0 on next screen flip
        if key_resp_blicket15.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicket15.getKeys(keyList=['1', '2'], waitRelease=False)
            _key_resp_blicket15_allKeys.extend(theseKeys)
            if len(_key_resp_blicket15_allKeys):
                key_resp_blicket15.keys = _key_resp_blicket15_allKeys[-1].name  # just the last key pressed
                key_resp_blicket15.rt = _key_resp_blicket15_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicket15.keys == str('1')) or (key_resp_blicket15.keys == '1'):
                    key_resp_blicket15.corr = 1
                else:
                    key_resp_blicket15.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_3* updates
        if blicket1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_3.frameNStart = frameN  # exact frame index
            blicket1_3.tStart = t  # local t and not account for scr refresh
            blicket1_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_3, 'tStartRefresh')  # time at next scr refresh
            blicket1_3.setAutoDraw(True)
        
        # *blicket_st_b15* updates
        if blicket_st_b15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b15.frameNStart = frameN  # exact frame index
            blicket_st_b15.tStart = t  # local t and not account for scr refresh
            blicket_st_b15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b15, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b15.setAutoDraw(True)
        
        # *blicket_st_w15* updates
        if blicket_st_w15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w15.frameNStart = frameN  # exact frame index
            blicket_st_w15.tStart = t  # local t and not account for scr refresh
            blicket_st_w15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w15, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w15.setAutoDraw(True)
        
        # *option1_critical_5* updates
        if option1_critical_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_5.frameNStart = frameN  # exact frame index
            option1_critical_5.tStart = t  # local t and not account for scr refresh
            option1_critical_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_5, 'tStartRefresh')  # time at next scr refresh
            option1_critical_5.setAutoDraw(True)
        
        # *option2_critical_5* updates
        if option2_critical_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_5.frameNStart = frameN  # exact frame index
            option2_critical_5.tStart = t  # local t and not account for scr refresh
            option2_critical_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_5, 'tStartRefresh')  # time at next scr refresh
            option2_critical_5.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicket15Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicket15"-------
    for thisComponent in blicket15Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_blicket15.keys in ['', [], None]:  # No response was made
        key_resp_blicket15.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_blicket15.corr = 1;  # correct non-response
        else:
           key_resp_blicket15.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicket15.keys',key_resp_blicket15.keys)
    trials_phase_2.addData('key_resp_blicket15.corr', key_resp_blicket15.corr)
    if key_resp_blicket15.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicket15.rt', key_resp_blicket15.rt)
    trials_phase_2.addData('key_resp_blicket15.started', key_resp_blicket15.tStartRefresh)
    trials_phase_2.addData('key_resp_blicket15.stopped', key_resp_blicket15.tStopRefresh)
    trials_phase_2.addData('blicket1_3.started', blicket1_3.tStartRefresh)
    trials_phase_2.addData('blicket1_3.stopped', blicket1_3.tStopRefresh)
    trials_phase_2.addData('blicket_st_b15.started', blicket_st_b15.tStartRefresh)
    trials_phase_2.addData('blicket_st_b15.stopped', blicket_st_b15.tStopRefresh)
    trials_phase_2.addData('blicket_st_w15.started', blicket_st_w15.tStartRefresh)
    trials_phase_2.addData('blicket_st_w15.stopped', blicket_st_w15.tStopRefresh)
    trials_phase_2.addData('option1_critical_5.started', option1_critical_5.tStartRefresh)
    trials_phase_2.addData('option1_critical_5.stopped', option1_critical_5.tStopRefresh)
    trials_phase_2.addData('option2_critical_5.started', option2_critical_5.tStartRefresh)
    trials_phase_2.addData('option2_critical_5.stopped', option2_critical_5.tStopRefresh)
    # the Routine "blicket15" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicket15"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicket15.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicket15.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_7.setText(msg1)
    feedback0_dax9_7.setText(msg0)
    feedback_dax9_7.setText(msg)
    # keep track of which components have finished
    fb_blicket15Components = [feedback1_dax9_7, feedback0_dax9_7, feedback_dax9_7]
    for thisComponent in fb_blicket15Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicket15Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicket15"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicket15Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicket15Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_7* updates
        if feedback1_dax9_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_7.frameNStart = frameN  # exact frame index
            feedback1_dax9_7.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_7, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_7.setAutoDraw(True)
        if feedback1_dax9_7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_7.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_7.tStop = t  # not accounting for scr refresh
                feedback1_dax9_7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_7, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_7.setAutoDraw(False)
        
        # *feedback0_dax9_7* updates
        if feedback0_dax9_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_7.frameNStart = frameN  # exact frame index
            feedback0_dax9_7.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_7, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_7.setAutoDraw(True)
        if feedback0_dax9_7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_7.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_7.tStop = t  # not accounting for scr refresh
                feedback0_dax9_7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_7, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_7.setAutoDraw(False)
        
        # *feedback_dax9_7* updates
        if feedback_dax9_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_7.frameNStart = frameN  # exact frame index
            feedback_dax9_7.tStart = t  # local t and not account for scr refresh
            feedback_dax9_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_7, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_7.setAutoDraw(True)
        if feedback_dax9_7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_7.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_7.tStop = t  # not accounting for scr refresh
                feedback_dax9_7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_7, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_7.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicket15Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicket15"-------
    for thisComponent in fb_blicket15Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_7.started', feedback1_dax9_7.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_7.stopped', feedback1_dax9_7.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_7.started', feedback0_dax9_7.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_7.stopped', feedback0_dax9_7.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_7.started', feedback_dax9_7.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_7.stopped', feedback_dax9_7.tStopRefresh)
    
    # ------Prepare to start Routine "blicket16"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_blicket16.keys = []
    key_resp_blicket16.rt = []
    _key_resp_blicket16_allKeys = []
    blicket_st_b15_2.setFillColor('black')
    blicket_st_w15_2.setFillColor('white')
    # keep track of which components have finished
    blicket16Components = [key_resp_blicket16, blicket1_4, blicket_st_b15_2, blicket_st_w15_2, option1_critical_6, option2_critical_6]
    for thisComponent in blicket16Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicket16Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicket16"-------
    while continueRoutine:
        # get current time
        t = blicket16Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicket16Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_blicket16* updates
        waitOnFlip = False
        if key_resp_blicket16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicket16.frameNStart = frameN  # exact frame index
            key_resp_blicket16.tStart = t  # local t and not account for scr refresh
            key_resp_blicket16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicket16, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicket16.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicket16.clock.reset)  # t=0 on next screen flip
        if key_resp_blicket16.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicket16.getKeys(keyList=['1', '2'], waitRelease=False)
            _key_resp_blicket16_allKeys.extend(theseKeys)
            if len(_key_resp_blicket16_allKeys):
                key_resp_blicket16.keys = _key_resp_blicket16_allKeys[-1].name  # just the last key pressed
                key_resp_blicket16.rt = _key_resp_blicket16_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicket16.keys == str('1')) or (key_resp_blicket16.keys == '1'):
                    key_resp_blicket16.corr = 1
                else:
                    key_resp_blicket16.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_4* updates
        if blicket1_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_4.frameNStart = frameN  # exact frame index
            blicket1_4.tStart = t  # local t and not account for scr refresh
            blicket1_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_4, 'tStartRefresh')  # time at next scr refresh
            blicket1_4.setAutoDraw(True)
        
        # *blicket_st_b15_2* updates
        if blicket_st_b15_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b15_2.frameNStart = frameN  # exact frame index
            blicket_st_b15_2.tStart = t  # local t and not account for scr refresh
            blicket_st_b15_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b15_2, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b15_2.setAutoDraw(True)
        
        # *blicket_st_w15_2* updates
        if blicket_st_w15_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w15_2.frameNStart = frameN  # exact frame index
            blicket_st_w15_2.tStart = t  # local t and not account for scr refresh
            blicket_st_w15_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w15_2, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w15_2.setAutoDraw(True)
        
        # *option1_critical_6* updates
        if option1_critical_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_6.frameNStart = frameN  # exact frame index
            option1_critical_6.tStart = t  # local t and not account for scr refresh
            option1_critical_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_6, 'tStartRefresh')  # time at next scr refresh
            option1_critical_6.setAutoDraw(True)
        
        # *option2_critical_6* updates
        if option2_critical_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_6.frameNStart = frameN  # exact frame index
            option2_critical_6.tStart = t  # local t and not account for scr refresh
            option2_critical_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_6, 'tStartRefresh')  # time at next scr refresh
            option2_critical_6.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicket16Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicket16"-------
    for thisComponent in blicket16Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_blicket16.keys in ['', [], None]:  # No response was made
        key_resp_blicket16.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_blicket16.corr = 1;  # correct non-response
        else:
           key_resp_blicket16.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicket16.keys',key_resp_blicket16.keys)
    trials_phase_2.addData('key_resp_blicket16.corr', key_resp_blicket16.corr)
    if key_resp_blicket16.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicket16.rt', key_resp_blicket16.rt)
    trials_phase_2.addData('key_resp_blicket16.started', key_resp_blicket16.tStartRefresh)
    trials_phase_2.addData('key_resp_blicket16.stopped', key_resp_blicket16.tStopRefresh)
    trials_phase_2.addData('blicket1_4.started', blicket1_4.tStartRefresh)
    trials_phase_2.addData('blicket1_4.stopped', blicket1_4.tStopRefresh)
    trials_phase_2.addData('blicket_st_b15_2.started', blicket_st_b15_2.tStartRefresh)
    trials_phase_2.addData('blicket_st_b15_2.stopped', blicket_st_b15_2.tStopRefresh)
    trials_phase_2.addData('blicket_st_w15_2.started', blicket_st_w15_2.tStartRefresh)
    trials_phase_2.addData('blicket_st_w15_2.stopped', blicket_st_w15_2.tStopRefresh)
    trials_phase_2.addData('option1_critical_6.started', option1_critical_6.tStartRefresh)
    trials_phase_2.addData('option1_critical_6.stopped', option1_critical_6.tStopRefresh)
    trials_phase_2.addData('option2_critical_6.started', option2_critical_6.tStartRefresh)
    trials_phase_2.addData('option2_critical_6.stopped', option2_critical_6.tStopRefresh)
    # the Routine "blicket16" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicket16"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicket16.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicket16.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_8.setText(msg1)
    feedback0_dax9_8.setText(msg0)
    feedback_dax9_8.setText(msg)
    # keep track of which components have finished
    fb_blicket16Components = [feedback1_dax9_8, feedback0_dax9_8, feedback_dax9_8]
    for thisComponent in fb_blicket16Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicket16Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicket16"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicket16Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicket16Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_8* updates
        if feedback1_dax9_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_8.frameNStart = frameN  # exact frame index
            feedback1_dax9_8.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_8, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_8.setAutoDraw(True)
        if feedback1_dax9_8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_8.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_8.tStop = t  # not accounting for scr refresh
                feedback1_dax9_8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_8, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_8.setAutoDraw(False)
        
        # *feedback0_dax9_8* updates
        if feedback0_dax9_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_8.frameNStart = frameN  # exact frame index
            feedback0_dax9_8.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_8, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_8.setAutoDraw(True)
        if feedback0_dax9_8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_8.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_8.tStop = t  # not accounting for scr refresh
                feedback0_dax9_8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_8, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_8.setAutoDraw(False)
        
        # *feedback_dax9_8* updates
        if feedback_dax9_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_8.frameNStart = frameN  # exact frame index
            feedback_dax9_8.tStart = t  # local t and not account for scr refresh
            feedback_dax9_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_8, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_8.setAutoDraw(True)
        if feedback_dax9_8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_8.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_8.tStop = t  # not accounting for scr refresh
                feedback_dax9_8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_8, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_8.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicket16Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicket16"-------
    for thisComponent in fb_blicket16Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_8.started', feedback1_dax9_8.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_8.stopped', feedback1_dax9_8.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_8.started', feedback0_dax9_8.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_8.stopped', feedback0_dax9_8.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_8.started', feedback_dax9_8.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_8.stopped', feedback_dax9_8.tStopRefresh)
    
    # ------Prepare to start Routine "smicket17"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_smicket17.keys = []
    key_resp_smicket17.rt = []
    _key_resp_smicket17_allKeys = []
    blicket_st_w_3.setFillColor('white')
    blicket_st_b_3.setFillColor('black')
    sm.setFillColor('black')
    # keep track of which components have finished
    smicket17Components = [key_resp_smicket17, blicket1_5, blicket_st_w_3, blicket_st_b_3, sm, option1_critical_7, option2_critical_7, smtext]
    for thisComponent in smicket17Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicket17Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicket17"-------
    while continueRoutine:
        # get current time
        t = smicket17Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicket17Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_smicket17* updates
        waitOnFlip = False
        if key_resp_smicket17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicket17.frameNStart = frameN  # exact frame index
            key_resp_smicket17.tStart = t  # local t and not account for scr refresh
            key_resp_smicket17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicket17, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicket17.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicket17.clock.reset)  # t=0 on next screen flip
        if key_resp_smicket17.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicket17.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_smicket17_allKeys.extend(theseKeys)
            if len(_key_resp_smicket17_allKeys):
                key_resp_smicket17.keys = _key_resp_smicket17_allKeys[-1].name  # just the last key pressed
                key_resp_smicket17.rt = _key_resp_smicket17_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicket17.keys == str('1')) or (key_resp_smicket17.keys == '1'):
                    key_resp_smicket17.corr = 1
                else:
                    key_resp_smicket17.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_5* updates
        if blicket1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_5.frameNStart = frameN  # exact frame index
            blicket1_5.tStart = t  # local t and not account for scr refresh
            blicket1_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_5, 'tStartRefresh')  # time at next scr refresh
            blicket1_5.setAutoDraw(True)
        
        # *blicket_st_w_3* updates
        if blicket_st_w_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w_3.frameNStart = frameN  # exact frame index
            blicket_st_w_3.tStart = t  # local t and not account for scr refresh
            blicket_st_w_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w_3, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w_3.setAutoDraw(True)
        
        # *blicket_st_b_3* updates
        if blicket_st_b_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b_3.frameNStart = frameN  # exact frame index
            blicket_st_b_3.tStart = t  # local t and not account for scr refresh
            blicket_st_b_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b_3, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b_3.setAutoDraw(True)
        
        # *sm* updates
        if sm.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            sm.frameNStart = frameN  # exact frame index
            sm.tStart = t  # local t and not account for scr refresh
            sm.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(sm, 'tStartRefresh')  # time at next scr refresh
            sm.setAutoDraw(True)
        
        # *option1_critical_7* updates
        if option1_critical_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_7.frameNStart = frameN  # exact frame index
            option1_critical_7.tStart = t  # local t and not account for scr refresh
            option1_critical_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_7, 'tStartRefresh')  # time at next scr refresh
            option1_critical_7.setAutoDraw(True)
        
        # *option2_critical_7* updates
        if option2_critical_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_7.frameNStart = frameN  # exact frame index
            option2_critical_7.tStart = t  # local t and not account for scr refresh
            option2_critical_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_7, 'tStartRefresh')  # time at next scr refresh
            option2_critical_7.setAutoDraw(True)
        
        # *smtext* updates
        if smtext.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            smtext.frameNStart = frameN  # exact frame index
            smtext.tStart = t  # local t and not account for scr refresh
            smtext.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(smtext, 'tStartRefresh')  # time at next scr refresh
            smtext.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicket17Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicket17"-------
    for thisComponent in smicket17Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_smicket17.keys in ['', [], None]:  # No response was made
        key_resp_smicket17.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_smicket17.corr = 1;  # correct non-response
        else:
           key_resp_smicket17.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicket17.keys',key_resp_smicket17.keys)
    trials_phase_2.addData('key_resp_smicket17.corr', key_resp_smicket17.corr)
    if key_resp_smicket17.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicket17.rt', key_resp_smicket17.rt)
    trials_phase_2.addData('key_resp_smicket17.started', key_resp_smicket17.tStartRefresh)
    trials_phase_2.addData('key_resp_smicket17.stopped', key_resp_smicket17.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('blicket1_5.started', blicket1_5.tStartRefresh)
    trials_phase_2.addData('blicket1_5.stopped', blicket1_5.tStopRefresh)
    trials_phase_2.addData('blicket_st_w_3.started', blicket_st_w_3.tStartRefresh)
    trials_phase_2.addData('blicket_st_w_3.stopped', blicket_st_w_3.tStopRefresh)
    trials_phase_2.addData('blicket_st_b_3.started', blicket_st_b_3.tStartRefresh)
    trials_phase_2.addData('blicket_st_b_3.stopped', blicket_st_b_3.tStopRefresh)
    trials_phase_2.addData('sm.started', sm.tStartRefresh)
    trials_phase_2.addData('sm.stopped', sm.tStopRefresh)
    trials_phase_2.addData('option1_critical_7.started', option1_critical_7.tStartRefresh)
    trials_phase_2.addData('option1_critical_7.stopped', option1_critical_7.tStopRefresh)
    trials_phase_2.addData('option2_critical_7.started', option2_critical_7.tStartRefresh)
    trials_phase_2.addData('option2_critical_7.stopped', option2_critical_7.tStopRefresh)
    trials_phase_2.addData('smtext.started', smtext.tStartRefresh)
    trials_phase_2.addData('smtext.stopped', smtext.tStopRefresh)
    # the Routine "smicket17" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicket17"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicket17.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicket17.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_9.setText(msg1)
    feedback0_dax9_9.setText(msg0)
    feedback_dax9_9.setText(msg)
    # keep track of which components have finished
    fb_smicket17Components = [feedback1_dax9_9, feedback0_dax9_9, feedback_dax9_9]
    for thisComponent in fb_smicket17Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicket17Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicket17"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicket17Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicket17Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_9* updates
        if feedback1_dax9_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_9.frameNStart = frameN  # exact frame index
            feedback1_dax9_9.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_9, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_9.setAutoDraw(True)
        if feedback1_dax9_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_9.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_9.tStop = t  # not accounting for scr refresh
                feedback1_dax9_9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_9, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_9.setAutoDraw(False)
        
        # *feedback0_dax9_9* updates
        if feedback0_dax9_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_9.frameNStart = frameN  # exact frame index
            feedback0_dax9_9.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_9, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_9.setAutoDraw(True)
        if feedback0_dax9_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_9.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_9.tStop = t  # not accounting for scr refresh
                feedback0_dax9_9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_9, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_9.setAutoDraw(False)
        
        # *feedback_dax9_9* updates
        if feedback_dax9_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_9.frameNStart = frameN  # exact frame index
            feedback_dax9_9.tStart = t  # local t and not account for scr refresh
            feedback_dax9_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_9, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_9.setAutoDraw(True)
        if feedback_dax9_9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_9.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_9.tStop = t  # not accounting for scr refresh
                feedback_dax9_9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_9, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_9.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicket17Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicket17"-------
    for thisComponent in fb_smicket17Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_9.started', feedback1_dax9_9.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_9.stopped', feedback1_dax9_9.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_9.started', feedback0_dax9_9.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_9.stopped', feedback0_dax9_9.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_9.started', feedback_dax9_9.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_9.stopped', feedback_dax9_9.tStopRefresh)
    
    # ------Prepare to start Routine "smicket18"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_smicket18.keys = []
    key_resp_smicket18.rt = []
    _key_resp_smicket18_allKeys = []
    blicket_st_w_4.setFillColor('black')
    blicket_st_b_4.setFillColor('white')
    sm2.setFillColor('black')
    # keep track of which components have finished
    smicket18Components = [key_resp_smicket18, blicket1_6, blicket_st_w_4, blicket_st_b_4, sm2, option1_critical_8, option2_critical_8, smtext2]
    for thisComponent in smicket18Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicket18Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicket18"-------
    while continueRoutine:
        # get current time
        t = smicket18Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicket18Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_smicket18* updates
        waitOnFlip = False
        if key_resp_smicket18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicket18.frameNStart = frameN  # exact frame index
            key_resp_smicket18.tStart = t  # local t and not account for scr refresh
            key_resp_smicket18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicket18, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicket18.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicket18.clock.reset)  # t=0 on next screen flip
        if key_resp_smicket18.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicket18.getKeys(keyList=['1', '2'], waitRelease=False)
            _key_resp_smicket18_allKeys.extend(theseKeys)
            if len(_key_resp_smicket18_allKeys):
                key_resp_smicket18.keys = _key_resp_smicket18_allKeys[-1].name  # just the last key pressed
                key_resp_smicket18.rt = _key_resp_smicket18_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicket18.keys == str('2')) or (key_resp_smicket18.keys == '2'):
                    key_resp_smicket18.corr = 1
                else:
                    key_resp_smicket18.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_6* updates
        if blicket1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_6.frameNStart = frameN  # exact frame index
            blicket1_6.tStart = t  # local t and not account for scr refresh
            blicket1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_6, 'tStartRefresh')  # time at next scr refresh
            blicket1_6.setAutoDraw(True)
        
        # *blicket_st_w_4* updates
        if blicket_st_w_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w_4.frameNStart = frameN  # exact frame index
            blicket_st_w_4.tStart = t  # local t and not account for scr refresh
            blicket_st_w_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w_4, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w_4.setAutoDraw(True)
        
        # *blicket_st_b_4* updates
        if blicket_st_b_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b_4.frameNStart = frameN  # exact frame index
            blicket_st_b_4.tStart = t  # local t and not account for scr refresh
            blicket_st_b_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b_4, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b_4.setAutoDraw(True)
        
        # *sm2* updates
        if sm2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            sm2.frameNStart = frameN  # exact frame index
            sm2.tStart = t  # local t and not account for scr refresh
            sm2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(sm2, 'tStartRefresh')  # time at next scr refresh
            sm2.setAutoDraw(True)
        
        # *option1_critical_8* updates
        if option1_critical_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_8.frameNStart = frameN  # exact frame index
            option1_critical_8.tStart = t  # local t and not account for scr refresh
            option1_critical_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_8, 'tStartRefresh')  # time at next scr refresh
            option1_critical_8.setAutoDraw(True)
        
        # *option2_critical_8* updates
        if option2_critical_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_8.frameNStart = frameN  # exact frame index
            option2_critical_8.tStart = t  # local t and not account for scr refresh
            option2_critical_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_8, 'tStartRefresh')  # time at next scr refresh
            option2_critical_8.setAutoDraw(True)
        
        # *smtext2* updates
        if smtext2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            smtext2.frameNStart = frameN  # exact frame index
            smtext2.tStart = t  # local t and not account for scr refresh
            smtext2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(smtext2, 'tStartRefresh')  # time at next scr refresh
            smtext2.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicket18Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicket18"-------
    for thisComponent in smicket18Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_smicket18.keys in ['', [], None]:  # No response was made
        key_resp_smicket18.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_smicket18.corr = 1;  # correct non-response
        else:
           key_resp_smicket18.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicket18.keys',key_resp_smicket18.keys)
    trials_phase_2.addData('key_resp_smicket18.corr', key_resp_smicket18.corr)
    if key_resp_smicket18.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicket18.rt', key_resp_smicket18.rt)
    trials_phase_2.addData('key_resp_smicket18.started', key_resp_smicket18.tStartRefresh)
    trials_phase_2.addData('key_resp_smicket18.stopped', key_resp_smicket18.tStopRefresh)
    
    number_correct = number_correct + 1
    print('number_Correct: ' + str(number_correct))
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase_2.addData('blicket1_6.started', blicket1_6.tStartRefresh)
    trials_phase_2.addData('blicket1_6.stopped', blicket1_6.tStopRefresh)
    trials_phase_2.addData('blicket_st_w_4.started', blicket_st_w_4.tStartRefresh)
    trials_phase_2.addData('blicket_st_w_4.stopped', blicket_st_w_4.tStopRefresh)
    trials_phase_2.addData('blicket_st_b_4.started', blicket_st_b_4.tStartRefresh)
    trials_phase_2.addData('blicket_st_b_4.stopped', blicket_st_b_4.tStopRefresh)
    trials_phase_2.addData('sm2.started', sm2.tStartRefresh)
    trials_phase_2.addData('sm2.stopped', sm2.tStopRefresh)
    trials_phase_2.addData('option1_critical_8.started', option1_critical_8.tStartRefresh)
    trials_phase_2.addData('option1_critical_8.stopped', option1_critical_8.tStopRefresh)
    trials_phase_2.addData('option2_critical_8.started', option2_critical_8.tStartRefresh)
    trials_phase_2.addData('option2_critical_8.stopped', option2_critical_8.tStopRefresh)
    trials_phase_2.addData('smtext2.started', smtext2.tStartRefresh)
    trials_phase_2.addData('smtext2.stopped', smtext2.tStopRefresh)
    # the Routine "smicket18" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicket18"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicket18.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicket18.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_10.setText(msg1)
    feedback0_dax9_10.setText(msg0)
    feedback_dax9_10.setText(msg)
    # keep track of which components have finished
    fb_smicket18Components = [feedback1_dax9_10, feedback0_dax9_10, feedback_dax9_10]
    for thisComponent in fb_smicket18Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicket18Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicket18"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicket18Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicket18Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_10* updates
        if feedback1_dax9_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_10.frameNStart = frameN  # exact frame index
            feedback1_dax9_10.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_10, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_10.setAutoDraw(True)
        if feedback1_dax9_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_10.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_10.tStop = t  # not accounting for scr refresh
                feedback1_dax9_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_10, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_10.setAutoDraw(False)
        
        # *feedback0_dax9_10* updates
        if feedback0_dax9_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_10.frameNStart = frameN  # exact frame index
            feedback0_dax9_10.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_10, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_10.setAutoDraw(True)
        if feedback0_dax9_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_10.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_10.tStop = t  # not accounting for scr refresh
                feedback0_dax9_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_10, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_10.setAutoDraw(False)
        
        # *feedback_dax9_10* updates
        if feedback_dax9_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_10.frameNStart = frameN  # exact frame index
            feedback_dax9_10.tStart = t  # local t and not account for scr refresh
            feedback_dax9_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_10, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_10.setAutoDraw(True)
        if feedback_dax9_10.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_10.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_10.tStop = t  # not accounting for scr refresh
                feedback_dax9_10.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_10, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_10.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicket18Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicket18"-------
    for thisComponent in fb_smicket18Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_10.started', feedback1_dax9_10.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_10.stopped', feedback1_dax9_10.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_10.started', feedback0_dax9_10.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_10.stopped', feedback0_dax9_10.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_10.started', feedback_dax9_10.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_10.stopped', feedback_dax9_10.tStopRefresh)
    
    # ------Prepare to start Routine "smicket19"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_smicket19.keys = []
    key_resp_smicket19.rt = []
    _key_resp_smicket19_allKeys = []
    blicket_st_b15_3.setFillColor('white')
    blicket_st_w15_3.setFillColor('black')
    # keep track of which components have finished
    smicket19Components = [key_resp_smicket19, blicket1_7, blicket_st_b15_3, blicket_st_w15_3, option1_critical_9, option2_critical_9]
    for thisComponent in smicket19Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicket19Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicket19"-------
    while continueRoutine:
        # get current time
        t = smicket19Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicket19Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_smicket19* updates
        waitOnFlip = False
        if key_resp_smicket19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicket19.frameNStart = frameN  # exact frame index
            key_resp_smicket19.tStart = t  # local t and not account for scr refresh
            key_resp_smicket19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicket19, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicket19.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicket19.clock.reset)  # t=0 on next screen flip
        if key_resp_smicket19.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicket19.getKeys(keyList=['1', '2'], waitRelease=False)
            _key_resp_smicket19_allKeys.extend(theseKeys)
            if len(_key_resp_smicket19_allKeys):
                key_resp_smicket19.keys = _key_resp_smicket19_allKeys[-1].name  # just the last key pressed
                key_resp_smicket19.rt = _key_resp_smicket19_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicket19.keys == str('1')) or (key_resp_smicket19.keys == '1'):
                    key_resp_smicket19.corr = 1
                else:
                    key_resp_smicket19.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_7* updates
        if blicket1_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_7.frameNStart = frameN  # exact frame index
            blicket1_7.tStart = t  # local t and not account for scr refresh
            blicket1_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_7, 'tStartRefresh')  # time at next scr refresh
            blicket1_7.setAutoDraw(True)
        
        # *blicket_st_b15_3* updates
        if blicket_st_b15_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b15_3.frameNStart = frameN  # exact frame index
            blicket_st_b15_3.tStart = t  # local t and not account for scr refresh
            blicket_st_b15_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b15_3, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b15_3.setAutoDraw(True)
        
        # *blicket_st_w15_3* updates
        if blicket_st_w15_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w15_3.frameNStart = frameN  # exact frame index
            blicket_st_w15_3.tStart = t  # local t and not account for scr refresh
            blicket_st_w15_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w15_3, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w15_3.setAutoDraw(True)
        
        # *option1_critical_9* updates
        if option1_critical_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_9.frameNStart = frameN  # exact frame index
            option1_critical_9.tStart = t  # local t and not account for scr refresh
            option1_critical_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_9, 'tStartRefresh')  # time at next scr refresh
            option1_critical_9.setAutoDraw(True)
        
        # *option2_critical_9* updates
        if option2_critical_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_9.frameNStart = frameN  # exact frame index
            option2_critical_9.tStart = t  # local t and not account for scr refresh
            option2_critical_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_9, 'tStartRefresh')  # time at next scr refresh
            option2_critical_9.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicket19Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicket19"-------
    for thisComponent in smicket19Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_smicket19.keys in ['', [], None]:  # No response was made
        key_resp_smicket19.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_smicket19.corr = 1;  # correct non-response
        else:
           key_resp_smicket19.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicket19.keys',key_resp_smicket19.keys)
    trials_phase_2.addData('key_resp_smicket19.corr', key_resp_smicket19.corr)
    if key_resp_smicket19.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicket19.rt', key_resp_smicket19.rt)
    trials_phase_2.addData('key_resp_smicket19.started', key_resp_smicket19.tStartRefresh)
    trials_phase_2.addData('key_resp_smicket19.stopped', key_resp_smicket19.tStopRefresh)
    trials_phase_2.addData('blicket1_7.started', blicket1_7.tStartRefresh)
    trials_phase_2.addData('blicket1_7.stopped', blicket1_7.tStopRefresh)
    trials_phase_2.addData('blicket_st_b15_3.started', blicket_st_b15_3.tStartRefresh)
    trials_phase_2.addData('blicket_st_b15_3.stopped', blicket_st_b15_3.tStopRefresh)
    trials_phase_2.addData('blicket_st_w15_3.started', blicket_st_w15_3.tStartRefresh)
    trials_phase_2.addData('blicket_st_w15_3.stopped', blicket_st_w15_3.tStopRefresh)
    trials_phase_2.addData('option1_critical_9.started', option1_critical_9.tStartRefresh)
    trials_phase_2.addData('option1_critical_9.stopped', option1_critical_9.tStopRefresh)
    trials_phase_2.addData('option2_critical_9.started', option2_critical_9.tStartRefresh)
    trials_phase_2.addData('option2_critical_9.stopped', option2_critical_9.tStopRefresh)
    # the Routine "smicket19" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicket19"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicket19.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicket19.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_11.setText(msg1)
    feedback0_dax9_11.setText(msg0)
    feedback_dax9_11.setText(msg)
    # keep track of which components have finished
    fb_smicket19Components = [feedback1_dax9_11, feedback0_dax9_11, feedback_dax9_11]
    for thisComponent in fb_smicket19Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicket19Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicket19"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicket19Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicket19Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_11* updates
        if feedback1_dax9_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_11.frameNStart = frameN  # exact frame index
            feedback1_dax9_11.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_11, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_11.setAutoDraw(True)
        if feedback1_dax9_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_11.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_11.tStop = t  # not accounting for scr refresh
                feedback1_dax9_11.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_11, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_11.setAutoDraw(False)
        
        # *feedback0_dax9_11* updates
        if feedback0_dax9_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_11.frameNStart = frameN  # exact frame index
            feedback0_dax9_11.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_11, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_11.setAutoDraw(True)
        if feedback0_dax9_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_11.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_11.tStop = t  # not accounting for scr refresh
                feedback0_dax9_11.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_11, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_11.setAutoDraw(False)
        
        # *feedback_dax9_11* updates
        if feedback_dax9_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_11.frameNStart = frameN  # exact frame index
            feedback_dax9_11.tStart = t  # local t and not account for scr refresh
            feedback_dax9_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_11, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_11.setAutoDraw(True)
        if feedback_dax9_11.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_11.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_11.tStop = t  # not accounting for scr refresh
                feedback_dax9_11.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_11, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_11.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicket19Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicket19"-------
    for thisComponent in fb_smicket19Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_11.started', feedback1_dax9_11.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_11.stopped', feedback1_dax9_11.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_11.started', feedback0_dax9_11.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_11.stopped', feedback0_dax9_11.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_11.started', feedback_dax9_11.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_11.stopped', feedback_dax9_11.tStopRefresh)
    
    # ------Prepare to start Routine "smicket20"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_smicket20.keys = []
    key_resp_smicket20.rt = []
    _key_resp_smicket20_allKeys = []
    blicket_st_b20.setFillColor('black')
    blicket_st_w15_4.setFillColor('white')
    # keep track of which components have finished
    smicket20Components = [key_resp_smicket20, blicket1_8, blicket_st_b20, blicket_st_w15_4, option1_critical_10, option2_critical_10]
    for thisComponent in smicket20Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicket20Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicket20"-------
    while continueRoutine:
        # get current time
        t = smicket20Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicket20Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *key_resp_smicket20* updates
        waitOnFlip = False
        if key_resp_smicket20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicket20.frameNStart = frameN  # exact frame index
            key_resp_smicket20.tStart = t  # local t and not account for scr refresh
            key_resp_smicket20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicket20, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicket20.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicket20.clock.reset)  # t=0 on next screen flip
        if key_resp_smicket20.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicket20.getKeys(keyList=['1', '2'], waitRelease=False)
            _key_resp_smicket20_allKeys.extend(theseKeys)
            if len(_key_resp_smicket20_allKeys):
                key_resp_smicket20.keys = _key_resp_smicket20_allKeys[-1].name  # just the last key pressed
                key_resp_smicket20.rt = _key_resp_smicket20_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicket20.keys == str('2')) or (key_resp_smicket20.keys == '2'):
                    key_resp_smicket20.corr = 1
                else:
                    key_resp_smicket20.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *blicket1_8* updates
        if blicket1_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket1_8.frameNStart = frameN  # exact frame index
            blicket1_8.tStart = t  # local t and not account for scr refresh
            blicket1_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket1_8, 'tStartRefresh')  # time at next scr refresh
            blicket1_8.setAutoDraw(True)
        
        # *blicket_st_b20* updates
        if blicket_st_b20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_b20.frameNStart = frameN  # exact frame index
            blicket_st_b20.tStart = t  # local t and not account for scr refresh
            blicket_st_b20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_b20, 'tStartRefresh')  # time at next scr refresh
            blicket_st_b20.setAutoDraw(True)
        
        # *blicket_st_w15_4* updates
        if blicket_st_w15_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blicket_st_w15_4.frameNStart = frameN  # exact frame index
            blicket_st_w15_4.tStart = t  # local t and not account for scr refresh
            blicket_st_w15_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blicket_st_w15_4, 'tStartRefresh')  # time at next scr refresh
            blicket_st_w15_4.setAutoDraw(True)
        
        # *option1_critical_10* updates
        if option1_critical_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_critical_10.frameNStart = frameN  # exact frame index
            option1_critical_10.tStart = t  # local t and not account for scr refresh
            option1_critical_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_critical_10, 'tStartRefresh')  # time at next scr refresh
            option1_critical_10.setAutoDraw(True)
        
        # *option2_critical_10* updates
        if option2_critical_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_critical_10.frameNStart = frameN  # exact frame index
            option2_critical_10.tStart = t  # local t and not account for scr refresh
            option2_critical_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_critical_10, 'tStartRefresh')  # time at next scr refresh
            option2_critical_10.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicket20Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicket20"-------
    for thisComponent in smicket20Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # check responses
    if key_resp_smicket20.keys in ['', [], None]:  # No response was made
        key_resp_smicket20.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_smicket20.corr = 1;  # correct non-response
        else:
           key_resp_smicket20.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicket20.keys',key_resp_smicket20.keys)
    trials_phase_2.addData('key_resp_smicket20.corr', key_resp_smicket20.corr)
    if key_resp_smicket20.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicket20.rt', key_resp_smicket20.rt)
    trials_phase_2.addData('key_resp_smicket20.started', key_resp_smicket20.tStartRefresh)
    trials_phase_2.addData('key_resp_smicket20.stopped', key_resp_smicket20.tStopRefresh)
    trials_phase_2.addData('blicket1_8.started', blicket1_8.tStartRefresh)
    trials_phase_2.addData('blicket1_8.stopped', blicket1_8.tStopRefresh)
    trials_phase_2.addData('blicket_st_b20.started', blicket_st_b20.tStartRefresh)
    trials_phase_2.addData('blicket_st_b20.stopped', blicket_st_b20.tStopRefresh)
    trials_phase_2.addData('blicket_st_w15_4.started', blicket_st_w15_4.tStartRefresh)
    trials_phase_2.addData('blicket_st_w15_4.stopped', blicket_st_w15_4.tStopRefresh)
    trials_phase_2.addData('option1_critical_10.started', option1_critical_10.tStartRefresh)
    trials_phase_2.addData('option1_critical_10.stopped', option1_critical_10.tStopRefresh)
    trials_phase_2.addData('option2_critical_10.started', option2_critical_10.tStartRefresh)
    trials_phase_2.addData('option2_critical_10.stopped', option2_critical_10.tStopRefresh)
    # the Routine "smicket20" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicket20"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicket20.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicket20.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_12.setText(msg1)
    feedback0_dax9_12.setText(msg0)
    feedback_dax9_12.setText(msg)
    # keep track of which components have finished
    fb_smicket20Components = [feedback1_dax9_12, feedback0_dax9_12, feedback_dax9_12]
    for thisComponent in fb_smicket20Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicket20Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicket20"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicket20Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicket20Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_12* updates
        if feedback1_dax9_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_12.frameNStart = frameN  # exact frame index
            feedback1_dax9_12.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_12, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_12.setAutoDraw(True)
        if feedback1_dax9_12.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_12.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_12.tStop = t  # not accounting for scr refresh
                feedback1_dax9_12.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_12, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_12.setAutoDraw(False)
        
        # *feedback0_dax9_12* updates
        if feedback0_dax9_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_12.frameNStart = frameN  # exact frame index
            feedback0_dax9_12.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_12, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_12.setAutoDraw(True)
        if feedback0_dax9_12.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_12.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_12.tStop = t  # not accounting for scr refresh
                feedback0_dax9_12.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_12, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_12.setAutoDraw(False)
        
        # *feedback_dax9_12* updates
        if feedback_dax9_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_12.frameNStart = frameN  # exact frame index
            feedback_dax9_12.tStart = t  # local t and not account for scr refresh
            feedback_dax9_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_12, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_12.setAutoDraw(True)
        if feedback_dax9_12.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_12.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_12.tStop = t  # not accounting for scr refresh
                feedback_dax9_12.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_12, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_12.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicket20Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicket20"-------
    for thisComponent in fb_smicket20Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_12.started', feedback1_dax9_12.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_12.stopped', feedback1_dax9_12.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_12.started', feedback0_dax9_12.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_12.stopped', feedback0_dax9_12.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_12.started', feedback_dax9_12.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_12.stopped', feedback_dax9_12.tStopRefresh)
    
    # ------Prepare to start Routine "blicketfep21"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_13.setFillColor('black')
    triange.setFillColor('black')
    cross_12.setFillColor('black')
    key_resp_blicketfep21.keys = []
    key_resp_blicketfep21.rt = []
    _key_resp_blicketfep21_allKeys = []
    # keep track of which components have finished
    blicketfep21Components = [dax9_corr2_2, star_13, triange, cross_12, key_resp_blicketfep21, option1_2, option2_2, option3_2]
    for thisComponent in blicketfep21Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicketfep21Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicketfep21"-------
    while continueRoutine:
        # get current time
        t = blicketfep21Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicketfep21Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_2* updates
        if dax9_corr2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_2.frameNStart = frameN  # exact frame index
            dax9_corr2_2.tStart = t  # local t and not account for scr refresh
            dax9_corr2_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_2, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_2.setAutoDraw(True)
        
        # *star_13* updates
        if star_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_13.frameNStart = frameN  # exact frame index
            star_13.tStart = t  # local t and not account for scr refresh
            star_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_13, 'tStartRefresh')  # time at next scr refresh
            star_13.setAutoDraw(True)
        
        # *triange* updates
        if triange.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange.frameNStart = frameN  # exact frame index
            triange.tStart = t  # local t and not account for scr refresh
            triange.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange, 'tStartRefresh')  # time at next scr refresh
            triange.setAutoDraw(True)
        
        # *cross_12* updates
        if cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_12.frameNStart = frameN  # exact frame index
            cross_12.tStart = t  # local t and not account for scr refresh
            cross_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_12, 'tStartRefresh')  # time at next scr refresh
            cross_12.setAutoDraw(True)
        
        # *key_resp_blicketfep21* updates
        waitOnFlip = False
        if key_resp_blicketfep21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicketfep21.frameNStart = frameN  # exact frame index
            key_resp_blicketfep21.tStart = t  # local t and not account for scr refresh
            key_resp_blicketfep21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicketfep21, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicketfep21.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicketfep21.clock.reset)  # t=0 on next screen flip
        if key_resp_blicketfep21.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicketfep21.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicketfep21_allKeys.extend(theseKeys)
            if len(_key_resp_blicketfep21_allKeys):
                key_resp_blicketfep21.keys = _key_resp_blicketfep21_allKeys[-1].name  # just the last key pressed
                key_resp_blicketfep21.rt = _key_resp_blicketfep21_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicketfep21.keys == str('3')) or (key_resp_blicketfep21.keys == '3'):
                    key_resp_blicketfep21.corr = 1
                else:
                    key_resp_blicketfep21.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_2* updates
        if option1_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_2.frameNStart = frameN  # exact frame index
            option1_2.tStart = t  # local t and not account for scr refresh
            option1_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_2, 'tStartRefresh')  # time at next scr refresh
            option1_2.setAutoDraw(True)
        
        # *option2_2* updates
        if option2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_2.frameNStart = frameN  # exact frame index
            option2_2.tStart = t  # local t and not account for scr refresh
            option2_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_2, 'tStartRefresh')  # time at next scr refresh
            option2_2.setAutoDraw(True)
        
        # *option3_2* updates
        if option3_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_2.frameNStart = frameN  # exact frame index
            option3_2.tStart = t  # local t and not account for scr refresh
            option3_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_2, 'tStartRefresh')  # time at next scr refresh
            option3_2.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicketfep21Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicketfep21"-------
    for thisComponent in blicketfep21Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_2.started', dax9_corr2_2.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_2.stopped', dax9_corr2_2.tStopRefresh)
    trials_phase_2.addData('star_13.started', star_13.tStartRefresh)
    trials_phase_2.addData('star_13.stopped', star_13.tStopRefresh)
    trials_phase_2.addData('triange.started', triange.tStartRefresh)
    trials_phase_2.addData('triange.stopped', triange.tStopRefresh)
    trials_phase_2.addData('cross_12.started', cross_12.tStartRefresh)
    trials_phase_2.addData('cross_12.stopped', cross_12.tStopRefresh)
    # check responses
    if key_resp_blicketfep21.keys in ['', [], None]:  # No response was made
        key_resp_blicketfep21.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_blicketfep21.corr = 1;  # correct non-response
        else:
           key_resp_blicketfep21.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicketfep21.keys',key_resp_blicketfep21.keys)
    trials_phase_2.addData('key_resp_blicketfep21.corr', key_resp_blicketfep21.corr)
    if key_resp_blicketfep21.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicketfep21.rt', key_resp_blicketfep21.rt)
    trials_phase_2.addData('key_resp_blicketfep21.started', key_resp_blicketfep21.tStartRefresh)
    trials_phase_2.addData('key_resp_blicketfep21.stopped', key_resp_blicketfep21.tStopRefresh)
    trials_phase_2.addData('option1_2.started', option1_2.tStartRefresh)
    trials_phase_2.addData('option1_2.stopped', option1_2.tStopRefresh)
    trials_phase_2.addData('option2_2.started', option2_2.tStartRefresh)
    trials_phase_2.addData('option2_2.stopped', option2_2.tStopRefresh)
    trials_phase_2.addData('option3_2.started', option3_2.tStartRefresh)
    trials_phase_2.addData('option3_2.stopped', option3_2.tStopRefresh)
    # the Routine "blicketfep21" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicketfep21"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicketfep21.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicketfep21.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_13.setText(msg1)
    feedback0_dax9_13.setText(msg0)
    feedback_dax9_13.setText(msg)
    # keep track of which components have finished
    fb_blicketfep21Components = [feedback1_dax9_13, feedback0_dax9_13, feedback_dax9_13]
    for thisComponent in fb_blicketfep21Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicketfep21Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicketfep21"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicketfep21Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicketfep21Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_13* updates
        if feedback1_dax9_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_13.frameNStart = frameN  # exact frame index
            feedback1_dax9_13.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_13, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_13.setAutoDraw(True)
        if feedback1_dax9_13.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_13.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_13.tStop = t  # not accounting for scr refresh
                feedback1_dax9_13.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_13, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_13.setAutoDraw(False)
        
        # *feedback0_dax9_13* updates
        if feedback0_dax9_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_13.frameNStart = frameN  # exact frame index
            feedback0_dax9_13.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_13, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_13.setAutoDraw(True)
        if feedback0_dax9_13.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_13.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_13.tStop = t  # not accounting for scr refresh
                feedback0_dax9_13.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_13, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_13.setAutoDraw(False)
        
        # *feedback_dax9_13* updates
        if feedback_dax9_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_13.frameNStart = frameN  # exact frame index
            feedback_dax9_13.tStart = t  # local t and not account for scr refresh
            feedback_dax9_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_13, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_13.setAutoDraw(True)
        if feedback_dax9_13.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_13.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_13.tStop = t  # not accounting for scr refresh
                feedback_dax9_13.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_13, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_13.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicketfep21Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicketfep21"-------
    for thisComponent in fb_blicketfep21Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_13.started', feedback1_dax9_13.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_13.stopped', feedback1_dax9_13.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_13.started', feedback0_dax9_13.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_13.stopped', feedback0_dax9_13.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_13.started', feedback_dax9_13.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_13.stopped', feedback_dax9_13.tStopRefresh)
    
    # ------Prepare to start Routine "blicketfep22"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_14.setFillColor('black')
    triange_2.setFillColor('black')
    cross_13.setFillColor('black')
    key_resp_blicketfep22.keys = []
    key_resp_blicketfep22.rt = []
    _key_resp_blicketfep22_allKeys = []
    # keep track of which components have finished
    blicketfep22Components = [dax9_corr2_3, star_14, triange_2, cross_13, key_resp_blicketfep22, option1_3, option2_3, option3_3]
    for thisComponent in blicketfep22Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicketfep22Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicketfep22"-------
    while continueRoutine:
        # get current time
        t = blicketfep22Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicketfep22Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_3* updates
        if dax9_corr2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_3.frameNStart = frameN  # exact frame index
            dax9_corr2_3.tStart = t  # local t and not account for scr refresh
            dax9_corr2_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_3, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_3.setAutoDraw(True)
        
        # *star_14* updates
        if star_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_14.frameNStart = frameN  # exact frame index
            star_14.tStart = t  # local t and not account for scr refresh
            star_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_14, 'tStartRefresh')  # time at next scr refresh
            star_14.setAutoDraw(True)
        
        # *triange_2* updates
        if triange_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_2.frameNStart = frameN  # exact frame index
            triange_2.tStart = t  # local t and not account for scr refresh
            triange_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_2, 'tStartRefresh')  # time at next scr refresh
            triange_2.setAutoDraw(True)
        
        # *cross_13* updates
        if cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_13.frameNStart = frameN  # exact frame index
            cross_13.tStart = t  # local t and not account for scr refresh
            cross_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_13, 'tStartRefresh')  # time at next scr refresh
            cross_13.setAutoDraw(True)
        
        # *key_resp_blicketfep22* updates
        waitOnFlip = False
        if key_resp_blicketfep22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicketfep22.frameNStart = frameN  # exact frame index
            key_resp_blicketfep22.tStart = t  # local t and not account for scr refresh
            key_resp_blicketfep22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicketfep22, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicketfep22.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicketfep22.clock.reset)  # t=0 on next screen flip
        if key_resp_blicketfep22.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicketfep22.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicketfep22_allKeys.extend(theseKeys)
            if len(_key_resp_blicketfep22_allKeys):
                key_resp_blicketfep22.keys = _key_resp_blicketfep22_allKeys[-1].name  # just the last key pressed
                key_resp_blicketfep22.rt = _key_resp_blicketfep22_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicketfep22.keys == str('2')) or (key_resp_blicketfep22.keys == '2'):
                    key_resp_blicketfep22.corr = 1
                else:
                    key_resp_blicketfep22.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_3* updates
        if option1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_3.frameNStart = frameN  # exact frame index
            option1_3.tStart = t  # local t and not account for scr refresh
            option1_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_3, 'tStartRefresh')  # time at next scr refresh
            option1_3.setAutoDraw(True)
        
        # *option2_3* updates
        if option2_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_3.frameNStart = frameN  # exact frame index
            option2_3.tStart = t  # local t and not account for scr refresh
            option2_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_3, 'tStartRefresh')  # time at next scr refresh
            option2_3.setAutoDraw(True)
        
        # *option3_3* updates
        if option3_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_3.frameNStart = frameN  # exact frame index
            option3_3.tStart = t  # local t and not account for scr refresh
            option3_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_3, 'tStartRefresh')  # time at next scr refresh
            option3_3.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicketfep22Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicketfep22"-------
    for thisComponent in blicketfep22Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_3.started', dax9_corr2_3.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_3.stopped', dax9_corr2_3.tStopRefresh)
    trials_phase_2.addData('star_14.started', star_14.tStartRefresh)
    trials_phase_2.addData('star_14.stopped', star_14.tStopRefresh)
    trials_phase_2.addData('triange_2.started', triange_2.tStartRefresh)
    trials_phase_2.addData('triange_2.stopped', triange_2.tStopRefresh)
    trials_phase_2.addData('cross_13.started', cross_13.tStartRefresh)
    trials_phase_2.addData('cross_13.stopped', cross_13.tStopRefresh)
    # check responses
    if key_resp_blicketfep22.keys in ['', [], None]:  # No response was made
        key_resp_blicketfep22.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_blicketfep22.corr = 1;  # correct non-response
        else:
           key_resp_blicketfep22.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicketfep22.keys',key_resp_blicketfep22.keys)
    trials_phase_2.addData('key_resp_blicketfep22.corr', key_resp_blicketfep22.corr)
    if key_resp_blicketfep22.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicketfep22.rt', key_resp_blicketfep22.rt)
    trials_phase_2.addData('key_resp_blicketfep22.started', key_resp_blicketfep22.tStartRefresh)
    trials_phase_2.addData('key_resp_blicketfep22.stopped', key_resp_blicketfep22.tStopRefresh)
    trials_phase_2.addData('option1_3.started', option1_3.tStartRefresh)
    trials_phase_2.addData('option1_3.stopped', option1_3.tStopRefresh)
    trials_phase_2.addData('option2_3.started', option2_3.tStartRefresh)
    trials_phase_2.addData('option2_3.stopped', option2_3.tStopRefresh)
    trials_phase_2.addData('option3_3.started', option3_3.tStartRefresh)
    trials_phase_2.addData('option3_3.stopped', option3_3.tStopRefresh)
    # the Routine "blicketfep22" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicketfep22"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicketfep22.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicketfep22.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_14.setText(msg1)
    feedback0_dax9_14.setText(msg0)
    feedback_dax9_14.setText(msg)
    # keep track of which components have finished
    fb_blicketfep22Components = [feedback1_dax9_14, feedback0_dax9_14, feedback_dax9_14]
    for thisComponent in fb_blicketfep22Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicketfep22Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicketfep22"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicketfep22Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicketfep22Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_14* updates
        if feedback1_dax9_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_14.frameNStart = frameN  # exact frame index
            feedback1_dax9_14.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_14, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_14.setAutoDraw(True)
        if feedback1_dax9_14.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_14.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_14.tStop = t  # not accounting for scr refresh
                feedback1_dax9_14.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_14, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_14.setAutoDraw(False)
        
        # *feedback0_dax9_14* updates
        if feedback0_dax9_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_14.frameNStart = frameN  # exact frame index
            feedback0_dax9_14.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_14, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_14.setAutoDraw(True)
        if feedback0_dax9_14.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_14.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_14.tStop = t  # not accounting for scr refresh
                feedback0_dax9_14.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_14, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_14.setAutoDraw(False)
        
        # *feedback_dax9_14* updates
        if feedback_dax9_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_14.frameNStart = frameN  # exact frame index
            feedback_dax9_14.tStart = t  # local t and not account for scr refresh
            feedback_dax9_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_14, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_14.setAutoDraw(True)
        if feedback_dax9_14.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_14.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_14.tStop = t  # not accounting for scr refresh
                feedback_dax9_14.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_14, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_14.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicketfep22Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicketfep22"-------
    for thisComponent in fb_blicketfep22Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_14.started', feedback1_dax9_14.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_14.stopped', feedback1_dax9_14.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_14.started', feedback0_dax9_14.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_14.stopped', feedback0_dax9_14.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_14.started', feedback_dax9_14.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_14.stopped', feedback_dax9_14.tStopRefresh)
    
    # ------Prepare to start Routine "blicketfep23"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_15.setFillColor('black')
    triange_3.setFillColor('black')
    cross_14.setFillColor('black')
    key_resp_blicketfep23.keys = []
    key_resp_blicketfep23.rt = []
    _key_resp_blicketfep23_allKeys = []
    # keep track of which components have finished
    blicketfep23Components = [dax9_corr2_4, star_15, triange_3, cross_14, key_resp_blicketfep23, option1_4, option2_4, option3_4]
    for thisComponent in blicketfep23Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicketfep23Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicketfep23"-------
    while continueRoutine:
        # get current time
        t = blicketfep23Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicketfep23Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_4* updates
        if dax9_corr2_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_4.frameNStart = frameN  # exact frame index
            dax9_corr2_4.tStart = t  # local t and not account for scr refresh
            dax9_corr2_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_4, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_4.setAutoDraw(True)
        
        # *star_15* updates
        if star_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_15.frameNStart = frameN  # exact frame index
            star_15.tStart = t  # local t and not account for scr refresh
            star_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_15, 'tStartRefresh')  # time at next scr refresh
            star_15.setAutoDraw(True)
        
        # *triange_3* updates
        if triange_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_3.frameNStart = frameN  # exact frame index
            triange_3.tStart = t  # local t and not account for scr refresh
            triange_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_3, 'tStartRefresh')  # time at next scr refresh
            triange_3.setAutoDraw(True)
        
        # *cross_14* updates
        if cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_14.frameNStart = frameN  # exact frame index
            cross_14.tStart = t  # local t and not account for scr refresh
            cross_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_14, 'tStartRefresh')  # time at next scr refresh
            cross_14.setAutoDraw(True)
        
        # *key_resp_blicketfep23* updates
        waitOnFlip = False
        if key_resp_blicketfep23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicketfep23.frameNStart = frameN  # exact frame index
            key_resp_blicketfep23.tStart = t  # local t and not account for scr refresh
            key_resp_blicketfep23.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicketfep23, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicketfep23.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicketfep23.clock.reset)  # t=0 on next screen flip
        if key_resp_blicketfep23.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicketfep23.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicketfep23_allKeys.extend(theseKeys)
            if len(_key_resp_blicketfep23_allKeys):
                key_resp_blicketfep23.keys = _key_resp_blicketfep23_allKeys[-1].name  # just the last key pressed
                key_resp_blicketfep23.rt = _key_resp_blicketfep23_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicketfep23.keys == str('2')) or (key_resp_blicketfep23.keys == '2'):
                    key_resp_blicketfep23.corr = 1
                else:
                    key_resp_blicketfep23.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_4* updates
        if option1_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_4.frameNStart = frameN  # exact frame index
            option1_4.tStart = t  # local t and not account for scr refresh
            option1_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_4, 'tStartRefresh')  # time at next scr refresh
            option1_4.setAutoDraw(True)
        
        # *option2_4* updates
        if option2_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_4.frameNStart = frameN  # exact frame index
            option2_4.tStart = t  # local t and not account for scr refresh
            option2_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_4, 'tStartRefresh')  # time at next scr refresh
            option2_4.setAutoDraw(True)
        
        # *option3_4* updates
        if option3_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_4.frameNStart = frameN  # exact frame index
            option3_4.tStart = t  # local t and not account for scr refresh
            option3_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_4, 'tStartRefresh')  # time at next scr refresh
            option3_4.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicketfep23Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicketfep23"-------
    for thisComponent in blicketfep23Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_4.started', dax9_corr2_4.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_4.stopped', dax9_corr2_4.tStopRefresh)
    trials_phase_2.addData('star_15.started', star_15.tStartRefresh)
    trials_phase_2.addData('star_15.stopped', star_15.tStopRefresh)
    trials_phase_2.addData('triange_3.started', triange_3.tStartRefresh)
    trials_phase_2.addData('triange_3.stopped', triange_3.tStopRefresh)
    trials_phase_2.addData('cross_14.started', cross_14.tStartRefresh)
    trials_phase_2.addData('cross_14.stopped', cross_14.tStopRefresh)
    # check responses
    if key_resp_blicketfep23.keys in ['', [], None]:  # No response was made
        key_resp_blicketfep23.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_blicketfep23.corr = 1;  # correct non-response
        else:
           key_resp_blicketfep23.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicketfep23.keys',key_resp_blicketfep23.keys)
    trials_phase_2.addData('key_resp_blicketfep23.corr', key_resp_blicketfep23.corr)
    if key_resp_blicketfep23.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicketfep23.rt', key_resp_blicketfep23.rt)
    trials_phase_2.addData('key_resp_blicketfep23.started', key_resp_blicketfep23.tStartRefresh)
    trials_phase_2.addData('key_resp_blicketfep23.stopped', key_resp_blicketfep23.tStopRefresh)
    trials_phase_2.addData('option1_4.started', option1_4.tStartRefresh)
    trials_phase_2.addData('option1_4.stopped', option1_4.tStopRefresh)
    trials_phase_2.addData('option2_4.started', option2_4.tStartRefresh)
    trials_phase_2.addData('option2_4.stopped', option2_4.tStopRefresh)
    trials_phase_2.addData('option3_4.started', option3_4.tStartRefresh)
    trials_phase_2.addData('option3_4.stopped', option3_4.tStopRefresh)
    # the Routine "blicketfep23" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicketfep23"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicketfep23.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicketfep23.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_15.setText(msg1)
    feedback0_dax9_15.setText(msg0)
    feedback_dax9_15.setText(msg)
    # keep track of which components have finished
    fb_blicketfep23Components = [feedback1_dax9_15, feedback0_dax9_15, feedback_dax9_15]
    for thisComponent in fb_blicketfep23Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicketfep23Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicketfep23"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicketfep23Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicketfep23Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_15* updates
        if feedback1_dax9_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_15.frameNStart = frameN  # exact frame index
            feedback1_dax9_15.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_15, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_15.setAutoDraw(True)
        if feedback1_dax9_15.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_15.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_15.tStop = t  # not accounting for scr refresh
                feedback1_dax9_15.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_15, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_15.setAutoDraw(False)
        
        # *feedback0_dax9_15* updates
        if feedback0_dax9_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_15.frameNStart = frameN  # exact frame index
            feedback0_dax9_15.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_15, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_15.setAutoDraw(True)
        if feedback0_dax9_15.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_15.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_15.tStop = t  # not accounting for scr refresh
                feedback0_dax9_15.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_15, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_15.setAutoDraw(False)
        
        # *feedback_dax9_15* updates
        if feedback_dax9_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_15.frameNStart = frameN  # exact frame index
            feedback_dax9_15.tStart = t  # local t and not account for scr refresh
            feedback_dax9_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_15, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_15.setAutoDraw(True)
        if feedback_dax9_15.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_15.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_15.tStop = t  # not accounting for scr refresh
                feedback_dax9_15.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_15, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_15.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicketfep23Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicketfep23"-------
    for thisComponent in fb_blicketfep23Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_15.started', feedback1_dax9_15.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_15.stopped', feedback1_dax9_15.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_15.started', feedback0_dax9_15.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_15.stopped', feedback0_dax9_15.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_15.started', feedback_dax9_15.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_15.stopped', feedback_dax9_15.tStopRefresh)
    
    # ------Prepare to start Routine "blicketfep24"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_16.setFillColor('black')
    triange_4.setFillColor('black')
    cross_15.setFillColor('black')
    key_resp_blicketfep24.keys = []
    key_resp_blicketfep24.rt = []
    _key_resp_blicketfep24_allKeys = []
    # keep track of which components have finished
    blicketfep24Components = [dax9_corr2_5, star_16, triange_4, cross_15, key_resp_blicketfep24, option1_5, option2_5, option3_5]
    for thisComponent in blicketfep24Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    blicketfep24Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "blicketfep24"-------
    while continueRoutine:
        # get current time
        t = blicketfep24Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=blicketfep24Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_5* updates
        if dax9_corr2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_5.frameNStart = frameN  # exact frame index
            dax9_corr2_5.tStart = t  # local t and not account for scr refresh
            dax9_corr2_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_5, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_5.setAutoDraw(True)
        
        # *star_16* updates
        if star_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_16.frameNStart = frameN  # exact frame index
            star_16.tStart = t  # local t and not account for scr refresh
            star_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_16, 'tStartRefresh')  # time at next scr refresh
            star_16.setAutoDraw(True)
        
        # *triange_4* updates
        if triange_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_4.frameNStart = frameN  # exact frame index
            triange_4.tStart = t  # local t and not account for scr refresh
            triange_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_4, 'tStartRefresh')  # time at next scr refresh
            triange_4.setAutoDraw(True)
        
        # *cross_15* updates
        if cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_15.frameNStart = frameN  # exact frame index
            cross_15.tStart = t  # local t and not account for scr refresh
            cross_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_15, 'tStartRefresh')  # time at next scr refresh
            cross_15.setAutoDraw(True)
        
        # *key_resp_blicketfep24* updates
        waitOnFlip = False
        if key_resp_blicketfep24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_blicketfep24.frameNStart = frameN  # exact frame index
            key_resp_blicketfep24.tStart = t  # local t and not account for scr refresh
            key_resp_blicketfep24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_blicketfep24, 'tStartRefresh')  # time at next scr refresh
            key_resp_blicketfep24.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_blicketfep24.clock.reset)  # t=0 on next screen flip
        if key_resp_blicketfep24.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_blicketfep24.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_blicketfep24_allKeys.extend(theseKeys)
            if len(_key_resp_blicketfep24_allKeys):
                key_resp_blicketfep24.keys = _key_resp_blicketfep24_allKeys[-1].name  # just the last key pressed
                key_resp_blicketfep24.rt = _key_resp_blicketfep24_allKeys[-1].rt
                # was this correct?
                if (key_resp_blicketfep24.keys == str('2')) or (key_resp_blicketfep24.keys == '2'):
                    key_resp_blicketfep24.corr = 1
                else:
                    key_resp_blicketfep24.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_5* updates
        if option1_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_5.frameNStart = frameN  # exact frame index
            option1_5.tStart = t  # local t and not account for scr refresh
            option1_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_5, 'tStartRefresh')  # time at next scr refresh
            option1_5.setAutoDraw(True)
        
        # *option2_5* updates
        if option2_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_5.frameNStart = frameN  # exact frame index
            option2_5.tStart = t  # local t and not account for scr refresh
            option2_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_5, 'tStartRefresh')  # time at next scr refresh
            option2_5.setAutoDraw(True)
        
        # *option3_5* updates
        if option3_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_5.frameNStart = frameN  # exact frame index
            option3_5.tStart = t  # local t and not account for scr refresh
            option3_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_5, 'tStartRefresh')  # time at next scr refresh
            option3_5.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in blicketfep24Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "blicketfep24"-------
    for thisComponent in blicketfep24Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_5.started', dax9_corr2_5.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_5.stopped', dax9_corr2_5.tStopRefresh)
    trials_phase_2.addData('star_16.started', star_16.tStartRefresh)
    trials_phase_2.addData('star_16.stopped', star_16.tStopRefresh)
    trials_phase_2.addData('triange_4.started', triange_4.tStartRefresh)
    trials_phase_2.addData('triange_4.stopped', triange_4.tStopRefresh)
    trials_phase_2.addData('cross_15.started', cross_15.tStartRefresh)
    trials_phase_2.addData('cross_15.stopped', cross_15.tStopRefresh)
    # check responses
    if key_resp_blicketfep24.keys in ['', [], None]:  # No response was made
        key_resp_blicketfep24.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_blicketfep24.corr = 1;  # correct non-response
        else:
           key_resp_blicketfep24.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_blicketfep24.keys',key_resp_blicketfep24.keys)
    trials_phase_2.addData('key_resp_blicketfep24.corr', key_resp_blicketfep24.corr)
    if key_resp_blicketfep24.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_blicketfep24.rt', key_resp_blicketfep24.rt)
    trials_phase_2.addData('key_resp_blicketfep24.started', key_resp_blicketfep24.tStartRefresh)
    trials_phase_2.addData('key_resp_blicketfep24.stopped', key_resp_blicketfep24.tStopRefresh)
    trials_phase_2.addData('option1_5.started', option1_5.tStartRefresh)
    trials_phase_2.addData('option1_5.stopped', option1_5.tStopRefresh)
    trials_phase_2.addData('option2_5.started', option2_5.tStartRefresh)
    trials_phase_2.addData('option2_5.stopped', option2_5.tStopRefresh)
    trials_phase_2.addData('option3_5.started', option3_5.tStartRefresh)
    trials_phase_2.addData('option3_5.stopped', option3_5.tStopRefresh)
    # the Routine "blicketfep24" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_blicketfep24"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_blicketfep24.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_blicketfep24.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_16.setText(msg1)
    feedback0_dax9_16.setText(msg0)
    feedback_dax9_16.setText(msg)
    # keep track of which components have finished
    fb_blicketfep24Components = [feedback1_dax9_16, feedback0_dax9_16, feedback_dax9_16]
    for thisComponent in fb_blicketfep24Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_blicketfep24Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_blicketfep24"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_blicketfep24Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_blicketfep24Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_16* updates
        if feedback1_dax9_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_16.frameNStart = frameN  # exact frame index
            feedback1_dax9_16.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_16, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_16.setAutoDraw(True)
        if feedback1_dax9_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_16.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_16.tStop = t  # not accounting for scr refresh
                feedback1_dax9_16.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_16, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_16.setAutoDraw(False)
        
        # *feedback0_dax9_16* updates
        if feedback0_dax9_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_16.frameNStart = frameN  # exact frame index
            feedback0_dax9_16.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_16, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_16.setAutoDraw(True)
        if feedback0_dax9_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_16.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_16.tStop = t  # not accounting for scr refresh
                feedback0_dax9_16.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_16, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_16.setAutoDraw(False)
        
        # *feedback_dax9_16* updates
        if feedback_dax9_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_16.frameNStart = frameN  # exact frame index
            feedback_dax9_16.tStart = t  # local t and not account for scr refresh
            feedback_dax9_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_16, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_16.setAutoDraw(True)
        if feedback_dax9_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_16.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_16.tStop = t  # not accounting for scr refresh
                feedback_dax9_16.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_16, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_16.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_blicketfep24Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_blicketfep24"-------
    for thisComponent in fb_blicketfep24Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_16.started', feedback1_dax9_16.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_16.stopped', feedback1_dax9_16.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_16.started', feedback0_dax9_16.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_16.stopped', feedback0_dax9_16.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_16.started', feedback_dax9_16.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_16.stopped', feedback_dax9_16.tStopRefresh)
    
    # ------Prepare to start Routine "smicketfep25"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_17.setFillColor('white')
    triange_5.setFillColor('white')
    cross_16.setFillColor('white')
    key_resp_smicketfep25.keys = []
    key_resp_smicketfep25.rt = []
    _key_resp_smicketfep25_allKeys = []
    # keep track of which components have finished
    smicketfep25Components = [dax9_corr2_6, star_17, triange_5, cross_16, key_resp_smicketfep25, option1_12, option2_12, option3_11]
    for thisComponent in smicketfep25Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicketfep25Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicketfep25"-------
    while continueRoutine:
        # get current time
        t = smicketfep25Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicketfep25Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_6* updates
        if dax9_corr2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_6.frameNStart = frameN  # exact frame index
            dax9_corr2_6.tStart = t  # local t and not account for scr refresh
            dax9_corr2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_6, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_6.setAutoDraw(True)
        
        # *star_17* updates
        if star_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_17.frameNStart = frameN  # exact frame index
            star_17.tStart = t  # local t and not account for scr refresh
            star_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_17, 'tStartRefresh')  # time at next scr refresh
            star_17.setAutoDraw(True)
        
        # *triange_5* updates
        if triange_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_5.frameNStart = frameN  # exact frame index
            triange_5.tStart = t  # local t and not account for scr refresh
            triange_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_5, 'tStartRefresh')  # time at next scr refresh
            triange_5.setAutoDraw(True)
        
        # *cross_16* updates
        if cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_16.frameNStart = frameN  # exact frame index
            cross_16.tStart = t  # local t and not account for scr refresh
            cross_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_16, 'tStartRefresh')  # time at next scr refresh
            cross_16.setAutoDraw(True)
        
        # *key_resp_smicketfep25* updates
        waitOnFlip = False
        if key_resp_smicketfep25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicketfep25.frameNStart = frameN  # exact frame index
            key_resp_smicketfep25.tStart = t  # local t and not account for scr refresh
            key_resp_smicketfep25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicketfep25, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicketfep25.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicketfep25.clock.reset)  # t=0 on next screen flip
        if key_resp_smicketfep25.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicketfep25.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_smicketfep25_allKeys.extend(theseKeys)
            if len(_key_resp_smicketfep25_allKeys):
                key_resp_smicketfep25.keys = _key_resp_smicketfep25_allKeys[-1].name  # just the last key pressed
                key_resp_smicketfep25.rt = _key_resp_smicketfep25_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicketfep25.keys == str('2')) or (key_resp_smicketfep25.keys == '2'):
                    key_resp_smicketfep25.corr = 1
                else:
                    key_resp_smicketfep25.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_12* updates
        if option1_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_12.frameNStart = frameN  # exact frame index
            option1_12.tStart = t  # local t and not account for scr refresh
            option1_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_12, 'tStartRefresh')  # time at next scr refresh
            option1_12.setAutoDraw(True)
        
        # *option2_12* updates
        if option2_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_12.frameNStart = frameN  # exact frame index
            option2_12.tStart = t  # local t and not account for scr refresh
            option2_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_12, 'tStartRefresh')  # time at next scr refresh
            option2_12.setAutoDraw(True)
        
        # *option3_11* updates
        if option3_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_11.frameNStart = frameN  # exact frame index
            option3_11.tStart = t  # local t and not account for scr refresh
            option3_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_11, 'tStartRefresh')  # time at next scr refresh
            option3_11.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicketfep25Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicketfep25"-------
    for thisComponent in smicketfep25Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_6.started', dax9_corr2_6.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_6.stopped', dax9_corr2_6.tStopRefresh)
    trials_phase_2.addData('star_17.started', star_17.tStartRefresh)
    trials_phase_2.addData('star_17.stopped', star_17.tStopRefresh)
    trials_phase_2.addData('triange_5.started', triange_5.tStartRefresh)
    trials_phase_2.addData('triange_5.stopped', triange_5.tStopRefresh)
    trials_phase_2.addData('cross_16.started', cross_16.tStartRefresh)
    trials_phase_2.addData('cross_16.stopped', cross_16.tStopRefresh)
    # check responses
    if key_resp_smicketfep25.keys in ['', [], None]:  # No response was made
        key_resp_smicketfep25.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_smicketfep25.corr = 1;  # correct non-response
        else:
           key_resp_smicketfep25.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicketfep25.keys',key_resp_smicketfep25.keys)
    trials_phase_2.addData('key_resp_smicketfep25.corr', key_resp_smicketfep25.corr)
    if key_resp_smicketfep25.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicketfep25.rt', key_resp_smicketfep25.rt)
    trials_phase_2.addData('key_resp_smicketfep25.started', key_resp_smicketfep25.tStartRefresh)
    trials_phase_2.addData('key_resp_smicketfep25.stopped', key_resp_smicketfep25.tStopRefresh)
    trials_phase_2.addData('option1_12.started', option1_12.tStartRefresh)
    trials_phase_2.addData('option1_12.stopped', option1_12.tStopRefresh)
    trials_phase_2.addData('option2_12.started', option2_12.tStartRefresh)
    trials_phase_2.addData('option2_12.stopped', option2_12.tStopRefresh)
    trials_phase_2.addData('option3_11.started', option3_11.tStartRefresh)
    trials_phase_2.addData('option3_11.stopped', option3_11.tStopRefresh)
    # the Routine "smicketfep25" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicketfep25"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicketfep25.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicketfep25.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_17.setText(msg1)
    feedback0_dax9_17.setText(msg0)
    feedback_dax9_17.setText(msg)
    # keep track of which components have finished
    fb_smicketfep25Components = [feedback1_dax9_17, feedback0_dax9_17, feedback_dax9_17]
    for thisComponent in fb_smicketfep25Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicketfep25Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicketfep25"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicketfep25Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicketfep25Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_17* updates
        if feedback1_dax9_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_17.frameNStart = frameN  # exact frame index
            feedback1_dax9_17.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_17, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_17.setAutoDraw(True)
        if feedback1_dax9_17.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_17.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_17.tStop = t  # not accounting for scr refresh
                feedback1_dax9_17.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_17, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_17.setAutoDraw(False)
        
        # *feedback0_dax9_17* updates
        if feedback0_dax9_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_17.frameNStart = frameN  # exact frame index
            feedback0_dax9_17.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_17, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_17.setAutoDraw(True)
        if feedback0_dax9_17.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_17.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_17.tStop = t  # not accounting for scr refresh
                feedback0_dax9_17.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_17, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_17.setAutoDraw(False)
        
        # *feedback_dax9_17* updates
        if feedback_dax9_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_17.frameNStart = frameN  # exact frame index
            feedback_dax9_17.tStart = t  # local t and not account for scr refresh
            feedback_dax9_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_17, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_17.setAutoDraw(True)
        if feedback_dax9_17.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_17.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_17.tStop = t  # not accounting for scr refresh
                feedback_dax9_17.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_17, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_17.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicketfep25Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicketfep25"-------
    for thisComponent in fb_smicketfep25Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_17.started', feedback1_dax9_17.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_17.stopped', feedback1_dax9_17.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_17.started', feedback0_dax9_17.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_17.stopped', feedback0_dax9_17.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_17.started', feedback_dax9_17.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_17.stopped', feedback_dax9_17.tStopRefresh)
    
    # ------Prepare to start Routine "smicketfep26"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_18.setFillColor('white')
    triange_6.setFillColor('white')
    cross_17.setFillColor('white')
    key_resp_smicketfep26.keys = []
    key_resp_smicketfep26.rt = []
    _key_resp_smicketfep26_allKeys = []
    # keep track of which components have finished
    smicketfep26Components = [dax9_corr2_7, star_18, triange_6, cross_17, key_resp_smicketfep26, option1_13, option2_13, option3_12]
    for thisComponent in smicketfep26Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicketfep26Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicketfep26"-------
    while continueRoutine:
        # get current time
        t = smicketfep26Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicketfep26Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_7* updates
        if dax9_corr2_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_7.frameNStart = frameN  # exact frame index
            dax9_corr2_7.tStart = t  # local t and not account for scr refresh
            dax9_corr2_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_7, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_7.setAutoDraw(True)
        
        # *star_18* updates
        if star_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_18.frameNStart = frameN  # exact frame index
            star_18.tStart = t  # local t and not account for scr refresh
            star_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_18, 'tStartRefresh')  # time at next scr refresh
            star_18.setAutoDraw(True)
        
        # *triange_6* updates
        if triange_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_6.frameNStart = frameN  # exact frame index
            triange_6.tStart = t  # local t and not account for scr refresh
            triange_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_6, 'tStartRefresh')  # time at next scr refresh
            triange_6.setAutoDraw(True)
        
        # *cross_17* updates
        if cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_17.frameNStart = frameN  # exact frame index
            cross_17.tStart = t  # local t and not account for scr refresh
            cross_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_17, 'tStartRefresh')  # time at next scr refresh
            cross_17.setAutoDraw(True)
        
        # *key_resp_smicketfep26* updates
        waitOnFlip = False
        if key_resp_smicketfep26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicketfep26.frameNStart = frameN  # exact frame index
            key_resp_smicketfep26.tStart = t  # local t and not account for scr refresh
            key_resp_smicketfep26.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicketfep26, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicketfep26.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicketfep26.clock.reset)  # t=0 on next screen flip
        if key_resp_smicketfep26.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicketfep26.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_smicketfep26_allKeys.extend(theseKeys)
            if len(_key_resp_smicketfep26_allKeys):
                key_resp_smicketfep26.keys = _key_resp_smicketfep26_allKeys[-1].name  # just the last key pressed
                key_resp_smicketfep26.rt = _key_resp_smicketfep26_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicketfep26.keys == str('3')) or (key_resp_smicketfep26.keys == '3'):
                    key_resp_smicketfep26.corr = 1
                else:
                    key_resp_smicketfep26.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_13* updates
        if option1_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_13.frameNStart = frameN  # exact frame index
            option1_13.tStart = t  # local t and not account for scr refresh
            option1_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_13, 'tStartRefresh')  # time at next scr refresh
            option1_13.setAutoDraw(True)
        
        # *option2_13* updates
        if option2_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_13.frameNStart = frameN  # exact frame index
            option2_13.tStart = t  # local t and not account for scr refresh
            option2_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_13, 'tStartRefresh')  # time at next scr refresh
            option2_13.setAutoDraw(True)
        
        # *option3_12* updates
        if option3_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_12.frameNStart = frameN  # exact frame index
            option3_12.tStart = t  # local t and not account for scr refresh
            option3_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_12, 'tStartRefresh')  # time at next scr refresh
            option3_12.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicketfep26Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicketfep26"-------
    for thisComponent in smicketfep26Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_7.started', dax9_corr2_7.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_7.stopped', dax9_corr2_7.tStopRefresh)
    trials_phase_2.addData('star_18.started', star_18.tStartRefresh)
    trials_phase_2.addData('star_18.stopped', star_18.tStopRefresh)
    trials_phase_2.addData('triange_6.started', triange_6.tStartRefresh)
    trials_phase_2.addData('triange_6.stopped', triange_6.tStopRefresh)
    trials_phase_2.addData('cross_17.started', cross_17.tStartRefresh)
    trials_phase_2.addData('cross_17.stopped', cross_17.tStopRefresh)
    # check responses
    if key_resp_smicketfep26.keys in ['', [], None]:  # No response was made
        key_resp_smicketfep26.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_smicketfep26.corr = 1;  # correct non-response
        else:
           key_resp_smicketfep26.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicketfep26.keys',key_resp_smicketfep26.keys)
    trials_phase_2.addData('key_resp_smicketfep26.corr', key_resp_smicketfep26.corr)
    if key_resp_smicketfep26.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicketfep26.rt', key_resp_smicketfep26.rt)
    trials_phase_2.addData('key_resp_smicketfep26.started', key_resp_smicketfep26.tStartRefresh)
    trials_phase_2.addData('key_resp_smicketfep26.stopped', key_resp_smicketfep26.tStopRefresh)
    trials_phase_2.addData('option1_13.started', option1_13.tStartRefresh)
    trials_phase_2.addData('option1_13.stopped', option1_13.tStopRefresh)
    trials_phase_2.addData('option2_13.started', option2_13.tStartRefresh)
    trials_phase_2.addData('option2_13.stopped', option2_13.tStopRefresh)
    trials_phase_2.addData('option3_12.started', option3_12.tStartRefresh)
    trials_phase_2.addData('option3_12.stopped', option3_12.tStopRefresh)
    # the Routine "smicketfep26" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicketfep26"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicketfep26.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicketfep26.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_18.setText(msg1)
    feedback0_dax9_18.setText(msg0)
    feedback_dax9_18.setText(msg)
    # keep track of which components have finished
    fb_smicketfep26Components = [feedback1_dax9_18, feedback0_dax9_18, feedback_dax9_18]
    for thisComponent in fb_smicketfep26Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicketfep26Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicketfep26"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicketfep26Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicketfep26Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_18* updates
        if feedback1_dax9_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_18.frameNStart = frameN  # exact frame index
            feedback1_dax9_18.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_18, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_18.setAutoDraw(True)
        if feedback1_dax9_18.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_18.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_18.tStop = t  # not accounting for scr refresh
                feedback1_dax9_18.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_18, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_18.setAutoDraw(False)
        
        # *feedback0_dax9_18* updates
        if feedback0_dax9_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_18.frameNStart = frameN  # exact frame index
            feedback0_dax9_18.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_18, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_18.setAutoDraw(True)
        if feedback0_dax9_18.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_18.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_18.tStop = t  # not accounting for scr refresh
                feedback0_dax9_18.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_18, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_18.setAutoDraw(False)
        
        # *feedback_dax9_18* updates
        if feedback_dax9_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_18.frameNStart = frameN  # exact frame index
            feedback_dax9_18.tStart = t  # local t and not account for scr refresh
            feedback_dax9_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_18, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_18.setAutoDraw(True)
        if feedback_dax9_18.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_18.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_18.tStop = t  # not accounting for scr refresh
                feedback_dax9_18.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_18, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_18.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicketfep26Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicketfep26"-------
    for thisComponent in fb_smicketfep26Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_18.started', feedback1_dax9_18.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_18.stopped', feedback1_dax9_18.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_18.started', feedback0_dax9_18.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_18.stopped', feedback0_dax9_18.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_18.started', feedback_dax9_18.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_18.stopped', feedback_dax9_18.tStopRefresh)
    
    # ------Prepare to start Routine "smicketfep27"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_19.setFillColor('white')
    triange_7.setFillColor('white')
    cross_18.setFillColor('white')
    key_resp_smicketfep27.keys = []
    key_resp_smicketfep27.rt = []
    _key_resp_smicketfep27_allKeys = []
    # keep track of which components have finished
    smicketfep27Components = [dax9_corr2_8, star_19, triange_7, cross_18, key_resp_smicketfep27, option1_14, option2_14, option3_13]
    for thisComponent in smicketfep27Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicketfep27Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicketfep27"-------
    while continueRoutine:
        # get current time
        t = smicketfep27Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicketfep27Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_8* updates
        if dax9_corr2_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_8.frameNStart = frameN  # exact frame index
            dax9_corr2_8.tStart = t  # local t and not account for scr refresh
            dax9_corr2_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_8, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_8.setAutoDraw(True)
        
        # *star_19* updates
        if star_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_19.frameNStart = frameN  # exact frame index
            star_19.tStart = t  # local t and not account for scr refresh
            star_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_19, 'tStartRefresh')  # time at next scr refresh
            star_19.setAutoDraw(True)
        
        # *triange_7* updates
        if triange_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_7.frameNStart = frameN  # exact frame index
            triange_7.tStart = t  # local t and not account for scr refresh
            triange_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_7, 'tStartRefresh')  # time at next scr refresh
            triange_7.setAutoDraw(True)
        
        # *cross_18* updates
        if cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_18.frameNStart = frameN  # exact frame index
            cross_18.tStart = t  # local t and not account for scr refresh
            cross_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_18, 'tStartRefresh')  # time at next scr refresh
            cross_18.setAutoDraw(True)
        
        # *key_resp_smicketfep27* updates
        waitOnFlip = False
        if key_resp_smicketfep27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicketfep27.frameNStart = frameN  # exact frame index
            key_resp_smicketfep27.tStart = t  # local t and not account for scr refresh
            key_resp_smicketfep27.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicketfep27, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicketfep27.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicketfep27.clock.reset)  # t=0 on next screen flip
        if key_resp_smicketfep27.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicketfep27.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_smicketfep27_allKeys.extend(theseKeys)
            if len(_key_resp_smicketfep27_allKeys):
                key_resp_smicketfep27.keys = _key_resp_smicketfep27_allKeys[-1].name  # just the last key pressed
                key_resp_smicketfep27.rt = _key_resp_smicketfep27_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicketfep27.keys == str('3')) or (key_resp_smicketfep27.keys == '3'):
                    key_resp_smicketfep27.corr = 1
                else:
                    key_resp_smicketfep27.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_14* updates
        if option1_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_14.frameNStart = frameN  # exact frame index
            option1_14.tStart = t  # local t and not account for scr refresh
            option1_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_14, 'tStartRefresh')  # time at next scr refresh
            option1_14.setAutoDraw(True)
        
        # *option2_14* updates
        if option2_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_14.frameNStart = frameN  # exact frame index
            option2_14.tStart = t  # local t and not account for scr refresh
            option2_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_14, 'tStartRefresh')  # time at next scr refresh
            option2_14.setAutoDraw(True)
        
        # *option3_13* updates
        if option3_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_13.frameNStart = frameN  # exact frame index
            option3_13.tStart = t  # local t and not account for scr refresh
            option3_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_13, 'tStartRefresh')  # time at next scr refresh
            option3_13.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicketfep27Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicketfep27"-------
    for thisComponent in smicketfep27Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_8.started', dax9_corr2_8.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_8.stopped', dax9_corr2_8.tStopRefresh)
    trials_phase_2.addData('star_19.started', star_19.tStartRefresh)
    trials_phase_2.addData('star_19.stopped', star_19.tStopRefresh)
    trials_phase_2.addData('triange_7.started', triange_7.tStartRefresh)
    trials_phase_2.addData('triange_7.stopped', triange_7.tStopRefresh)
    trials_phase_2.addData('cross_18.started', cross_18.tStartRefresh)
    trials_phase_2.addData('cross_18.stopped', cross_18.tStopRefresh)
    # check responses
    if key_resp_smicketfep27.keys in ['', [], None]:  # No response was made
        key_resp_smicketfep27.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_smicketfep27.corr = 1;  # correct non-response
        else:
           key_resp_smicketfep27.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicketfep27.keys',key_resp_smicketfep27.keys)
    trials_phase_2.addData('key_resp_smicketfep27.corr', key_resp_smicketfep27.corr)
    if key_resp_smicketfep27.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicketfep27.rt', key_resp_smicketfep27.rt)
    trials_phase_2.addData('key_resp_smicketfep27.started', key_resp_smicketfep27.tStartRefresh)
    trials_phase_2.addData('key_resp_smicketfep27.stopped', key_resp_smicketfep27.tStopRefresh)
    trials_phase_2.addData('option1_14.started', option1_14.tStartRefresh)
    trials_phase_2.addData('option1_14.stopped', option1_14.tStopRefresh)
    trials_phase_2.addData('option2_14.started', option2_14.tStartRefresh)
    trials_phase_2.addData('option2_14.stopped', option2_14.tStopRefresh)
    trials_phase_2.addData('option3_13.started', option3_13.tStartRefresh)
    trials_phase_2.addData('option3_13.stopped', option3_13.tStopRefresh)
    # the Routine "smicketfep27" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicketfep27"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicketfep27.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicketfep27.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_19.setText(msg1)
    feedback0_dax9_19.setText(msg0)
    feedback_dax9_19.setText(msg)
    # keep track of which components have finished
    fb_smicketfep27Components = [feedback1_dax9_19, feedback0_dax9_19, feedback_dax9_19]
    for thisComponent in fb_smicketfep27Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicketfep27Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicketfep27"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicketfep27Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicketfep27Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_19* updates
        if feedback1_dax9_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_19.frameNStart = frameN  # exact frame index
            feedback1_dax9_19.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_19, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_19.setAutoDraw(True)
        if feedback1_dax9_19.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_19.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_19.tStop = t  # not accounting for scr refresh
                feedback1_dax9_19.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_19, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_19.setAutoDraw(False)
        
        # *feedback0_dax9_19* updates
        if feedback0_dax9_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_19.frameNStart = frameN  # exact frame index
            feedback0_dax9_19.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_19, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_19.setAutoDraw(True)
        if feedback0_dax9_19.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_19.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_19.tStop = t  # not accounting for scr refresh
                feedback0_dax9_19.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_19, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_19.setAutoDraw(False)
        
        # *feedback_dax9_19* updates
        if feedback_dax9_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_19.frameNStart = frameN  # exact frame index
            feedback_dax9_19.tStart = t  # local t and not account for scr refresh
            feedback_dax9_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_19, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_19.setAutoDraw(True)
        if feedback_dax9_19.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_19.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_19.tStop = t  # not accounting for scr refresh
                feedback_dax9_19.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_19, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_19.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicketfep27Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicketfep27"-------
    for thisComponent in fb_smicketfep27Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_19.started', feedback1_dax9_19.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_19.stopped', feedback1_dax9_19.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_19.started', feedback0_dax9_19.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_19.stopped', feedback0_dax9_19.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_19.started', feedback_dax9_19.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_19.stopped', feedback_dax9_19.tStopRefresh)
    
    # ------Prepare to start Routine "smicketfep28"-------
    continueRoutine = True
    # update component parameters for each repeat
    star_20.setFillColor('white')
    triange_8.setFillColor('white')
    cross_19.setFillColor('white')
    key_resp_smicketfep28.keys = []
    key_resp_smicketfep28.rt = []
    _key_resp_smicketfep28_allKeys = []
    # keep track of which components have finished
    smicketfep28Components = [dax9_corr2_9, star_20, triange_8, cross_19, key_resp_smicketfep28, option1_15, option2_15, option3_14]
    for thisComponent in smicketfep28Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    smicketfep28Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "smicketfep28"-------
    while continueRoutine:
        # get current time
        t = smicketfep28Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=smicketfep28Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_9* updates
        if dax9_corr2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_9.frameNStart = frameN  # exact frame index
            dax9_corr2_9.tStart = t  # local t and not account for scr refresh
            dax9_corr2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_9, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_9.setAutoDraw(True)
        
        # *star_20* updates
        if star_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_20.frameNStart = frameN  # exact frame index
            star_20.tStart = t  # local t and not account for scr refresh
            star_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_20, 'tStartRefresh')  # time at next scr refresh
            star_20.setAutoDraw(True)
        
        # *triange_8* updates
        if triange_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_8.frameNStart = frameN  # exact frame index
            triange_8.tStart = t  # local t and not account for scr refresh
            triange_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_8, 'tStartRefresh')  # time at next scr refresh
            triange_8.setAutoDraw(True)
        
        # *cross_19* updates
        if cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_19.frameNStart = frameN  # exact frame index
            cross_19.tStart = t  # local t and not account for scr refresh
            cross_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_19, 'tStartRefresh')  # time at next scr refresh
            cross_19.setAutoDraw(True)
        
        # *key_resp_smicketfep28* updates
        waitOnFlip = False
        if key_resp_smicketfep28.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_smicketfep28.frameNStart = frameN  # exact frame index
            key_resp_smicketfep28.tStart = t  # local t and not account for scr refresh
            key_resp_smicketfep28.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_smicketfep28, 'tStartRefresh')  # time at next scr refresh
            key_resp_smicketfep28.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_smicketfep28.clock.reset)  # t=0 on next screen flip
        if key_resp_smicketfep28.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_smicketfep28.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_smicketfep28_allKeys.extend(theseKeys)
            if len(_key_resp_smicketfep28_allKeys):
                key_resp_smicketfep28.keys = _key_resp_smicketfep28_allKeys[-1].name  # just the last key pressed
                key_resp_smicketfep28.rt = _key_resp_smicketfep28_allKeys[-1].rt
                # was this correct?
                if (key_resp_smicketfep28.keys == str('1')) or (key_resp_smicketfep28.keys == '1'):
                    key_resp_smicketfep28.corr = 1
                else:
                    key_resp_smicketfep28.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_15* updates
        if option1_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_15.frameNStart = frameN  # exact frame index
            option1_15.tStart = t  # local t and not account for scr refresh
            option1_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_15, 'tStartRefresh')  # time at next scr refresh
            option1_15.setAutoDraw(True)
        
        # *option2_15* updates
        if option2_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_15.frameNStart = frameN  # exact frame index
            option2_15.tStart = t  # local t and not account for scr refresh
            option2_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_15, 'tStartRefresh')  # time at next scr refresh
            option2_15.setAutoDraw(True)
        
        # *option3_14* updates
        if option3_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_14.frameNStart = frameN  # exact frame index
            option3_14.tStart = t  # local t and not account for scr refresh
            option3_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_14, 'tStartRefresh')  # time at next scr refresh
            option3_14.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in smicketfep28Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "smicketfep28"-------
    for thisComponent in smicketfep28Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('dax9_corr2_9.started', dax9_corr2_9.tStartRefresh)
    trials_phase_2.addData('dax9_corr2_9.stopped', dax9_corr2_9.tStopRefresh)
    trials_phase_2.addData('star_20.started', star_20.tStartRefresh)
    trials_phase_2.addData('star_20.stopped', star_20.tStopRefresh)
    trials_phase_2.addData('triange_8.started', triange_8.tStartRefresh)
    trials_phase_2.addData('triange_8.stopped', triange_8.tStopRefresh)
    trials_phase_2.addData('cross_19.started', cross_19.tStartRefresh)
    trials_phase_2.addData('cross_19.stopped', cross_19.tStopRefresh)
    # check responses
    if key_resp_smicketfep28.keys in ['', [], None]:  # No response was made
        key_resp_smicketfep28.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_smicketfep28.corr = 1;  # correct non-response
        else:
           key_resp_smicketfep28.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase_2 (TrialHandler)
    trials_phase_2.addData('key_resp_smicketfep28.keys',key_resp_smicketfep28.keys)
    trials_phase_2.addData('key_resp_smicketfep28.corr', key_resp_smicketfep28.corr)
    if key_resp_smicketfep28.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_smicketfep28.rt', key_resp_smicketfep28.rt)
    trials_phase_2.addData('key_resp_smicketfep28.started', key_resp_smicketfep28.tStartRefresh)
    trials_phase_2.addData('key_resp_smicketfep28.stopped', key_resp_smicketfep28.tStopRefresh)
    trials_phase_2.addData('option1_15.started', option1_15.tStartRefresh)
    trials_phase_2.addData('option1_15.stopped', option1_15.tStopRefresh)
    trials_phase_2.addData('option2_15.started', option2_15.tStartRefresh)
    trials_phase_2.addData('option2_15.stopped', option2_15.tStopRefresh)
    trials_phase_2.addData('option3_14.started', option3_14.tStartRefresh)
    trials_phase_2.addData('option3_14.stopped', option3_14.tStopRefresh)
    # the Routine "smicketfep28" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_smicketfep28"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_smicketfep28.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_smicketfep28.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_20.setText(msg1)
    feedback0_dax9_20.setText(msg0)
    feedback_dax9_20.setText(msg)
    # keep track of which components have finished
    fb_smicketfep28Components = [feedback1_dax9_20, feedback0_dax9_20, feedback_dax9_20]
    for thisComponent in fb_smicketfep28Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_smicketfep28Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_smicketfep28"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_smicketfep28Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_smicketfep28Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_20* updates
        if feedback1_dax9_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_20.frameNStart = frameN  # exact frame index
            feedback1_dax9_20.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_20, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_20.setAutoDraw(True)
        if feedback1_dax9_20.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_20.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_20.tStop = t  # not accounting for scr refresh
                feedback1_dax9_20.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_20, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_20.setAutoDraw(False)
        
        # *feedback0_dax9_20* updates
        if feedback0_dax9_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_20.frameNStart = frameN  # exact frame index
            feedback0_dax9_20.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_20, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_20.setAutoDraw(True)
        if feedback0_dax9_20.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_20.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_20.tStop = t  # not accounting for scr refresh
                feedback0_dax9_20.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_20, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_20.setAutoDraw(False)
        
        # *feedback_dax9_20* updates
        if feedback_dax9_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_20.frameNStart = frameN  # exact frame index
            feedback_dax9_20.tStart = t  # local t and not account for scr refresh
            feedback_dax9_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_20, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_20.setAutoDraw(True)
        if feedback_dax9_20.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_20.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_20.tStop = t  # not accounting for scr refresh
                feedback_dax9_20.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_20, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_20.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_smicketfep28Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_smicketfep28"-------
    for thisComponent in fb_smicketfep28Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('feedback1_dax9_20.started', feedback1_dax9_20.tStartRefresh)
    trials_phase_2.addData('feedback1_dax9_20.stopped', feedback1_dax9_20.tStopRefresh)
    trials_phase_2.addData('feedback0_dax9_20.started', feedback0_dax9_20.tStartRefresh)
    trials_phase_2.addData('feedback0_dax9_20.stopped', feedback0_dax9_20.tStopRefresh)
    trials_phase_2.addData('feedback_dax9_20.started', feedback_dax9_20.tStartRefresh)
    trials_phase_2.addData('feedback_dax9_20.stopped', feedback_dax9_20.tStopRefresh)
    
    # ------Prepare to start Routine "proceed"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_6.keys = []
    key_resp_6.rt = []
    _key_resp_6_allKeys = []
    # keep track of which components have finished
    proceedComponents = [text2, key_resp_6]
    for thisComponent in proceedComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    proceedClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "proceed"-------
    while continueRoutine:
        # get current time
        t = proceedClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=proceedClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text2* updates
        if text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text2.frameNStart = frameN  # exact frame index
            text2.tStart = t  # local t and not account for scr refresh
            text2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text2, 'tStartRefresh')  # time at next scr refresh
            text2.setAutoDraw(True)
        
        # *key_resp_6* updates
        waitOnFlip = False
        if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_6.frameNStart = frameN  # exact frame index
            key_resp_6.tStart = t  # local t and not account for scr refresh
            key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
            key_resp_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_6_allKeys.extend(theseKeys)
            if len(_key_resp_6_allKeys):
                key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
                key_resp_6.rt = _key_resp_6_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in proceedComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "proceed"-------
    for thisComponent in proceedComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase_2.addData('text2.started', text2.tStartRefresh)
    trials_phase_2.addData('text2.stopped', text2.tStopRefresh)
    # check responses
    if key_resp_6.keys in ['', [], None]:  # No response was made
        key_resp_6.keys = None
    trials_phase_2.addData('key_resp_6.keys',key_resp_6.keys)
    if key_resp_6.keys != None:  # we had a response
        trials_phase_2.addData('key_resp_6.rt', key_resp_6.rt)
    trials_phase_2.addData('key_resp_6.started', key_resp_6.tStartRefresh)
    trials_phase_2.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
    # the Routine "proceed" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_test2 = data.TrialHandler(nReps=1.0, method='sequential', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='trials_test2')
    thisExp.addLoop(trials_test2)  # add the loop to the experiment
    thisTrials_test2 = trials_test2.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_test2.rgb)
    if thisTrials_test2 != None:
        for paramName in thisTrials_test2:
            exec('{} = thisTrials_test2[paramName]'.format(paramName))
    
    for thisTrials_test2 in trials_test2:
        currentLoop = trials_test2
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_test2.rgb)
        if thisTrials_test2 != None:
            for paramName in thisTrials_test2:
                exec('{} = thisTrials_test2[paramName]'.format(paramName))
        
        # ------Prepare to start Routine "dax12test2"-------
        continueRoutine = True
        # update component parameters for each repeat
        number_correct2 = 0
        star_21.setFillColor('white')
        tr.setFillColor('white')
        cr.setFillColor('white')
        key_resp_dax12_2.keys = []
        key_resp_dax12_2.rt = []
        _key_resp_dax12_2_allKeys = []
        # keep track of which components have finished
        dax12test2Components = [dax11_corr2_2, star_21, tr, cr, key_resp_dax12_2, option1_16, option2_16, option3_15]
        for thisComponent in dax12test2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        dax12test2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "dax12test2"-------
        while continueRoutine:
            # get current time
            t = dax12test2Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=dax12test2Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *dax11_corr2_2* updates
            if dax11_corr2_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                dax11_corr2_2.frameNStart = frameN  # exact frame index
                dax11_corr2_2.tStart = t  # local t and not account for scr refresh
                dax11_corr2_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(dax11_corr2_2, 'tStartRefresh')  # time at next scr refresh
                dax11_corr2_2.setAutoDraw(True)
            
            # *star_21* updates
            if star_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                star_21.frameNStart = frameN  # exact frame index
                star_21.tStart = t  # local t and not account for scr refresh
                star_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(star_21, 'tStartRefresh')  # time at next scr refresh
                star_21.setAutoDraw(True)
            
            # *tr* updates
            if tr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                tr.frameNStart = frameN  # exact frame index
                tr.tStart = t  # local t and not account for scr refresh
                tr.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(tr, 'tStartRefresh')  # time at next scr refresh
                tr.setAutoDraw(True)
            
            # *cr* updates
            if cr.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cr.frameNStart = frameN  # exact frame index
                cr.tStart = t  # local t and not account for scr refresh
                cr.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cr, 'tStartRefresh')  # time at next scr refresh
                cr.setAutoDraw(True)
            
            # *key_resp_dax12_2* updates
            waitOnFlip = False
            if key_resp_dax12_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_dax12_2.frameNStart = frameN  # exact frame index
                key_resp_dax12_2.tStart = t  # local t and not account for scr refresh
                key_resp_dax12_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_dax12_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_dax12_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_dax12_2.clock.reset)  # t=0 on next screen flip
            if key_resp_dax12_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_dax12_2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
                _key_resp_dax12_2_allKeys.extend(theseKeys)
                if len(_key_resp_dax12_2_allKeys):
                    key_resp_dax12_2.keys = _key_resp_dax12_2_allKeys[-1].name  # just the last key pressed
                    key_resp_dax12_2.rt = _key_resp_dax12_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_dax12_2.keys == str('2')) or (key_resp_dax12_2.keys == '2'):
                        key_resp_dax12_2.corr = 1
                    else:
                        key_resp_dax12_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *option1_16* updates
            if option1_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_16.frameNStart = frameN  # exact frame index
                option1_16.tStart = t  # local t and not account for scr refresh
                option1_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_16, 'tStartRefresh')  # time at next scr refresh
                option1_16.setAutoDraw(True)
            
            # *option2_16* updates
            if option2_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_16.frameNStart = frameN  # exact frame index
                option2_16.tStart = t  # local t and not account for scr refresh
                option2_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_16, 'tStartRefresh')  # time at next scr refresh
                option2_16.setAutoDraw(True)
            
            # *option3_15* updates
            if option3_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option3_15.frameNStart = frameN  # exact frame index
                option3_15.tStart = t  # local t and not account for scr refresh
                option3_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option3_15, 'tStartRefresh')  # time at next scr refresh
                option3_15.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in dax12test2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "dax12test2"-------
        for thisComponent in dax12test2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_dax12_2.corr: 
            number_correct2 = number_correct2 + 1
            print('Correct2: ' + str(number_correct2))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct2 == 5:
            print('total Correct2: ' + str(number_correct2))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase_2.finished = True
        else:
            print('flag2!')
            trials_phase_2.finished = False
        trials_test2.addData('dax11_corr2_2.started', dax11_corr2_2.tStartRefresh)
        trials_test2.addData('dax11_corr2_2.stopped', dax11_corr2_2.tStopRefresh)
        trials_test2.addData('star_21.started', star_21.tStartRefresh)
        trials_test2.addData('star_21.stopped', star_21.tStopRefresh)
        trials_test2.addData('tr.started', tr.tStartRefresh)
        trials_test2.addData('tr.stopped', tr.tStopRefresh)
        trials_test2.addData('cr.started', cr.tStartRefresh)
        trials_test2.addData('cr.stopped', cr.tStopRefresh)
        # check responses
        if key_resp_dax12_2.keys in ['', [], None]:  # No response was made
            key_resp_dax12_2.keys = None
            # was no response the correct answer?!
            if str('2').lower() == 'none':
               key_resp_dax12_2.corr = 1;  # correct non-response
            else:
               key_resp_dax12_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test2 (TrialHandler)
        trials_test2.addData('key_resp_dax12_2.keys',key_resp_dax12_2.keys)
        trials_test2.addData('key_resp_dax12_2.corr', key_resp_dax12_2.corr)
        if key_resp_dax12_2.keys != None:  # we had a response
            trials_test2.addData('key_resp_dax12_2.rt', key_resp_dax12_2.rt)
        trials_test2.addData('key_resp_dax12_2.started', key_resp_dax12_2.tStartRefresh)
        trials_test2.addData('key_resp_dax12_2.stopped', key_resp_dax12_2.tStopRefresh)
        trials_test2.addData('option1_16.started', option1_16.tStartRefresh)
        trials_test2.addData('option1_16.stopped', option1_16.tStopRefresh)
        trials_test2.addData('option2_16.started', option2_16.tStartRefresh)
        trials_test2.addData('option2_16.stopped', option2_16.tStopRefresh)
        trials_test2.addData('option3_15.started', option3_15.tStartRefresh)
        trials_test2.addData('option3_15.stopped', option3_15.tStopRefresh)
        # the Routine "dax12test2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # ------Prepare to start Routine "blicket15test2"-------
        continueRoutine = True
        # update component parameters for each repeat
        key_resp_blicket15_2.keys = []
        key_resp_blicket15_2.rt = []
        _key_resp_blicket15_2_allKeys = []
        blicket_st_b15_4.setFillColor('black')
        blicket_st_w15_5.setFillColor('white')
        # keep track of which components have finished
        blicket15test2Components = [key_resp_blicket15_2, blicket1_9, blicket_st_b15_4, blicket_st_w15_5, option1_critical_11, option2_critical_11]
        for thisComponent in blicket15test2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        blicket15test2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "blicket15test2"-------
        while continueRoutine:
            # get current time
            t = blicket15test2Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=blicket15test2Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *key_resp_blicket15_2* updates
            waitOnFlip = False
            if key_resp_blicket15_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_blicket15_2.frameNStart = frameN  # exact frame index
                key_resp_blicket15_2.tStart = t  # local t and not account for scr refresh
                key_resp_blicket15_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_blicket15_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_blicket15_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_blicket15_2.clock.reset)  # t=0 on next screen flip
            if key_resp_blicket15_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_blicket15_2.getKeys(keyList=['1', '2'], waitRelease=False)
                _key_resp_blicket15_2_allKeys.extend(theseKeys)
                if len(_key_resp_blicket15_2_allKeys):
                    key_resp_blicket15_2.keys = _key_resp_blicket15_2_allKeys[-1].name  # just the last key pressed
                    key_resp_blicket15_2.rt = _key_resp_blicket15_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_blicket15_2.keys == str('1')) or (key_resp_blicket15_2.keys == '1'):
                        key_resp_blicket15_2.corr = 1
                    else:
                        key_resp_blicket15_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *blicket1_9* updates
            if blicket1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blicket1_9.frameNStart = frameN  # exact frame index
                blicket1_9.tStart = t  # local t and not account for scr refresh
                blicket1_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blicket1_9, 'tStartRefresh')  # time at next scr refresh
                blicket1_9.setAutoDraw(True)
            
            # *blicket_st_b15_4* updates
            if blicket_st_b15_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blicket_st_b15_4.frameNStart = frameN  # exact frame index
                blicket_st_b15_4.tStart = t  # local t and not account for scr refresh
                blicket_st_b15_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blicket_st_b15_4, 'tStartRefresh')  # time at next scr refresh
                blicket_st_b15_4.setAutoDraw(True)
            
            # *blicket_st_w15_5* updates
            if blicket_st_w15_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blicket_st_w15_5.frameNStart = frameN  # exact frame index
                blicket_st_w15_5.tStart = t  # local t and not account for scr refresh
                blicket_st_w15_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blicket_st_w15_5, 'tStartRefresh')  # time at next scr refresh
                blicket_st_w15_5.setAutoDraw(True)
            
            # *option1_critical_11* updates
            if option1_critical_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_critical_11.frameNStart = frameN  # exact frame index
                option1_critical_11.tStart = t  # local t and not account for scr refresh
                option1_critical_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_critical_11, 'tStartRefresh')  # time at next scr refresh
                option1_critical_11.setAutoDraw(True)
            
            # *option2_critical_11* updates
            if option2_critical_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_critical_11.frameNStart = frameN  # exact frame index
                option2_critical_11.tStart = t  # local t and not account for scr refresh
                option2_critical_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_critical_11, 'tStartRefresh')  # time at next scr refresh
                option2_critical_11.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in blicket15test2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "blicket15test2"-------
        for thisComponent in blicket15test2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_blicket15_2.corr: 
            number_correct2 = number_correct2 + 1
            print('Correct2: ' + str(number_correct2))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct2 == 5:
            print('total Correct2: ' + str(number_correct2))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase_2.finished = True
        else:
            print('flag2!')
            trials_phase_2.finished = False
        # check responses
        if key_resp_blicket15_2.keys in ['', [], None]:  # No response was made
            key_resp_blicket15_2.keys = None
            # was no response the correct answer?!
            if str('1').lower() == 'none':
               key_resp_blicket15_2.corr = 1;  # correct non-response
            else:
               key_resp_blicket15_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test2 (TrialHandler)
        trials_test2.addData('key_resp_blicket15_2.keys',key_resp_blicket15_2.keys)
        trials_test2.addData('key_resp_blicket15_2.corr', key_resp_blicket15_2.corr)
        if key_resp_blicket15_2.keys != None:  # we had a response
            trials_test2.addData('key_resp_blicket15_2.rt', key_resp_blicket15_2.rt)
        trials_test2.addData('key_resp_blicket15_2.started', key_resp_blicket15_2.tStartRefresh)
        trials_test2.addData('key_resp_blicket15_2.stopped', key_resp_blicket15_2.tStopRefresh)
        trials_test2.addData('blicket1_9.started', blicket1_9.tStartRefresh)
        trials_test2.addData('blicket1_9.stopped', blicket1_9.tStopRefresh)
        trials_test2.addData('blicket_st_b15_4.started', blicket_st_b15_4.tStartRefresh)
        trials_test2.addData('blicket_st_b15_4.stopped', blicket_st_b15_4.tStopRefresh)
        trials_test2.addData('blicket_st_w15_5.started', blicket_st_w15_5.tStartRefresh)
        trials_test2.addData('blicket_st_w15_5.stopped', blicket_st_w15_5.tStopRefresh)
        trials_test2.addData('option1_critical_11.started', option1_critical_11.tStartRefresh)
        trials_test2.addData('option1_critical_11.stopped', option1_critical_11.tStopRefresh)
        trials_test2.addData('option2_critical_11.started', option2_critical_11.tStartRefresh)
        trials_test2.addData('option2_critical_11.stopped', option2_critical_11.tStopRefresh)
        # the Routine "blicket15test2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # ------Prepare to start Routine "smicket18test2"-------
        continueRoutine = True
        # update component parameters for each repeat
        key_resp_smicket18_2.keys = []
        key_resp_smicket18_2.rt = []
        _key_resp_smicket18_2_allKeys = []
        blicket_st_w_5.setFillColor('black')
        blicket_st_b_5.setFillColor('white')
        # keep track of which components have finished
        smicket18test2Components = [key_resp_smicket18_2, blicket1_10, blicket_st_w_5, blicket_st_b_5, option1_critical_12, option2_critical_12]
        for thisComponent in smicket18test2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        smicket18test2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "smicket18test2"-------
        while continueRoutine:
            # get current time
            t = smicket18test2Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=smicket18test2Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *key_resp_smicket18_2* updates
            waitOnFlip = False
            if key_resp_smicket18_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_smicket18_2.frameNStart = frameN  # exact frame index
                key_resp_smicket18_2.tStart = t  # local t and not account for scr refresh
                key_resp_smicket18_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_smicket18_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_smicket18_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_smicket18_2.clock.reset)  # t=0 on next screen flip
            if key_resp_smicket18_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_smicket18_2.getKeys(keyList=['1', '2'], waitRelease=False)
                _key_resp_smicket18_2_allKeys.extend(theseKeys)
                if len(_key_resp_smicket18_2_allKeys):
                    key_resp_smicket18_2.keys = _key_resp_smicket18_2_allKeys[-1].name  # just the last key pressed
                    key_resp_smicket18_2.rt = _key_resp_smicket18_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_smicket18_2.keys == str('2')) or (key_resp_smicket18_2.keys == '2'):
                        key_resp_smicket18_2.corr = 1
                    else:
                        key_resp_smicket18_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *blicket1_10* updates
            if blicket1_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blicket1_10.frameNStart = frameN  # exact frame index
                blicket1_10.tStart = t  # local t and not account for scr refresh
                blicket1_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blicket1_10, 'tStartRefresh')  # time at next scr refresh
                blicket1_10.setAutoDraw(True)
            
            # *blicket_st_w_5* updates
            if blicket_st_w_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blicket_st_w_5.frameNStart = frameN  # exact frame index
                blicket_st_w_5.tStart = t  # local t and not account for scr refresh
                blicket_st_w_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blicket_st_w_5, 'tStartRefresh')  # time at next scr refresh
                blicket_st_w_5.setAutoDraw(True)
            
            # *blicket_st_b_5* updates
            if blicket_st_b_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blicket_st_b_5.frameNStart = frameN  # exact frame index
                blicket_st_b_5.tStart = t  # local t and not account for scr refresh
                blicket_st_b_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blicket_st_b_5, 'tStartRefresh')  # time at next scr refresh
                blicket_st_b_5.setAutoDraw(True)
            
            # *option1_critical_12* updates
            if option1_critical_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_critical_12.frameNStart = frameN  # exact frame index
                option1_critical_12.tStart = t  # local t and not account for scr refresh
                option1_critical_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_critical_12, 'tStartRefresh')  # time at next scr refresh
                option1_critical_12.setAutoDraw(True)
            
            # *option2_critical_12* updates
            if option2_critical_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_critical_12.frameNStart = frameN  # exact frame index
                option2_critical_12.tStart = t  # local t and not account for scr refresh
                option2_critical_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_critical_12, 'tStartRefresh')  # time at next scr refresh
                option2_critical_12.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in smicket18test2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "smicket18test2"-------
        for thisComponent in smicket18test2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_smicket18_2.corr: 
            number_correct2 = number_correct2 + 1
            print('Correct2: ' + str(number_correct2))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct2 == 5:
            print('total Correct2: ' + str(number_correct2))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase_2.finished = True
        else:
            print('flag2!')
            trials_phase_2.finished = False
        # check responses
        if key_resp_smicket18_2.keys in ['', [], None]:  # No response was made
            key_resp_smicket18_2.keys = None
            # was no response the correct answer?!
            if str('2').lower() == 'none':
               key_resp_smicket18_2.corr = 1;  # correct non-response
            else:
               key_resp_smicket18_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test2 (TrialHandler)
        trials_test2.addData('key_resp_smicket18_2.keys',key_resp_smicket18_2.keys)
        trials_test2.addData('key_resp_smicket18_2.corr', key_resp_smicket18_2.corr)
        if key_resp_smicket18_2.keys != None:  # we had a response
            trials_test2.addData('key_resp_smicket18_2.rt', key_resp_smicket18_2.rt)
        trials_test2.addData('key_resp_smicket18_2.started', key_resp_smicket18_2.tStartRefresh)
        trials_test2.addData('key_resp_smicket18_2.stopped', key_resp_smicket18_2.tStopRefresh)
        trials_test2.addData('blicket1_10.started', blicket1_10.tStartRefresh)
        trials_test2.addData('blicket1_10.stopped', blicket1_10.tStopRefresh)
        trials_test2.addData('blicket_st_w_5.started', blicket_st_w_5.tStartRefresh)
        trials_test2.addData('blicket_st_w_5.stopped', blicket_st_w_5.tStopRefresh)
        trials_test2.addData('blicket_st_b_5.started', blicket_st_b_5.tStartRefresh)
        trials_test2.addData('blicket_st_b_5.stopped', blicket_st_b_5.tStopRefresh)
        trials_test2.addData('option1_critical_12.started', option1_critical_12.tStartRefresh)
        trials_test2.addData('option1_critical_12.stopped', option1_critical_12.tStopRefresh)
        trials_test2.addData('option2_critical_12.started', option2_critical_12.tStartRefresh)
        trials_test2.addData('option2_critical_12.stopped', option2_critical_12.tStopRefresh)
        # the Routine "smicket18test2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # ------Prepare to start Routine "blicketfep21test2"-------
        continueRoutine = True
        # update component parameters for each repeat
        star_22.setFillColor('black')
        triange_10.setFillColor('black')
        cross_20.setFillColor('black')
        key_resp_blicketfep21_2.keys = []
        key_resp_blicketfep21_2.rt = []
        _key_resp_blicketfep21_2_allKeys = []
        # keep track of which components have finished
        blicketfep21test2Components = [dax9_corr2_10, star_22, triange_10, cross_20, key_resp_blicketfep21_2, option1_17, option2_17, option3_16]
        for thisComponent in blicketfep21test2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        blicketfep21test2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "blicketfep21test2"-------
        while continueRoutine:
            # get current time
            t = blicketfep21test2Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=blicketfep21test2Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *dax9_corr2_10* updates
            if dax9_corr2_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                dax9_corr2_10.frameNStart = frameN  # exact frame index
                dax9_corr2_10.tStart = t  # local t and not account for scr refresh
                dax9_corr2_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(dax9_corr2_10, 'tStartRefresh')  # time at next scr refresh
                dax9_corr2_10.setAutoDraw(True)
            
            # *star_22* updates
            if star_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                star_22.frameNStart = frameN  # exact frame index
                star_22.tStart = t  # local t and not account for scr refresh
                star_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(star_22, 'tStartRefresh')  # time at next scr refresh
                star_22.setAutoDraw(True)
            
            # *triange_10* updates
            if triange_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                triange_10.frameNStart = frameN  # exact frame index
                triange_10.tStart = t  # local t and not account for scr refresh
                triange_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(triange_10, 'tStartRefresh')  # time at next scr refresh
                triange_10.setAutoDraw(True)
            
            # *cross_20* updates
            if cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cross_20.frameNStart = frameN  # exact frame index
                cross_20.tStart = t  # local t and not account for scr refresh
                cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cross_20, 'tStartRefresh')  # time at next scr refresh
                cross_20.setAutoDraw(True)
            
            # *key_resp_blicketfep21_2* updates
            waitOnFlip = False
            if key_resp_blicketfep21_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_blicketfep21_2.frameNStart = frameN  # exact frame index
                key_resp_blicketfep21_2.tStart = t  # local t and not account for scr refresh
                key_resp_blicketfep21_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_blicketfep21_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_blicketfep21_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_blicketfep21_2.clock.reset)  # t=0 on next screen flip
            if key_resp_blicketfep21_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_blicketfep21_2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
                _key_resp_blicketfep21_2_allKeys.extend(theseKeys)
                if len(_key_resp_blicketfep21_2_allKeys):
                    key_resp_blicketfep21_2.keys = _key_resp_blicketfep21_2_allKeys[-1].name  # just the last key pressed
                    key_resp_blicketfep21_2.rt = _key_resp_blicketfep21_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_blicketfep21_2.keys == str('3')) or (key_resp_blicketfep21_2.keys == '3'):
                        key_resp_blicketfep21_2.corr = 1
                    else:
                        key_resp_blicketfep21_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *option1_17* updates
            if option1_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_17.frameNStart = frameN  # exact frame index
                option1_17.tStart = t  # local t and not account for scr refresh
                option1_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_17, 'tStartRefresh')  # time at next scr refresh
                option1_17.setAutoDraw(True)
            
            # *option2_17* updates
            if option2_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_17.frameNStart = frameN  # exact frame index
                option2_17.tStart = t  # local t and not account for scr refresh
                option2_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_17, 'tStartRefresh')  # time at next scr refresh
                option2_17.setAutoDraw(True)
            
            # *option3_16* updates
            if option3_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option3_16.frameNStart = frameN  # exact frame index
                option3_16.tStart = t  # local t and not account for scr refresh
                option3_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option3_16, 'tStartRefresh')  # time at next scr refresh
                option3_16.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in blicketfep21test2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "blicketfep21test2"-------
        for thisComponent in blicketfep21test2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_blicketfep21_2.corr: 
            number_correct2 = number_correct2 + 1
            print('Correct2: ' + str(number_correct2))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct2 == 5:
            print('total Correct2: ' + str(number_correct2))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase_2.finished = True
        else:
            print('flag2!')
            trials_phase_2.finished = False
        trials_test2.addData('dax9_corr2_10.started', dax9_corr2_10.tStartRefresh)
        trials_test2.addData('dax9_corr2_10.stopped', dax9_corr2_10.tStopRefresh)
        trials_test2.addData('star_22.started', star_22.tStartRefresh)
        trials_test2.addData('star_22.stopped', star_22.tStopRefresh)
        trials_test2.addData('triange_10.started', triange_10.tStartRefresh)
        trials_test2.addData('triange_10.stopped', triange_10.tStopRefresh)
        trials_test2.addData('cross_20.started', cross_20.tStartRefresh)
        trials_test2.addData('cross_20.stopped', cross_20.tStopRefresh)
        # check responses
        if key_resp_blicketfep21_2.keys in ['', [], None]:  # No response was made
            key_resp_blicketfep21_2.keys = None
            # was no response the correct answer?!
            if str('3').lower() == 'none':
               key_resp_blicketfep21_2.corr = 1;  # correct non-response
            else:
               key_resp_blicketfep21_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test2 (TrialHandler)
        trials_test2.addData('key_resp_blicketfep21_2.keys',key_resp_blicketfep21_2.keys)
        trials_test2.addData('key_resp_blicketfep21_2.corr', key_resp_blicketfep21_2.corr)
        if key_resp_blicketfep21_2.keys != None:  # we had a response
            trials_test2.addData('key_resp_blicketfep21_2.rt', key_resp_blicketfep21_2.rt)
        trials_test2.addData('key_resp_blicketfep21_2.started', key_resp_blicketfep21_2.tStartRefresh)
        trials_test2.addData('key_resp_blicketfep21_2.stopped', key_resp_blicketfep21_2.tStopRefresh)
        trials_test2.addData('option1_17.started', option1_17.tStartRefresh)
        trials_test2.addData('option1_17.stopped', option1_17.tStopRefresh)
        trials_test2.addData('option2_17.started', option2_17.tStartRefresh)
        trials_test2.addData('option2_17.stopped', option2_17.tStopRefresh)
        trials_test2.addData('option3_16.started', option3_16.tStartRefresh)
        trials_test2.addData('option3_16.stopped', option3_16.tStopRefresh)
        # the Routine "blicketfep21test2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # ------Prepare to start Routine "smicketfep27test2"-------
        continueRoutine = True
        # update component parameters for each repeat
        star_23.setFillColor('white')
        triange_11.setFillColor('white')
        cross_21.setFillColor('white')
        key_resp_smicketfep27_2.keys = []
        key_resp_smicketfep27_2.rt = []
        _key_resp_smicketfep27_2_allKeys = []
        # keep track of which components have finished
        smicketfep27test2Components = [dax9_corr2_11, star_23, triange_11, cross_21, key_resp_smicketfep27_2, option1_18, option2_18, option3_17]
        for thisComponent in smicketfep27test2Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        smicketfep27test2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "smicketfep27test2"-------
        while continueRoutine:
            # get current time
            t = smicketfep27test2Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=smicketfep27test2Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *dax9_corr2_11* updates
            if dax9_corr2_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                dax9_corr2_11.frameNStart = frameN  # exact frame index
                dax9_corr2_11.tStart = t  # local t and not account for scr refresh
                dax9_corr2_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(dax9_corr2_11, 'tStartRefresh')  # time at next scr refresh
                dax9_corr2_11.setAutoDraw(True)
            
            # *star_23* updates
            if star_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                star_23.frameNStart = frameN  # exact frame index
                star_23.tStart = t  # local t and not account for scr refresh
                star_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(star_23, 'tStartRefresh')  # time at next scr refresh
                star_23.setAutoDraw(True)
            
            # *triange_11* updates
            if triange_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                triange_11.frameNStart = frameN  # exact frame index
                triange_11.tStart = t  # local t and not account for scr refresh
                triange_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(triange_11, 'tStartRefresh')  # time at next scr refresh
                triange_11.setAutoDraw(True)
            
            # *cross_21* updates
            if cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cross_21.frameNStart = frameN  # exact frame index
                cross_21.tStart = t  # local t and not account for scr refresh
                cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cross_21, 'tStartRefresh')  # time at next scr refresh
                cross_21.setAutoDraw(True)
            
            # *key_resp_smicketfep27_2* updates
            waitOnFlip = False
            if key_resp_smicketfep27_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_smicketfep27_2.frameNStart = frameN  # exact frame index
                key_resp_smicketfep27_2.tStart = t  # local t and not account for scr refresh
                key_resp_smicketfep27_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_smicketfep27_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_smicketfep27_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_smicketfep27_2.clock.reset)  # t=0 on next screen flip
            if key_resp_smicketfep27_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_smicketfep27_2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
                _key_resp_smicketfep27_2_allKeys.extend(theseKeys)
                if len(_key_resp_smicketfep27_2_allKeys):
                    key_resp_smicketfep27_2.keys = _key_resp_smicketfep27_2_allKeys[-1].name  # just the last key pressed
                    key_resp_smicketfep27_2.rt = _key_resp_smicketfep27_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_smicketfep27_2.keys == str('3')) or (key_resp_smicketfep27_2.keys == '3'):
                        key_resp_smicketfep27_2.corr = 1
                    else:
                        key_resp_smicketfep27_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *option1_18* updates
            if option1_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_18.frameNStart = frameN  # exact frame index
                option1_18.tStart = t  # local t and not account for scr refresh
                option1_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_18, 'tStartRefresh')  # time at next scr refresh
                option1_18.setAutoDraw(True)
            
            # *option2_18* updates
            if option2_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_18.frameNStart = frameN  # exact frame index
                option2_18.tStart = t  # local t and not account for scr refresh
                option2_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_18, 'tStartRefresh')  # time at next scr refresh
                option2_18.setAutoDraw(True)
            
            # *option3_17* updates
            if option3_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option3_17.frameNStart = frameN  # exact frame index
                option3_17.tStart = t  # local t and not account for scr refresh
                option3_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option3_17, 'tStartRefresh')  # time at next scr refresh
                option3_17.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in smicketfep27test2Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "smicketfep27test2"-------
        for thisComponent in smicketfep27test2Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_smicketfep27_2.corr: 
            number_correct2 = number_correct2 + 1
            print('Correct2: ' + str(number_correct2))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct2 == 5:
            print('total Correct2: ' + str(number_correct2))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase_2.finished = True
        else:
            print('flag2!')
            trials_phase_2.finished = False
        trials_test2.addData('dax9_corr2_11.started', dax9_corr2_11.tStartRefresh)
        trials_test2.addData('dax9_corr2_11.stopped', dax9_corr2_11.tStopRefresh)
        trials_test2.addData('star_23.started', star_23.tStartRefresh)
        trials_test2.addData('star_23.stopped', star_23.tStopRefresh)
        trials_test2.addData('triange_11.started', triange_11.tStartRefresh)
        trials_test2.addData('triange_11.stopped', triange_11.tStopRefresh)
        trials_test2.addData('cross_21.started', cross_21.tStartRefresh)
        trials_test2.addData('cross_21.stopped', cross_21.tStopRefresh)
        # check responses
        if key_resp_smicketfep27_2.keys in ['', [], None]:  # No response was made
            key_resp_smicketfep27_2.keys = None
            # was no response the correct answer?!
            if str('3').lower() == 'none':
               key_resp_smicketfep27_2.corr = 1;  # correct non-response
            else:
               key_resp_smicketfep27_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test2 (TrialHandler)
        trials_test2.addData('key_resp_smicketfep27_2.keys',key_resp_smicketfep27_2.keys)
        trials_test2.addData('key_resp_smicketfep27_2.corr', key_resp_smicketfep27_2.corr)
        if key_resp_smicketfep27_2.keys != None:  # we had a response
            trials_test2.addData('key_resp_smicketfep27_2.rt', key_resp_smicketfep27_2.rt)
        trials_test2.addData('key_resp_smicketfep27_2.started', key_resp_smicketfep27_2.tStartRefresh)
        trials_test2.addData('key_resp_smicketfep27_2.stopped', key_resp_smicketfep27_2.tStopRefresh)
        trials_test2.addData('option1_18.started', option1_18.tStartRefresh)
        trials_test2.addData('option1_18.stopped', option1_18.tStopRefresh)
        trials_test2.addData('option2_18.started', option2_18.tStartRefresh)
        trials_test2.addData('option2_18.stopped', option2_18.tStopRefresh)
        trials_test2.addData('option3_17.started', option3_17.tStartRefresh)
        trials_test2.addData('option3_17.stopped', option3_17.tStopRefresh)
        # the Routine "smicketfep27test2" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_test2'
    
    thisExp.nextEntry()
    
# completed 4.0 repeats of 'trials_phase_2'


# ------Prepare to start Routine "proceed"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_6.keys = []
key_resp_6.rt = []
_key_resp_6_allKeys = []
# keep track of which components have finished
proceedComponents = [text2, key_resp_6]
for thisComponent in proceedComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
proceedClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "proceed"-------
while continueRoutine:
    # get current time
    t = proceedClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=proceedClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text2* updates
    if text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text2.frameNStart = frameN  # exact frame index
        text2.tStart = t  # local t and not account for scr refresh
        text2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text2, 'tStartRefresh')  # time at next scr refresh
        text2.setAutoDraw(True)
    
    # *key_resp_6* updates
    waitOnFlip = False
    if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_6.frameNStart = frameN  # exact frame index
        key_resp_6.tStart = t  # local t and not account for scr refresh
        key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
        key_resp_6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_6.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_6_allKeys.extend(theseKeys)
        if len(_key_resp_6_allKeys):
            key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
            key_resp_6.rt = _key_resp_6_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in proceedComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "proceed"-------
for thisComponent in proceedComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text2.started', text2.tStartRefresh)
thisExp.addData('text2.stopped', text2.tStopRefresh)
# check responses
if key_resp_6.keys in ['', [], None]:  # No response was made
    key_resp_6.keys = None
thisExp.addData('key_resp_6.keys',key_resp_6.keys)
if key_resp_6.keys != None:  # we had a response
    thisExp.addData('key_resp_6.rt', key_resp_6.rt)
thisExp.addData('key_resp_6.started', key_resp_6.tStartRefresh)
thisExp.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
thisExp.nextEntry()
# the Routine "proceed" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "blank"-------
continueRoutine = True
routineTimer.add(0.200000)
# update component parameters for each repeat
# keep track of which components have finished
blankComponents = [blank500ms]
for thisComponent in blankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
blankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = blankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=blankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *blank500ms* updates
    if blank500ms.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        blank500ms.frameNStart = frameN  # exact frame index
        blank500ms.tStart = t  # local t and not account for scr refresh
        blank500ms.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(blank500ms, 'tStartRefresh')  # time at next scr refresh
        blank500ms.setAutoDraw(True)
    if blank500ms.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > blank500ms.tStartRefresh + 0.2-frameTolerance:
            # keep track of stop time/frame for later
            blank500ms.tStop = t  # not accounting for scr refresh
            blank500ms.frameNStop = frameN  # exact frame index
            win.timeOnFlip(blank500ms, 'tStopRefresh')  # time at next scr refresh
            blank500ms.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in blankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "blank"-------
for thisComponent in blankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('blank500ms.started', blank500ms.tStartRefresh)
thisExp.addData('blank500ms.stopped', blank500ms.tStopRefresh)

# ------Prepare to start Routine "test"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_t1_3.keys = []
key_resp_t1_3.rt = []
_key_resp_t1_3_allKeys = []
t1_triangle1_3.setFillColor('black')
t1_rectangle1_3.setFillColor('black')
# keep track of which components have finished
testComponents = [key_resp_t1_3, t1_zud_3, t1_triangle1_3, t1_rectangle1_3, option1_critical_13, option2_critical_13]
for thisComponent in testComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
testClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "test"-------
while continueRoutine:
    # get current time
    t = testClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=testClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *key_resp_t1_3* updates
    waitOnFlip = False
    if key_resp_t1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_t1_3.frameNStart = frameN  # exact frame index
        key_resp_t1_3.tStart = t  # local t and not account for scr refresh
        key_resp_t1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_t1_3, 'tStartRefresh')  # time at next scr refresh
        key_resp_t1_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_t1_3.clock.reset)  # t=0 on next screen flip
    if key_resp_t1_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_t1_3.getKeys(keyList=['1', '2'], waitRelease=False)
        _key_resp_t1_3_allKeys.extend(theseKeys)
        if len(_key_resp_t1_3_allKeys):
            key_resp_t1_3.keys = _key_resp_t1_3_allKeys[-1].name  # just the last key pressed
            key_resp_t1_3.rt = _key_resp_t1_3_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *t1_zud_3* updates
    if t1_zud_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_zud_3.frameNStart = frameN  # exact frame index
        t1_zud_3.tStart = t  # local t and not account for scr refresh
        t1_zud_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_zud_3, 'tStartRefresh')  # time at next scr refresh
        t1_zud_3.setAutoDraw(True)
    
    # *t1_triangle1_3* updates
    if t1_triangle1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_triangle1_3.frameNStart = frameN  # exact frame index
        t1_triangle1_3.tStart = t  # local t and not account for scr refresh
        t1_triangle1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_triangle1_3, 'tStartRefresh')  # time at next scr refresh
        t1_triangle1_3.setAutoDraw(True)
    
    # *t1_rectangle1_3* updates
    if t1_rectangle1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_rectangle1_3.frameNStart = frameN  # exact frame index
        t1_rectangle1_3.tStart = t  # local t and not account for scr refresh
        t1_rectangle1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_rectangle1_3, 'tStartRefresh')  # time at next scr refresh
        t1_rectangle1_3.setAutoDraw(True)
    
    # *option1_critical_13* updates
    if option1_critical_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option1_critical_13.frameNStart = frameN  # exact frame index
        option1_critical_13.tStart = t  # local t and not account for scr refresh
        option1_critical_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option1_critical_13, 'tStartRefresh')  # time at next scr refresh
        option1_critical_13.setAutoDraw(True)
    
    # *option2_critical_13* updates
    if option2_critical_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option2_critical_13.frameNStart = frameN  # exact frame index
        option2_critical_13.tStart = t  # local t and not account for scr refresh
        option2_critical_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option2_critical_13, 'tStartRefresh')  # time at next scr refresh
        option2_critical_13.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in testComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "test"-------
for thisComponent in testComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if key_resp_t1_3.keys in ['', [], None]:  # No response was made
    key_resp_t1_3.keys = None
thisExp.addData('key_resp_t1_3.keys',key_resp_t1_3.keys)
if key_resp_t1_3.keys != None:  # we had a response
    thisExp.addData('key_resp_t1_3.rt', key_resp_t1_3.rt)
thisExp.addData('key_resp_t1_3.started', key_resp_t1_3.tStartRefresh)
thisExp.addData('key_resp_t1_3.stopped', key_resp_t1_3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('t1_zud_3.started', t1_zud_3.tStartRefresh)
thisExp.addData('t1_zud_3.stopped', t1_zud_3.tStopRefresh)
thisExp.addData('t1_triangle1_3.started', t1_triangle1_3.tStartRefresh)
thisExp.addData('t1_triangle1_3.stopped', t1_triangle1_3.tStopRefresh)
thisExp.addData('t1_rectangle1_3.started', t1_rectangle1_3.tStartRefresh)
thisExp.addData('t1_rectangle1_3.stopped', t1_rectangle1_3.tStopRefresh)
thisExp.addData('option1_critical_13.started', option1_critical_13.tStartRefresh)
thisExp.addData('option1_critical_13.stopped', option1_critical_13.tStopRefresh)
thisExp.addData('option2_critical_13.started', option2_critical_13.tStartRefresh)
thisExp.addData('option2_critical_13.stopped', option2_critical_13.tStopRefresh)
# the Routine "test" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "phase3"-------
continueRoutine = True
routineTimer.add(2.000000)
# update component parameters for each repeat
p3.setText('Phase 3')
# keep track of which components have finished
phase3Components = [p3]
for thisComponent in phase3Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
phase3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "phase3"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = phase3Clock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=phase3Clock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *p3* updates
    if p3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        p3.frameNStart = frameN  # exact frame index
        p3.tStart = t  # local t and not account for scr refresh
        p3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(p3, 'tStartRefresh')  # time at next scr refresh
        p3.setAutoDraw(True)
    if p3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > p3.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            p3.tStop = t  # not accounting for scr refresh
            p3.frameNStop = frameN  # exact frame index
            win.timeOnFlip(p3, 'tStopRefresh')  # time at next scr refresh
            p3.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in phase3Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "phase3"-------
for thisComponent in phase3Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('p3.started', p3.tStartRefresh)
thisExp.addData('p3.stopped', p3.tStopRefresh)

# set up handler to look after randomisation of conditions etc
trials_phase3 = data.TrialHandler(nReps=4.0, method='sequential', 
    extraInfo=expInfo, originPath=-1,
    trialList=[None],
    seed=None, name='trials_phase3')
thisExp.addLoop(trials_phase3)  # add the loop to the experiment
thisTrials_phase3 = trials_phase3.trialList[0]  # so we can initialise stimuli with some values
# abbreviate parameter names if possible (e.g. rgb = thisTrials_phase3.rgb)
if thisTrials_phase3 != None:
    for paramName in thisTrials_phase3:
        exec('{} = thisTrials_phase3[paramName]'.format(paramName))

for thisTrials_phase3 in trials_phase3:
    currentLoop = trials_phase3
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_phase3.rgb)
    if thisTrials_phase3 != None:
        for paramName in thisTrials_phase3:
            exec('{} = thisTrials_phase3[paramName]'.format(paramName))
    
    # ------Prepare to start Routine "start_2"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # keep track of which components have finished
    start_2Components = [text1, key_resp_7]
    for thisComponent in start_2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    start_2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "start_2"-------
    while continueRoutine:
        # get current time
        t = start_2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=start_2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text1* updates
        if text1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text1.frameNStart = frameN  # exact frame index
            text1.tStart = t  # local t and not account for scr refresh
            text1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text1, 'tStartRefresh')  # time at next scr refresh
            text1.setAutoDraw(True)
        
        # *key_resp_7* updates
        waitOnFlip = False
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in start_2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "start_2"-------
    for thisComponent in start_2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('text1.started', text1.tStartRefresh)
    trials_phase3.addData('text1.stopped', text1.tStopRefresh)
    # check responses
    if key_resp_7.keys in ['', [], None]:  # No response was made
        key_resp_7.keys = None
    trials_phase3.addData('key_resp_7.keys',key_resp_7.keys)
    if key_resp_7.keys != None:  # we had a response
        trials_phase3.addData('key_resp_7.rt', key_resp_7.rt)
    trials_phase3.addData('key_resp_7.started', key_resp_7.tStartRefresh)
    trials_phase3.addData('key_resp_7.stopped', key_resp_7.tStopRefresh)
    # the Routine "start_2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "zud1"-------
    continueRoutine = True
    # update component parameters for each repeat
    number_correct=0
    star_1.setFillColor('black')
    triangle_1.setFillColor('black')
    cross_1.setFillColor('black')
    key_resp_zud1.keys = []
    key_resp_zud1.rt = []
    _key_resp_zud1_allKeys = []
    # keep track of which components have finished
    zud1Components = [zud1_corr2, star_1, triangle_1, cross_1, option1_01, option2_01, option3_01, key_resp_zud1]
    for thisComponent in zud1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud1"-------
    while continueRoutine:
        # get current time
        t = zud1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud1_corr2* updates
        if zud1_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud1_corr2.frameNStart = frameN  # exact frame index
            zud1_corr2.tStart = t  # local t and not account for scr refresh
            zud1_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud1_corr2, 'tStartRefresh')  # time at next scr refresh
            zud1_corr2.setAutoDraw(True)
        
        # *star_1* updates
        if star_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_1.frameNStart = frameN  # exact frame index
            star_1.tStart = t  # local t and not account for scr refresh
            star_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_1, 'tStartRefresh')  # time at next scr refresh
            star_1.setAutoDraw(True)
        
        # *triangle_1* updates
        if triangle_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_1.frameNStart = frameN  # exact frame index
            triangle_1.tStart = t  # local t and not account for scr refresh
            triangle_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_1, 'tStartRefresh')  # time at next scr refresh
            triangle_1.setAutoDraw(True)
        
        # *cross_1* updates
        if cross_1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_1.frameNStart = frameN  # exact frame index
            cross_1.tStart = t  # local t and not account for scr refresh
            cross_1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_1, 'tStartRefresh')  # time at next scr refresh
            cross_1.setAutoDraw(True)
        
        # *option1_01* updates
        if option1_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_01.frameNStart = frameN  # exact frame index
            option1_01.tStart = t  # local t and not account for scr refresh
            option1_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_01, 'tStartRefresh')  # time at next scr refresh
            option1_01.setAutoDraw(True)
        
        # *option2_01* updates
        if option2_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_01.frameNStart = frameN  # exact frame index
            option2_01.tStart = t  # local t and not account for scr refresh
            option2_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_01, 'tStartRefresh')  # time at next scr refresh
            option2_01.setAutoDraw(True)
        
        # *option3_01* updates
        if option3_01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_01.frameNStart = frameN  # exact frame index
            option3_01.tStart = t  # local t and not account for scr refresh
            option3_01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_01, 'tStartRefresh')  # time at next scr refresh
            option3_01.setAutoDraw(True)
        
        # *key_resp_zud1* updates
        waitOnFlip = False
        if key_resp_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud1.frameNStart = frameN  # exact frame index
            key_resp_zud1.tStart = t  # local t and not account for scr refresh
            key_resp_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud1, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud1.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud1.clock.reset)  # t=0 on next screen flip
        if key_resp_zud1.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud1.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud1_allKeys.extend(theseKeys)
            if len(_key_resp_zud1_allKeys):
                key_resp_zud1.keys = _key_resp_zud1_allKeys[-1].name  # just the last key pressed
                key_resp_zud1.rt = _key_resp_zud1_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud1.keys == str('2')) or (key_resp_zud1.keys == '2'):
                    key_resp_zud1.corr = 1
                else:
                    key_resp_zud1.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud1"-------
    for thisComponent in zud1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud1_corr2.started', zud1_corr2.tStartRefresh)
    trials_phase3.addData('zud1_corr2.stopped', zud1_corr2.tStopRefresh)
    number_correct = number_correct + 1
    
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase3.addData('star_1.started', star_1.tStartRefresh)
    trials_phase3.addData('star_1.stopped', star_1.tStopRefresh)
    trials_phase3.addData('triangle_1.started', triangle_1.tStartRefresh)
    trials_phase3.addData('triangle_1.stopped', triangle_1.tStopRefresh)
    trials_phase3.addData('cross_1.started', cross_1.tStartRefresh)
    trials_phase3.addData('cross_1.stopped', cross_1.tStopRefresh)
    trials_phase3.addData('option1_01.started', option1_01.tStartRefresh)
    trials_phase3.addData('option1_01.stopped', option1_01.tStopRefresh)
    trials_phase3.addData('option2_01.started', option2_01.tStartRefresh)
    trials_phase3.addData('option2_01.stopped', option2_01.tStopRefresh)
    trials_phase3.addData('option3_01.started', option3_01.tStartRefresh)
    trials_phase3.addData('option3_01.stopped', option3_01.tStopRefresh)
    # check responses
    if key_resp_zud1.keys in ['', [], None]:  # No response was made
        key_resp_zud1.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_zud1.corr = 1;  # correct non-response
        else:
           key_resp_zud1.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud1.keys',key_resp_zud1.keys)
    trials_phase3.addData('key_resp_zud1.corr', key_resp_zud1.corr)
    if key_resp_zud1.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud1.rt', key_resp_zud1.rt)
    trials_phase3.addData('key_resp_zud1.started', key_resp_zud1.tStartRefresh)
    trials_phase3.addData('key_resp_zud1.stopped', key_resp_zud1.tStopRefresh)
    # the Routine "zud1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud1"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud1.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud1.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud1.setText(msg1)
    feedback0_zud1.setText(msg0)
    feedback_zud01.setText(msg)
    # keep track of which components have finished
    fb_zud1Components = [feedback1_zud1, feedback0_zud1, feedback_zud01]
    for thisComponent in fb_zud1Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud1Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud1"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud1Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud1Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud1* updates
        if feedback1_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud1.frameNStart = frameN  # exact frame index
            feedback1_zud1.tStart = t  # local t and not account for scr refresh
            feedback1_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud1, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud1.setAutoDraw(True)
        if feedback1_zud1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud1.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud1.tStop = t  # not accounting for scr refresh
                feedback1_zud1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud1, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud1.setAutoDraw(False)
        
        # *feedback0_zud1* updates
        if feedback0_zud1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud1.frameNStart = frameN  # exact frame index
            feedback0_zud1.tStart = t  # local t and not account for scr refresh
            feedback0_zud1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud1, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud1.setAutoDraw(True)
        if feedback0_zud1.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud1.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud1.tStop = t  # not accounting for scr refresh
                feedback0_zud1.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud1, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud1.setAutoDraw(False)
        
        # *feedback_zud01* updates
        if feedback_zud01.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud01.frameNStart = frameN  # exact frame index
            feedback_zud01.tStart = t  # local t and not account for scr refresh
            feedback_zud01.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud01, 'tStartRefresh')  # time at next scr refresh
            feedback_zud01.setAutoDraw(True)
        if feedback_zud01.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud01.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud01.tStop = t  # not accounting for scr refresh
                feedback_zud01.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud01, 'tStopRefresh')  # time at next scr refresh
                feedback_zud01.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud1Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud1"-------
    for thisComponent in fb_zud1Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud1.started', feedback1_zud1.tStartRefresh)
    trials_phase3.addData('feedback1_zud1.stopped', feedback1_zud1.tStopRefresh)
    trials_phase3.addData('feedback0_zud1.started', feedback0_zud1.tStartRefresh)
    trials_phase3.addData('feedback0_zud1.stopped', feedback0_zud1.tStopRefresh)
    trials_phase3.addData('feedback_zud01.started', feedback_zud01.tStartRefresh)
    trials_phase3.addData('feedback_zud01.stopped', feedback_zud01.tStopRefresh)
    
    # ------Prepare to start Routine "zud2"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_2.setFillColor('black')
    star_2.setFillColor('black')
    cross_2.setFillColor('black')
    key_resp_zud2.keys = []
    key_resp_zud2.rt = []
    _key_resp_zud2_allKeys = []
    # keep track of which components have finished
    zud2Components = [zud2_corr1, triangle_2, star_2, cross_2, key_resp_zud2, option1_02, option2_02, option3_02]
    for thisComponent in zud2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud2"-------
    while continueRoutine:
        # get current time
        t = zud2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud2_corr1* updates
        if zud2_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud2_corr1.frameNStart = frameN  # exact frame index
            zud2_corr1.tStart = t  # local t and not account for scr refresh
            zud2_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud2_corr1, 'tStartRefresh')  # time at next scr refresh
            zud2_corr1.setAutoDraw(True)
        
        # *triangle_2* updates
        if triangle_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_2.frameNStart = frameN  # exact frame index
            triangle_2.tStart = t  # local t and not account for scr refresh
            triangle_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_2, 'tStartRefresh')  # time at next scr refresh
            triangle_2.setAutoDraw(True)
        
        # *star_2* updates
        if star_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_2.frameNStart = frameN  # exact frame index
            star_2.tStart = t  # local t and not account for scr refresh
            star_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_2, 'tStartRefresh')  # time at next scr refresh
            star_2.setAutoDraw(True)
        
        # *cross_2* updates
        if cross_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_2.frameNStart = frameN  # exact frame index
            cross_2.tStart = t  # local t and not account for scr refresh
            cross_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_2, 'tStartRefresh')  # time at next scr refresh
            cross_2.setAutoDraw(True)
        
        # *key_resp_zud2* updates
        waitOnFlip = False
        if key_resp_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud2.frameNStart = frameN  # exact frame index
            key_resp_zud2.tStart = t  # local t and not account for scr refresh
            key_resp_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud2, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud2.clock.reset)  # t=0 on next screen flip
        if key_resp_zud2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud2_allKeys.extend(theseKeys)
            if len(_key_resp_zud2_allKeys):
                key_resp_zud2.keys = _key_resp_zud2_allKeys[-1].name  # just the last key pressed
                key_resp_zud2.rt = _key_resp_zud2_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud2.keys == str('1')) or (key_resp_zud2.keys == '1'):
                    key_resp_zud2.corr = 1
                else:
                    key_resp_zud2.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_02* updates
        if option1_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_02.frameNStart = frameN  # exact frame index
            option1_02.tStart = t  # local t and not account for scr refresh
            option1_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_02, 'tStartRefresh')  # time at next scr refresh
            option1_02.setAutoDraw(True)
        
        # *option2_02* updates
        if option2_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_02.frameNStart = frameN  # exact frame index
            option2_02.tStart = t  # local t and not account for scr refresh
            option2_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_02, 'tStartRefresh')  # time at next scr refresh
            option2_02.setAutoDraw(True)
        
        # *option3_02* updates
        if option3_02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_02.frameNStart = frameN  # exact frame index
            option3_02.tStart = t  # local t and not account for scr refresh
            option3_02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_02, 'tStartRefresh')  # time at next scr refresh
            option3_02.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud2"-------
    for thisComponent in zud2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud2_corr1.started', zud2_corr1.tStartRefresh)
    trials_phase3.addData('zud2_corr1.stopped', zud2_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase3.addData('triangle_2.started', triangle_2.tStartRefresh)
    trials_phase3.addData('triangle_2.stopped', triangle_2.tStopRefresh)
    trials_phase3.addData('star_2.started', star_2.tStartRefresh)
    trials_phase3.addData('star_2.stopped', star_2.tStopRefresh)
    trials_phase3.addData('cross_2.started', cross_2.tStartRefresh)
    trials_phase3.addData('cross_2.stopped', cross_2.tStopRefresh)
    # check responses
    if key_resp_zud2.keys in ['', [], None]:  # No response was made
        key_resp_zud2.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud2.corr = 1;  # correct non-response
        else:
           key_resp_zud2.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud2.keys',key_resp_zud2.keys)
    trials_phase3.addData('key_resp_zud2.corr', key_resp_zud2.corr)
    if key_resp_zud2.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud2.rt', key_resp_zud2.rt)
    trials_phase3.addData('key_resp_zud2.started', key_resp_zud2.tStartRefresh)
    trials_phase3.addData('key_resp_zud2.stopped', key_resp_zud2.tStopRefresh)
    trials_phase3.addData('option1_02.started', option1_02.tStartRefresh)
    trials_phase3.addData('option1_02.stopped', option1_02.tStopRefresh)
    trials_phase3.addData('option2_02.started', option2_02.tStartRefresh)
    trials_phase3.addData('option2_02.stopped', option2_02.tStopRefresh)
    trials_phase3.addData('option3_02.started', option3_02.tStartRefresh)
    trials_phase3.addData('option3_02.stopped', option3_02.tStopRefresh)
    # the Routine "zud2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud2"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud2.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud2.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud2.setText(msg1)
    feedback0_zud2.setText(msg0)
    feedback_zud02.setText(msg)
    # keep track of which components have finished
    fb_zud2Components = [feedback1_zud2, feedback0_zud2, feedback_zud02]
    for thisComponent in fb_zud2Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud2Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud2"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud2Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud2Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud2* updates
        if feedback1_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud2.frameNStart = frameN  # exact frame index
            feedback1_zud2.tStart = t  # local t and not account for scr refresh
            feedback1_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud2, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud2.setAutoDraw(True)
        if feedback1_zud2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud2.tStop = t  # not accounting for scr refresh
                feedback1_zud2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud2, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud2.setAutoDraw(False)
        
        # *feedback0_zud2* updates
        if feedback0_zud2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud2.frameNStart = frameN  # exact frame index
            feedback0_zud2.tStart = t  # local t and not account for scr refresh
            feedback0_zud2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud2, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud2.setAutoDraw(True)
        if feedback0_zud2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud2.tStop = t  # not accounting for scr refresh
                feedback0_zud2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud2, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud2.setAutoDraw(False)
        
        # *feedback_zud02* updates
        if feedback_zud02.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud02.frameNStart = frameN  # exact frame index
            feedback_zud02.tStart = t  # local t and not account for scr refresh
            feedback_zud02.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud02, 'tStartRefresh')  # time at next scr refresh
            feedback_zud02.setAutoDraw(True)
        if feedback_zud02.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud02.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud02.tStop = t  # not accounting for scr refresh
                feedback_zud02.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud02, 'tStopRefresh')  # time at next scr refresh
                feedback_zud02.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud2Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud2"-------
    for thisComponent in fb_zud2Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud2.started', feedback1_zud2.tStartRefresh)
    trials_phase3.addData('feedback1_zud2.stopped', feedback1_zud2.tStopRefresh)
    trials_phase3.addData('feedback0_zud2.started', feedback0_zud2.tStartRefresh)
    trials_phase3.addData('feedback0_zud2.stopped', feedback0_zud2.tStopRefresh)
    trials_phase3.addData('feedback_zud02.started', feedback_zud02.tStartRefresh)
    trials_phase3.addData('feedback_zud02.stopped', feedback_zud02.tStopRefresh)
    
    # ------Prepare to start Routine "zud3"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_3.setFillColor('white')
    star_3.setFillColor('white')
    cross_3.setFillColor('white')
    key_resp_zud3.keys = []
    key_resp_zud3.rt = []
    _key_resp_zud3_allKeys = []
    # keep track of which components have finished
    zud3Components = [zud3_corr1, triangle_3, star_3, cross_3, key_resp_zud3, option1_03, option2_03, option3_03]
    for thisComponent in zud3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud3"-------
    while continueRoutine:
        # get current time
        t = zud3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud3_corr1* updates
        if zud3_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud3_corr1.frameNStart = frameN  # exact frame index
            zud3_corr1.tStart = t  # local t and not account for scr refresh
            zud3_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud3_corr1, 'tStartRefresh')  # time at next scr refresh
            zud3_corr1.setAutoDraw(True)
        
        # *triangle_3* updates
        if triangle_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_3.frameNStart = frameN  # exact frame index
            triangle_3.tStart = t  # local t and not account for scr refresh
            triangle_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_3, 'tStartRefresh')  # time at next scr refresh
            triangle_3.setAutoDraw(True)
        
        # *star_3* updates
        if star_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_3.frameNStart = frameN  # exact frame index
            star_3.tStart = t  # local t and not account for scr refresh
            star_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_3, 'tStartRefresh')  # time at next scr refresh
            star_3.setAutoDraw(True)
        
        # *cross_3* updates
        if cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_3.frameNStart = frameN  # exact frame index
            cross_3.tStart = t  # local t and not account for scr refresh
            cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_3, 'tStartRefresh')  # time at next scr refresh
            cross_3.setAutoDraw(True)
        
        # *key_resp_zud3* updates
        waitOnFlip = False
        if key_resp_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud3.frameNStart = frameN  # exact frame index
            key_resp_zud3.tStart = t  # local t and not account for scr refresh
            key_resp_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud3, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud3.clock.reset)  # t=0 on next screen flip
        if key_resp_zud3.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud3.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud3_allKeys.extend(theseKeys)
            if len(_key_resp_zud3_allKeys):
                key_resp_zud3.keys = _key_resp_zud3_allKeys[-1].name  # just the last key pressed
                key_resp_zud3.rt = _key_resp_zud3_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud3.keys == str('1')) or (key_resp_zud3.keys == '1'):
                    key_resp_zud3.corr = 1
                else:
                    key_resp_zud3.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_03* updates
        if option1_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_03.frameNStart = frameN  # exact frame index
            option1_03.tStart = t  # local t and not account for scr refresh
            option1_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_03, 'tStartRefresh')  # time at next scr refresh
            option1_03.setAutoDraw(True)
        
        # *option2_03* updates
        if option2_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_03.frameNStart = frameN  # exact frame index
            option2_03.tStart = t  # local t and not account for scr refresh
            option2_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_03, 'tStartRefresh')  # time at next scr refresh
            option2_03.setAutoDraw(True)
        
        # *option3_03* updates
        if option3_03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_03.frameNStart = frameN  # exact frame index
            option3_03.tStart = t  # local t and not account for scr refresh
            option3_03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_03, 'tStartRefresh')  # time at next scr refresh
            option3_03.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud3"-------
    for thisComponent in zud3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud3_corr1.started', zud3_corr1.tStartRefresh)
    trials_phase3.addData('zud3_corr1.stopped', zud3_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase3.addData('triangle_3.started', triangle_3.tStartRefresh)
    trials_phase3.addData('triangle_3.stopped', triangle_3.tStopRefresh)
    trials_phase3.addData('star_3.started', star_3.tStartRefresh)
    trials_phase3.addData('star_3.stopped', star_3.tStopRefresh)
    trials_phase3.addData('cross_3.started', cross_3.tStartRefresh)
    trials_phase3.addData('cross_3.stopped', cross_3.tStopRefresh)
    # check responses
    if key_resp_zud3.keys in ['', [], None]:  # No response was made
        key_resp_zud3.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud3.corr = 1;  # correct non-response
        else:
           key_resp_zud3.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud3.keys',key_resp_zud3.keys)
    trials_phase3.addData('key_resp_zud3.corr', key_resp_zud3.corr)
    if key_resp_zud3.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud3.rt', key_resp_zud3.rt)
    trials_phase3.addData('key_resp_zud3.started', key_resp_zud3.tStartRefresh)
    trials_phase3.addData('key_resp_zud3.stopped', key_resp_zud3.tStopRefresh)
    trials_phase3.addData('option1_03.started', option1_03.tStartRefresh)
    trials_phase3.addData('option1_03.stopped', option1_03.tStopRefresh)
    trials_phase3.addData('option2_03.started', option2_03.tStartRefresh)
    trials_phase3.addData('option2_03.stopped', option2_03.tStopRefresh)
    trials_phase3.addData('option3_03.started', option3_03.tStartRefresh)
    trials_phase3.addData('option3_03.stopped', option3_03.tStopRefresh)
    # the Routine "zud3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud3"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud3.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud3.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud3.setText(msg1)
    feedback0_zud3.setText(msg0)
    feedback_zud03.setText(msg)
    # keep track of which components have finished
    fb_zud3Components = [feedback1_zud3, feedback0_zud3, feedback_zud03]
    for thisComponent in fb_zud3Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud3Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud3"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud3Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud3Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud3* updates
        if feedback1_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud3.frameNStart = frameN  # exact frame index
            feedback1_zud3.tStart = t  # local t and not account for scr refresh
            feedback1_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud3, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud3.setAutoDraw(True)
        if feedback1_zud3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud3.tStop = t  # not accounting for scr refresh
                feedback1_zud3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud3, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud3.setAutoDraw(False)
        
        # *feedback0_zud3* updates
        if feedback0_zud3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud3.frameNStart = frameN  # exact frame index
            feedback0_zud3.tStart = t  # local t and not account for scr refresh
            feedback0_zud3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud3, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud3.setAutoDraw(True)
        if feedback0_zud3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud3.tStop = t  # not accounting for scr refresh
                feedback0_zud3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud3, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud3.setAutoDraw(False)
        
        # *feedback_zud03* updates
        if feedback_zud03.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud03.frameNStart = frameN  # exact frame index
            feedback_zud03.tStart = t  # local t and not account for scr refresh
            feedback_zud03.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud03, 'tStartRefresh')  # time at next scr refresh
            feedback_zud03.setAutoDraw(True)
        if feedback_zud03.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud03.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud03.tStop = t  # not accounting for scr refresh
                feedback_zud03.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud03, 'tStopRefresh')  # time at next scr refresh
                feedback_zud03.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud3Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud3"-------
    for thisComponent in fb_zud3Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud3.started', feedback1_zud3.tStartRefresh)
    trials_phase3.addData('feedback1_zud3.stopped', feedback1_zud3.tStopRefresh)
    trials_phase3.addData('feedback0_zud3.started', feedback0_zud3.tStartRefresh)
    trials_phase3.addData('feedback0_zud3.stopped', feedback0_zud3.tStopRefresh)
    trials_phase3.addData('feedback_zud03.started', feedback_zud03.tStartRefresh)
    trials_phase3.addData('feedback_zud03.stopped', feedback_zud03.tStopRefresh)
    
    # ------Prepare to start Routine "zud4"-------
    continueRoutine = True
    # update component parameters for each repeat
    triangle_4.setFillColor('white')
    star_4.setFillColor('white')
    cross_4.setFillColor('white')
    key_resp_zud4.keys = []
    key_resp_zud4.rt = []
    _key_resp_zud4_allKeys = []
    # keep track of which components have finished
    zud4Components = [zud4_corr1, triangle_4, star_4, cross_4, key_resp_zud4, option1_04, option2_04, option3_04]
    for thisComponent in zud4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud4"-------
    while continueRoutine:
        # get current time
        t = zud4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud4_corr1* updates
        if zud4_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud4_corr1.frameNStart = frameN  # exact frame index
            zud4_corr1.tStart = t  # local t and not account for scr refresh
            zud4_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud4_corr1, 'tStartRefresh')  # time at next scr refresh
            zud4_corr1.setAutoDraw(True)
        
        # *triangle_4* updates
        if triangle_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_4.frameNStart = frameN  # exact frame index
            triangle_4.tStart = t  # local t and not account for scr refresh
            triangle_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_4, 'tStartRefresh')  # time at next scr refresh
            triangle_4.setAutoDraw(True)
        
        # *star_4* updates
        if star_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_4.frameNStart = frameN  # exact frame index
            star_4.tStart = t  # local t and not account for scr refresh
            star_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_4, 'tStartRefresh')  # time at next scr refresh
            star_4.setAutoDraw(True)
        
        # *cross_4* updates
        if cross_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_4.frameNStart = frameN  # exact frame index
            cross_4.tStart = t  # local t and not account for scr refresh
            cross_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_4, 'tStartRefresh')  # time at next scr refresh
            cross_4.setAutoDraw(True)
        
        # *key_resp_zud4* updates
        waitOnFlip = False
        if key_resp_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud4.frameNStart = frameN  # exact frame index
            key_resp_zud4.tStart = t  # local t and not account for scr refresh
            key_resp_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud4, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud4.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud4.clock.reset)  # t=0 on next screen flip
        if key_resp_zud4.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud4.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud4_allKeys.extend(theseKeys)
            if len(_key_resp_zud4_allKeys):
                key_resp_zud4.keys = _key_resp_zud4_allKeys[-1].name  # just the last key pressed
                key_resp_zud4.rt = _key_resp_zud4_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud4.keys == str('1')) or (key_resp_zud4.keys == '1'):
                    key_resp_zud4.corr = 1
                else:
                    key_resp_zud4.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_04* updates
        if option1_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_04.frameNStart = frameN  # exact frame index
            option1_04.tStart = t  # local t and not account for scr refresh
            option1_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_04, 'tStartRefresh')  # time at next scr refresh
            option1_04.setAutoDraw(True)
        
        # *option2_04* updates
        if option2_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_04.frameNStart = frameN  # exact frame index
            option2_04.tStart = t  # local t and not account for scr refresh
            option2_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_04, 'tStartRefresh')  # time at next scr refresh
            option2_04.setAutoDraw(True)
        
        # *option3_04* updates
        if option3_04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_04.frameNStart = frameN  # exact frame index
            option3_04.tStart = t  # local t and not account for scr refresh
            option3_04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_04, 'tStartRefresh')  # time at next scr refresh
            option3_04.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud4"-------
    for thisComponent in zud4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud4_corr1.started', zud4_corr1.tStartRefresh)
    trials_phase3.addData('zud4_corr1.stopped', zud4_corr1.tStopRefresh)
    
    number_correct = number_correct + 1
    
    if number_correct == 12 : 
        print('total Correct: ' + str(number_correct))
        # ''' terminate the outer loop so no more practice happens:'''
        trials_phase1.finished = True
    else:
        print('flag!')
        trials_phase1.finished = False
    trials_phase3.addData('triangle_4.started', triangle_4.tStartRefresh)
    trials_phase3.addData('triangle_4.stopped', triangle_4.tStopRefresh)
    trials_phase3.addData('star_4.started', star_4.tStartRefresh)
    trials_phase3.addData('star_4.stopped', star_4.tStopRefresh)
    trials_phase3.addData('cross_4.started', cross_4.tStartRefresh)
    trials_phase3.addData('cross_4.stopped', cross_4.tStopRefresh)
    # check responses
    if key_resp_zud4.keys in ['', [], None]:  # No response was made
        key_resp_zud4.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud4.corr = 1;  # correct non-response
        else:
           key_resp_zud4.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud4.keys',key_resp_zud4.keys)
    trials_phase3.addData('key_resp_zud4.corr', key_resp_zud4.corr)
    if key_resp_zud4.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud4.rt', key_resp_zud4.rt)
    trials_phase3.addData('key_resp_zud4.started', key_resp_zud4.tStartRefresh)
    trials_phase3.addData('key_resp_zud4.stopped', key_resp_zud4.tStopRefresh)
    trials_phase3.addData('option1_04.started', option1_04.tStartRefresh)
    trials_phase3.addData('option1_04.stopped', option1_04.tStopRefresh)
    trials_phase3.addData('option2_04.started', option2_04.tStartRefresh)
    trials_phase3.addData('option2_04.stopped', option2_04.tStopRefresh)
    trials_phase3.addData('option3_04.started', option3_04.tStartRefresh)
    trials_phase3.addData('option3_04.stopped', option3_04.tStopRefresh)
    # the Routine "zud4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud4"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud4.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud4.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud4.setText(msg1)
    feedback0_zud4.setText(msg0)
    feedback_zud04.setText(msg)
    # keep track of which components have finished
    fb_zud4Components = [feedback1_zud4, feedback0_zud4, feedback_zud04]
    for thisComponent in fb_zud4Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud4Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud4"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud4Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud4Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud4* updates
        if feedback1_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud4.frameNStart = frameN  # exact frame index
            feedback1_zud4.tStart = t  # local t and not account for scr refresh
            feedback1_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud4, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud4.setAutoDraw(True)
        if feedback1_zud4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud4.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud4.tStop = t  # not accounting for scr refresh
                feedback1_zud4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud4, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud4.setAutoDraw(False)
        
        # *feedback0_zud4* updates
        if feedback0_zud4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud4.frameNStart = frameN  # exact frame index
            feedback0_zud4.tStart = t  # local t and not account for scr refresh
            feedback0_zud4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud4, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud4.setAutoDraw(True)
        if feedback0_zud4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud4.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud4.tStop = t  # not accounting for scr refresh
                feedback0_zud4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud4, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud4.setAutoDraw(False)
        
        # *feedback_zud04* updates
        if feedback_zud04.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud04.frameNStart = frameN  # exact frame index
            feedback_zud04.tStart = t  # local t and not account for scr refresh
            feedback_zud04.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud04, 'tStartRefresh')  # time at next scr refresh
            feedback_zud04.setAutoDraw(True)
        if feedback_zud04.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud04.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud04.tStop = t  # not accounting for scr refresh
                feedback_zud04.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud04, 'tStopRefresh')  # time at next scr refresh
                feedback_zud04.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud4Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud4"-------
    for thisComponent in fb_zud4Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud4.started', feedback1_zud4.tStartRefresh)
    trials_phase3.addData('feedback1_zud4.stopped', feedback1_zud4.tStopRefresh)
    trials_phase3.addData('feedback0_zud4.started', feedback0_zud4.tStartRefresh)
    trials_phase3.addData('feedback0_zud4.stopped', feedback0_zud4.tStopRefresh)
    trials_phase3.addData('feedback_zud04.started', feedback_zud04.tStartRefresh)
    trials_phase3.addData('feedback_zud04.stopped', feedback_zud04.tStopRefresh)
    
    # ------Prepare to start Routine "zud5"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud5.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_5.setFillColor('black')
    cross_5.setFillColor('black')
    rectangle_5.setFillColor('black')
    key_resp_zud5.keys = []
    key_resp_zud5.rt = []
    _key_resp_zud5_allKeys = []
    # keep track of which components have finished
    zud5Components = [zud5_corr3, star_5, cross_5, rectangle_5, key_resp_zud5, option1_05, option2_05, option3_05]
    for thisComponent in zud5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud5"-------
    while continueRoutine:
        # get current time
        t = zud5Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud5Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud5_corr3* updates
        if zud5_corr3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud5_corr3.frameNStart = frameN  # exact frame index
            zud5_corr3.tStart = t  # local t and not account for scr refresh
            zud5_corr3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud5_corr3, 'tStartRefresh')  # time at next scr refresh
            zud5_corr3.setAutoDraw(True)
        
        # *star_5* updates
        if star_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_5.frameNStart = frameN  # exact frame index
            star_5.tStart = t  # local t and not account for scr refresh
            star_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_5, 'tStartRefresh')  # time at next scr refresh
            star_5.setAutoDraw(True)
        
        # *cross_5* updates
        if cross_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_5.frameNStart = frameN  # exact frame index
            cross_5.tStart = t  # local t and not account for scr refresh
            cross_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_5, 'tStartRefresh')  # time at next scr refresh
            cross_5.setAutoDraw(True)
        
        # *rectangle_5* updates
        if rectangle_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_5.frameNStart = frameN  # exact frame index
            rectangle_5.tStart = t  # local t and not account for scr refresh
            rectangle_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_5, 'tStartRefresh')  # time at next scr refresh
            rectangle_5.setAutoDraw(True)
        
        # *key_resp_zud5* updates
        waitOnFlip = False
        if key_resp_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud5.frameNStart = frameN  # exact frame index
            key_resp_zud5.tStart = t  # local t and not account for scr refresh
            key_resp_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud5, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud5.clock.reset)  # t=0 on next screen flip
        if key_resp_zud5.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud5.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud5_allKeys.extend(theseKeys)
            if len(_key_resp_zud5_allKeys):
                key_resp_zud5.keys = _key_resp_zud5_allKeys[-1].name  # just the last key pressed
                key_resp_zud5.rt = _key_resp_zud5_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud5.keys == str('3')) or (key_resp_zud5.keys == '3'):
                    key_resp_zud5.corr = 1
                else:
                    key_resp_zud5.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_05* updates
        if option1_05.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_05.frameNStart = frameN  # exact frame index
            option1_05.tStart = t  # local t and not account for scr refresh
            option1_05.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_05, 'tStartRefresh')  # time at next scr refresh
            option1_05.setAutoDraw(True)
        
        # *option2_05* updates
        if option2_05.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_05.frameNStart = frameN  # exact frame index
            option2_05.tStart = t  # local t and not account for scr refresh
            option2_05.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_05, 'tStartRefresh')  # time at next scr refresh
            option2_05.setAutoDraw(True)
        
        # *option3_05* updates
        if option3_05.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_05.frameNStart = frameN  # exact frame index
            option3_05.tStart = t  # local t and not account for scr refresh
            option3_05.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_05, 'tStartRefresh')  # time at next scr refresh
            option3_05.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud5"-------
    for thisComponent in zud5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud5_corr3.started', zud5_corr3.tStartRefresh)
    trials_phase3.addData('zud5_corr3.stopped', zud5_corr3.tStopRefresh)
    trials_phase3.addData('star_5.started', star_5.tStartRefresh)
    trials_phase3.addData('star_5.stopped', star_5.tStopRefresh)
    trials_phase3.addData('cross_5.started', cross_5.tStartRefresh)
    trials_phase3.addData('cross_5.stopped', cross_5.tStopRefresh)
    trials_phase3.addData('rectangle_5.started', rectangle_5.tStartRefresh)
    trials_phase3.addData('rectangle_5.stopped', rectangle_5.tStopRefresh)
    # check responses
    if key_resp_zud5.keys in ['', [], None]:  # No response was made
        key_resp_zud5.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_zud5.corr = 1;  # correct non-response
        else:
           key_resp_zud5.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud5.keys',key_resp_zud5.keys)
    trials_phase3.addData('key_resp_zud5.corr', key_resp_zud5.corr)
    if key_resp_zud5.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud5.rt', key_resp_zud5.rt)
    trials_phase3.addData('key_resp_zud5.started', key_resp_zud5.tStartRefresh)
    trials_phase3.addData('key_resp_zud5.stopped', key_resp_zud5.tStopRefresh)
    trials_phase3.addData('option1_05.started', option1_05.tStartRefresh)
    trials_phase3.addData('option1_05.stopped', option1_05.tStopRefresh)
    trials_phase3.addData('option2_05.started', option2_05.tStartRefresh)
    trials_phase3.addData('option2_05.stopped', option2_05.tStopRefresh)
    trials_phase3.addData('option3_05.started', option3_05.tStartRefresh)
    trials_phase3.addData('option3_05.stopped', option3_05.tStopRefresh)
    # the Routine "zud5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud5"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud5.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud5.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud5.setText(msg1)
    feedback0_zud5.setText(msg0)
    feedback_zud5.setText(msg)
    # keep track of which components have finished
    fb_zud5Components = [feedback1_zud5, feedback0_zud5, feedback_zud5]
    for thisComponent in fb_zud5Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud5Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud5"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud5Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud5Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud5* updates
        if feedback1_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud5.frameNStart = frameN  # exact frame index
            feedback1_zud5.tStart = t  # local t and not account for scr refresh
            feedback1_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud5, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud5.setAutoDraw(True)
        if feedback1_zud5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud5.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud5.tStop = t  # not accounting for scr refresh
                feedback1_zud5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud5, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud5.setAutoDraw(False)
        
        # *feedback0_zud5* updates
        if feedback0_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud5.frameNStart = frameN  # exact frame index
            feedback0_zud5.tStart = t  # local t and not account for scr refresh
            feedback0_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud5, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud5.setAutoDraw(True)
        if feedback0_zud5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud5.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud5.tStop = t  # not accounting for scr refresh
                feedback0_zud5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud5, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud5.setAutoDraw(False)
        
        # *feedback_zud5* updates
        if feedback_zud5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud5.frameNStart = frameN  # exact frame index
            feedback_zud5.tStart = t  # local t and not account for scr refresh
            feedback_zud5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud5, 'tStartRefresh')  # time at next scr refresh
            feedback_zud5.setAutoDraw(True)
        if feedback_zud5.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud5.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud5.tStop = t  # not accounting for scr refresh
                feedback_zud5.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud5, 'tStopRefresh')  # time at next scr refresh
                feedback_zud5.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud5Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud5"-------
    for thisComponent in fb_zud5Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud5.started', feedback1_zud5.tStartRefresh)
    trials_phase3.addData('feedback1_zud5.stopped', feedback1_zud5.tStopRefresh)
    trials_phase3.addData('feedback0_zud5.started', feedback0_zud5.tStartRefresh)
    trials_phase3.addData('feedback0_zud5.stopped', feedback0_zud5.tStopRefresh)
    trials_phase3.addData('feedback_zud5.started', feedback_zud5.tStartRefresh)
    trials_phase3.addData('feedback_zud5.stopped', feedback_zud5.tStopRefresh)
    
    # ------Prepare to start Routine "zud6"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud6.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_6.setFillColor('black')
    cross_6.setFillColor('black')
    rectangle_6.setFillColor('black')
    key_resp_zud6.keys = []
    key_resp_zud6.rt = []
    _key_resp_zud6_allKeys = []
    # keep track of which components have finished
    zud6Components = [zud6_corr3, star_6, cross_6, rectangle_6, key_resp_zud6, option1_06, option2_06, option3_06]
    for thisComponent in zud6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud6"-------
    while continueRoutine:
        # get current time
        t = zud6Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud6Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud6_corr3* updates
        if zud6_corr3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud6_corr3.frameNStart = frameN  # exact frame index
            zud6_corr3.tStart = t  # local t and not account for scr refresh
            zud6_corr3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud6_corr3, 'tStartRefresh')  # time at next scr refresh
            zud6_corr3.setAutoDraw(True)
        
        # *star_6* updates
        if star_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_6.frameNStart = frameN  # exact frame index
            star_6.tStart = t  # local t and not account for scr refresh
            star_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_6, 'tStartRefresh')  # time at next scr refresh
            star_6.setAutoDraw(True)
        
        # *cross_6* updates
        if cross_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_6.frameNStart = frameN  # exact frame index
            cross_6.tStart = t  # local t and not account for scr refresh
            cross_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_6, 'tStartRefresh')  # time at next scr refresh
            cross_6.setAutoDraw(True)
        
        # *rectangle_6* updates
        if rectangle_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_6.frameNStart = frameN  # exact frame index
            rectangle_6.tStart = t  # local t and not account for scr refresh
            rectangle_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_6, 'tStartRefresh')  # time at next scr refresh
            rectangle_6.setAutoDraw(True)
        
        # *key_resp_zud6* updates
        waitOnFlip = False
        if key_resp_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud6.frameNStart = frameN  # exact frame index
            key_resp_zud6.tStart = t  # local t and not account for scr refresh
            key_resp_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud6, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud6.clock.reset)  # t=0 on next screen flip
        if key_resp_zud6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud6.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud6_allKeys.extend(theseKeys)
            if len(_key_resp_zud6_allKeys):
                key_resp_zud6.keys = _key_resp_zud6_allKeys[-1].name  # just the last key pressed
                key_resp_zud6.rt = _key_resp_zud6_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud6.keys == str('3')) or (key_resp_zud6.keys == '3'):
                    key_resp_zud6.corr = 1
                else:
                    key_resp_zud6.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_06* updates
        if option1_06.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_06.frameNStart = frameN  # exact frame index
            option1_06.tStart = t  # local t and not account for scr refresh
            option1_06.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_06, 'tStartRefresh')  # time at next scr refresh
            option1_06.setAutoDraw(True)
        
        # *option2_06* updates
        if option2_06.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_06.frameNStart = frameN  # exact frame index
            option2_06.tStart = t  # local t and not account for scr refresh
            option2_06.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_06, 'tStartRefresh')  # time at next scr refresh
            option2_06.setAutoDraw(True)
        
        # *option3_06* updates
        if option3_06.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_06.frameNStart = frameN  # exact frame index
            option3_06.tStart = t  # local t and not account for scr refresh
            option3_06.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_06, 'tStartRefresh')  # time at next scr refresh
            option3_06.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud6"-------
    for thisComponent in zud6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud6_corr3.started', zud6_corr3.tStartRefresh)
    trials_phase3.addData('zud6_corr3.stopped', zud6_corr3.tStopRefresh)
    trials_phase3.addData('star_6.started', star_6.tStartRefresh)
    trials_phase3.addData('star_6.stopped', star_6.tStopRefresh)
    trials_phase3.addData('cross_6.started', cross_6.tStartRefresh)
    trials_phase3.addData('cross_6.stopped', cross_6.tStopRefresh)
    trials_phase3.addData('rectangle_6.started', rectangle_6.tStartRefresh)
    trials_phase3.addData('rectangle_6.stopped', rectangle_6.tStopRefresh)
    # check responses
    if key_resp_zud6.keys in ['', [], None]:  # No response was made
        key_resp_zud6.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_zud6.corr = 1;  # correct non-response
        else:
           key_resp_zud6.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud6.keys',key_resp_zud6.keys)
    trials_phase3.addData('key_resp_zud6.corr', key_resp_zud6.corr)
    if key_resp_zud6.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud6.rt', key_resp_zud6.rt)
    trials_phase3.addData('key_resp_zud6.started', key_resp_zud6.tStartRefresh)
    trials_phase3.addData('key_resp_zud6.stopped', key_resp_zud6.tStopRefresh)
    trials_phase3.addData('option1_06.started', option1_06.tStartRefresh)
    trials_phase3.addData('option1_06.stopped', option1_06.tStopRefresh)
    trials_phase3.addData('option2_06.started', option2_06.tStartRefresh)
    trials_phase3.addData('option2_06.stopped', option2_06.tStopRefresh)
    trials_phase3.addData('option3_06.started', option3_06.tStartRefresh)
    trials_phase3.addData('option3_06.stopped', option3_06.tStopRefresh)
    # the Routine "zud6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud6"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud6.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud6.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud6.setText(msg1)
    feedback0_zud6.setText(msg0)
    feedback_zud6.setText(msg)
    # keep track of which components have finished
    fb_zud6Components = [feedback1_zud6, feedback0_zud6, feedback_zud6]
    for thisComponent in fb_zud6Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud6Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud6"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud6Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud6Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud6* updates
        if feedback1_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud6.frameNStart = frameN  # exact frame index
            feedback1_zud6.tStart = t  # local t and not account for scr refresh
            feedback1_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud6, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud6.setAutoDraw(True)
        if feedback1_zud6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud6.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud6.tStop = t  # not accounting for scr refresh
                feedback1_zud6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud6, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud6.setAutoDraw(False)
        
        # *feedback0_zud6* updates
        if feedback0_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud6.frameNStart = frameN  # exact frame index
            feedback0_zud6.tStart = t  # local t and not account for scr refresh
            feedback0_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud6, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud6.setAutoDraw(True)
        if feedback0_zud6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud6.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud6.tStop = t  # not accounting for scr refresh
                feedback0_zud6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud6, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud6.setAutoDraw(False)
        
        # *feedback_zud6* updates
        if feedback_zud6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud6.frameNStart = frameN  # exact frame index
            feedback_zud6.tStart = t  # local t and not account for scr refresh
            feedback_zud6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud6, 'tStartRefresh')  # time at next scr refresh
            feedback_zud6.setAutoDraw(True)
        if feedback_zud6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud6.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud6.tStop = t  # not accounting for scr refresh
                feedback_zud6.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud6, 'tStopRefresh')  # time at next scr refresh
                feedback_zud6.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud6Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud6"-------
    for thisComponent in fb_zud6Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud6.started', feedback1_zud6.tStartRefresh)
    trials_phase3.addData('feedback1_zud6.stopped', feedback1_zud6.tStopRefresh)
    trials_phase3.addData('feedback0_zud6.started', feedback0_zud6.tStartRefresh)
    trials_phase3.addData('feedback0_zud6.stopped', feedback0_zud6.tStopRefresh)
    trials_phase3.addData('feedback_zud6.started', feedback_zud6.tStartRefresh)
    trials_phase3.addData('feedback_zud6.stopped', feedback_zud6.tStopRefresh)
    
    # ------Prepare to start Routine "zud7"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud7.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    rectangle_7.setFillColor('white')
    cross_7.setFillColor('white')
    star_7.setFillColor('white')
    key_resp_zud7.keys = []
    key_resp_zud7.rt = []
    _key_resp_zud7_allKeys = []
    # keep track of which components have finished
    zud7Components = [zud7_corr1, rectangle_7, cross_7, star_7, key_resp_zud7, option1_07, option2_07, option3_07]
    for thisComponent in zud7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud7"-------
    while continueRoutine:
        # get current time
        t = zud7Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud7Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud7_corr1* updates
        if zud7_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud7_corr1.frameNStart = frameN  # exact frame index
            zud7_corr1.tStart = t  # local t and not account for scr refresh
            zud7_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud7_corr1, 'tStartRefresh')  # time at next scr refresh
            zud7_corr1.setAutoDraw(True)
        
        # *rectangle_7* updates
        if rectangle_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_7.frameNStart = frameN  # exact frame index
            rectangle_7.tStart = t  # local t and not account for scr refresh
            rectangle_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_7, 'tStartRefresh')  # time at next scr refresh
            rectangle_7.setAutoDraw(True)
        
        # *cross_7* updates
        if cross_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_7.frameNStart = frameN  # exact frame index
            cross_7.tStart = t  # local t and not account for scr refresh
            cross_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_7, 'tStartRefresh')  # time at next scr refresh
            cross_7.setAutoDraw(True)
        
        # *star_7* updates
        if star_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_7.frameNStart = frameN  # exact frame index
            star_7.tStart = t  # local t and not account for scr refresh
            star_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_7, 'tStartRefresh')  # time at next scr refresh
            star_7.setAutoDraw(True)
        
        # *key_resp_zud7* updates
        waitOnFlip = False
        if key_resp_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud7.frameNStart = frameN  # exact frame index
            key_resp_zud7.tStart = t  # local t and not account for scr refresh
            key_resp_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud7, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud7.clock.reset)  # t=0 on next screen flip
        if key_resp_zud7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud7.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud7_allKeys.extend(theseKeys)
            if len(_key_resp_zud7_allKeys):
                key_resp_zud7.keys = _key_resp_zud7_allKeys[-1].name  # just the last key pressed
                key_resp_zud7.rt = _key_resp_zud7_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud7.keys == str('1')) or (key_resp_zud7.keys == '1'):
                    key_resp_zud7.corr = 1
                else:
                    key_resp_zud7.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_07* updates
        if option1_07.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_07.frameNStart = frameN  # exact frame index
            option1_07.tStart = t  # local t and not account for scr refresh
            option1_07.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_07, 'tStartRefresh')  # time at next scr refresh
            option1_07.setAutoDraw(True)
        
        # *option2_07* updates
        if option2_07.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_07.frameNStart = frameN  # exact frame index
            option2_07.tStart = t  # local t and not account for scr refresh
            option2_07.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_07, 'tStartRefresh')  # time at next scr refresh
            option2_07.setAutoDraw(True)
        
        # *option3_07* updates
        if option3_07.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_07.frameNStart = frameN  # exact frame index
            option3_07.tStart = t  # local t and not account for scr refresh
            option3_07.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_07, 'tStartRefresh')  # time at next scr refresh
            option3_07.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud7"-------
    for thisComponent in zud7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud7_corr1.started', zud7_corr1.tStartRefresh)
    trials_phase3.addData('zud7_corr1.stopped', zud7_corr1.tStopRefresh)
    trials_phase3.addData('rectangle_7.started', rectangle_7.tStartRefresh)
    trials_phase3.addData('rectangle_7.stopped', rectangle_7.tStopRefresh)
    trials_phase3.addData('cross_7.started', cross_7.tStartRefresh)
    trials_phase3.addData('cross_7.stopped', cross_7.tStopRefresh)
    trials_phase3.addData('star_7.started', star_7.tStartRefresh)
    trials_phase3.addData('star_7.stopped', star_7.tStopRefresh)
    # check responses
    if key_resp_zud7.keys in ['', [], None]:  # No response was made
        key_resp_zud7.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_zud7.corr = 1;  # correct non-response
        else:
           key_resp_zud7.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud7.keys',key_resp_zud7.keys)
    trials_phase3.addData('key_resp_zud7.corr', key_resp_zud7.corr)
    if key_resp_zud7.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud7.rt', key_resp_zud7.rt)
    trials_phase3.addData('key_resp_zud7.started', key_resp_zud7.tStartRefresh)
    trials_phase3.addData('key_resp_zud7.stopped', key_resp_zud7.tStopRefresh)
    trials_phase3.addData('option1_07.started', option1_07.tStartRefresh)
    trials_phase3.addData('option1_07.stopped', option1_07.tStopRefresh)
    trials_phase3.addData('option2_07.started', option2_07.tStartRefresh)
    trials_phase3.addData('option2_07.stopped', option2_07.tStopRefresh)
    trials_phase3.addData('option3_07.started', option3_07.tStartRefresh)
    trials_phase3.addData('option3_07.stopped', option3_07.tStopRefresh)
    # the Routine "zud7" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud7"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud7.keys:
        msg="Allowed Keys: 1, 2, 3"
    elif key_resp_zud7.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud7.setText(msg1)
    feedback0_zud7.setText(msg0)
    feedback_zud7.setText(msg)
    # keep track of which components have finished
    fb_zud7Components = [feedback1_zud7, feedback0_zud7, feedback_zud7]
    for thisComponent in fb_zud7Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud7Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud7"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud7Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud7Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud7* updates
        if feedback1_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud7.frameNStart = frameN  # exact frame index
            feedback1_zud7.tStart = t  # local t and not account for scr refresh
            feedback1_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud7, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud7.setAutoDraw(True)
        if feedback1_zud7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud7.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud7.tStop = t  # not accounting for scr refresh
                feedback1_zud7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud7, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud7.setAutoDraw(False)
        
        # *feedback0_zud7* updates
        if feedback0_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud7.frameNStart = frameN  # exact frame index
            feedback0_zud7.tStart = t  # local t and not account for scr refresh
            feedback0_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud7, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud7.setAutoDraw(True)
        if feedback0_zud7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud7.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud7.tStop = t  # not accounting for scr refresh
                feedback0_zud7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud7, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud7.setAutoDraw(False)
        
        # *feedback_zud7* updates
        if feedback_zud7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud7.frameNStart = frameN  # exact frame index
            feedback_zud7.tStart = t  # local t and not account for scr refresh
            feedback_zud7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud7, 'tStartRefresh')  # time at next scr refresh
            feedback_zud7.setAutoDraw(True)
        if feedback_zud7.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud7.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud7.tStop = t  # not accounting for scr refresh
                feedback_zud7.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud7, 'tStopRefresh')  # time at next scr refresh
                feedback_zud7.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud7Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud7"-------
    for thisComponent in fb_zud7Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud7.started', feedback1_zud7.tStartRefresh)
    trials_phase3.addData('feedback1_zud7.stopped', feedback1_zud7.tStopRefresh)
    trials_phase3.addData('feedback0_zud7.started', feedback0_zud7.tStartRefresh)
    trials_phase3.addData('feedback0_zud7.stopped', feedback0_zud7.tStopRefresh)
    trials_phase3.addData('feedback_zud7.started', feedback_zud7.tStartRefresh)
    trials_phase3.addData('feedback_zud7.stopped', feedback_zud7.tStopRefresh)
    
    # ------Prepare to start Routine "zud8"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud8.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_8.setFillColor('white')
    rectangle_8.setFillColor('white')
    cross_8.setFillColor('white')
    key_resp_zud8.keys = []
    key_resp_zud8.rt = []
    _key_resp_zud8_allKeys = []
    # keep track of which components have finished
    zud8Components = [zud8_corr2, star_8, rectangle_8, cross_8, key_resp_zud8, option1_9, option2_9, option3_8]
    for thisComponent in zud8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    zud8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "zud8"-------
    while continueRoutine:
        # get current time
        t = zud8Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=zud8Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *zud8_corr2* updates
        if zud8_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            zud8_corr2.frameNStart = frameN  # exact frame index
            zud8_corr2.tStart = t  # local t and not account for scr refresh
            zud8_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(zud8_corr2, 'tStartRefresh')  # time at next scr refresh
            zud8_corr2.setAutoDraw(True)
        
        # *star_8* updates
        if star_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_8.frameNStart = frameN  # exact frame index
            star_8.tStart = t  # local t and not account for scr refresh
            star_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_8, 'tStartRefresh')  # time at next scr refresh
            star_8.setAutoDraw(True)
        
        # *rectangle_8* updates
        if rectangle_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            rectangle_8.frameNStart = frameN  # exact frame index
            rectangle_8.tStart = t  # local t and not account for scr refresh
            rectangle_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(rectangle_8, 'tStartRefresh')  # time at next scr refresh
            rectangle_8.setAutoDraw(True)
        
        # *cross_8* updates
        if cross_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_8.frameNStart = frameN  # exact frame index
            cross_8.tStart = t  # local t and not account for scr refresh
            cross_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_8, 'tStartRefresh')  # time at next scr refresh
            cross_8.setAutoDraw(True)
        
        # *key_resp_zud8* updates
        waitOnFlip = False
        if key_resp_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_zud8.frameNStart = frameN  # exact frame index
            key_resp_zud8.tStart = t  # local t and not account for scr refresh
            key_resp_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_zud8, 'tStartRefresh')  # time at next scr refresh
            key_resp_zud8.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_zud8.clock.reset)  # t=0 on next screen flip
        if key_resp_zud8.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_zud8.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_zud8_allKeys.extend(theseKeys)
            if len(_key_resp_zud8_allKeys):
                key_resp_zud8.keys = _key_resp_zud8_allKeys[-1].name  # just the last key pressed
                key_resp_zud8.rt = _key_resp_zud8_allKeys[-1].rt
                # was this correct?
                if (key_resp_zud8.keys == str('2')) or (key_resp_zud8.keys == '2'):
                    key_resp_zud8.corr = 1
                else:
                    key_resp_zud8.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_9* updates
        if option1_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_9.frameNStart = frameN  # exact frame index
            option1_9.tStart = t  # local t and not account for scr refresh
            option1_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_9, 'tStartRefresh')  # time at next scr refresh
            option1_9.setAutoDraw(True)
        
        # *option2_9* updates
        if option2_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_9.frameNStart = frameN  # exact frame index
            option2_9.tStart = t  # local t and not account for scr refresh
            option2_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_9, 'tStartRefresh')  # time at next scr refresh
            option2_9.setAutoDraw(True)
        
        # *option3_8* updates
        if option3_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_8.frameNStart = frameN  # exact frame index
            option3_8.tStart = t  # local t and not account for scr refresh
            option3_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_8, 'tStartRefresh')  # time at next scr refresh
            option3_8.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in zud8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "zud8"-------
    for thisComponent in zud8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('zud8_corr2.started', zud8_corr2.tStartRefresh)
    trials_phase3.addData('zud8_corr2.stopped', zud8_corr2.tStopRefresh)
    trials_phase3.addData('star_8.started', star_8.tStartRefresh)
    trials_phase3.addData('star_8.stopped', star_8.tStopRefresh)
    trials_phase3.addData('rectangle_8.started', rectangle_8.tStartRefresh)
    trials_phase3.addData('rectangle_8.stopped', rectangle_8.tStopRefresh)
    trials_phase3.addData('cross_8.started', cross_8.tStartRefresh)
    trials_phase3.addData('cross_8.stopped', cross_8.tStopRefresh)
    # check responses
    if key_resp_zud8.keys in ['', [], None]:  # No response was made
        key_resp_zud8.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_zud8.corr = 1;  # correct non-response
        else:
           key_resp_zud8.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_zud8.keys',key_resp_zud8.keys)
    trials_phase3.addData('key_resp_zud8.corr', key_resp_zud8.corr)
    if key_resp_zud8.keys != None:  # we had a response
        trials_phase3.addData('key_resp_zud8.rt', key_resp_zud8.rt)
    trials_phase3.addData('key_resp_zud8.started', key_resp_zud8.tStartRefresh)
    trials_phase3.addData('key_resp_zud8.stopped', key_resp_zud8.tStopRefresh)
    trials_phase3.addData('option1_9.started', option1_9.tStartRefresh)
    trials_phase3.addData('option1_9.stopped', option1_9.tStopRefresh)
    trials_phase3.addData('option2_9.started', option2_9.tStartRefresh)
    trials_phase3.addData('option2_9.stopped', option2_9.tStopRefresh)
    trials_phase3.addData('option3_8.started', option3_8.tStartRefresh)
    trials_phase3.addData('option3_8.stopped', option3_8.tStopRefresh)
    # the Routine "zud8" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_zud8"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_zud8.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_zud8.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_zud8.setText(msg1)
    feedback0_zud8.setText(msg0)
    feedback_zud8.setText(msg)
    # keep track of which components have finished
    fb_zud8Components = [feedback1_zud8, feedback0_zud8, feedback_zud8]
    for thisComponent in fb_zud8Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_zud8Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_zud8"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_zud8Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_zud8Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_zud8* updates
        if feedback1_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_zud8.frameNStart = frameN  # exact frame index
            feedback1_zud8.tStart = t  # local t and not account for scr refresh
            feedback1_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_zud8, 'tStartRefresh')  # time at next scr refresh
            feedback1_zud8.setAutoDraw(True)
        if feedback1_zud8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_zud8.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_zud8.tStop = t  # not accounting for scr refresh
                feedback1_zud8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_zud8, 'tStopRefresh')  # time at next scr refresh
                feedback1_zud8.setAutoDraw(False)
        
        # *feedback0_zud8* updates
        if feedback0_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_zud8.frameNStart = frameN  # exact frame index
            feedback0_zud8.tStart = t  # local t and not account for scr refresh
            feedback0_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_zud8, 'tStartRefresh')  # time at next scr refresh
            feedback0_zud8.setAutoDraw(True)
        if feedback0_zud8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_zud8.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_zud8.tStop = t  # not accounting for scr refresh
                feedback0_zud8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_zud8, 'tStopRefresh')  # time at next scr refresh
                feedback0_zud8.setAutoDraw(False)
        
        # *feedback_zud8* updates
        if feedback_zud8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_zud8.frameNStart = frameN  # exact frame index
            feedback_zud8.tStart = t  # local t and not account for scr refresh
            feedback_zud8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_zud8, 'tStartRefresh')  # time at next scr refresh
            feedback_zud8.setAutoDraw(True)
        if feedback_zud8.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_zud8.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_zud8.tStop = t  # not accounting for scr refresh
                feedback_zud8.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_zud8, 'tStopRefresh')  # time at next scr refresh
                feedback_zud8.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_zud8Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_zud8"-------
    for thisComponent in fb_zud8Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_zud8.started', feedback1_zud8.tStartRefresh)
    trials_phase3.addData('feedback1_zud8.stopped', feedback1_zud8.tStopRefresh)
    trials_phase3.addData('feedback0_zud8.started', feedback0_zud8.tStartRefresh)
    trials_phase3.addData('feedback0_zud8.stopped', feedback0_zud8.tStopRefresh)
    trials_phase3.addData('feedback_zud8.started', feedback_zud8.tStartRefresh)
    trials_phase3.addData('feedback_zud8.stopped', feedback_zud8.tStopRefresh)
    
    # ------Prepare to start Routine "dax9"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax9.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_9.setFillColor('black')
    triange_9.setFillColor('black')
    cross_9.setFillColor('black')
    key_resp_dax9.keys = []
    key_resp_dax9.rt = []
    _key_resp_dax9_allKeys = []
    # keep track of which components have finished
    dax9Components = [dax9_corr2, star_9, triange_9, cross_9, key_resp_dax9, option1, option2, option3]
    for thisComponent in dax9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax9"-------
    while continueRoutine:
        # get current time
        t = dax9Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax9Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2* updates
        if dax9_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2.frameNStart = frameN  # exact frame index
            dax9_corr2.tStart = t  # local t and not account for scr refresh
            dax9_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2.setAutoDraw(True)
        
        # *star_9* updates
        if star_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_9.frameNStart = frameN  # exact frame index
            star_9.tStart = t  # local t and not account for scr refresh
            star_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_9, 'tStartRefresh')  # time at next scr refresh
            star_9.setAutoDraw(True)
        
        # *triange_9* updates
        if triange_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_9.frameNStart = frameN  # exact frame index
            triange_9.tStart = t  # local t and not account for scr refresh
            triange_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_9, 'tStartRefresh')  # time at next scr refresh
            triange_9.setAutoDraw(True)
        
        # *cross_9* updates
        if cross_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_9.frameNStart = frameN  # exact frame index
            cross_9.tStart = t  # local t and not account for scr refresh
            cross_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_9, 'tStartRefresh')  # time at next scr refresh
            cross_9.setAutoDraw(True)
        
        # *key_resp_dax9* updates
        waitOnFlip = False
        if key_resp_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax9.frameNStart = frameN  # exact frame index
            key_resp_dax9.tStart = t  # local t and not account for scr refresh
            key_resp_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax9, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax9.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax9.clock.reset)  # t=0 on next screen flip
        if key_resp_dax9.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax9.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax9_allKeys.extend(theseKeys)
            if len(_key_resp_dax9_allKeys):
                key_resp_dax9.keys = _key_resp_dax9_allKeys[-1].name  # just the last key pressed
                key_resp_dax9.rt = _key_resp_dax9_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax9.keys == str('2')) or (key_resp_dax9.keys == '2'):
                    key_resp_dax9.corr = 1
                else:
                    key_resp_dax9.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1* updates
        if option1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1.frameNStart = frameN  # exact frame index
            option1.tStart = t  # local t and not account for scr refresh
            option1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1, 'tStartRefresh')  # time at next scr refresh
            option1.setAutoDraw(True)
        
        # *option2* updates
        if option2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2.frameNStart = frameN  # exact frame index
            option2.tStart = t  # local t and not account for scr refresh
            option2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2, 'tStartRefresh')  # time at next scr refresh
            option2.setAutoDraw(True)
        
        # *option3* updates
        if option3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3.frameNStart = frameN  # exact frame index
            option3.tStart = t  # local t and not account for scr refresh
            option3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3, 'tStartRefresh')  # time at next scr refresh
            option3.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax9"-------
    for thisComponent in dax9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax9_corr2.started', dax9_corr2.tStartRefresh)
    trials_phase3.addData('dax9_corr2.stopped', dax9_corr2.tStopRefresh)
    trials_phase3.addData('star_9.started', star_9.tStartRefresh)
    trials_phase3.addData('star_9.stopped', star_9.tStopRefresh)
    trials_phase3.addData('triange_9.started', triange_9.tStartRefresh)
    trials_phase3.addData('triange_9.stopped', triange_9.tStopRefresh)
    trials_phase3.addData('cross_9.started', cross_9.tStartRefresh)
    trials_phase3.addData('cross_9.stopped', cross_9.tStopRefresh)
    # check responses
    if key_resp_dax9.keys in ['', [], None]:  # No response was made
        key_resp_dax9.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_dax9.corr = 1;  # correct non-response
        else:
           key_resp_dax9.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_dax9.keys',key_resp_dax9.keys)
    trials_phase3.addData('key_resp_dax9.corr', key_resp_dax9.corr)
    if key_resp_dax9.keys != None:  # we had a response
        trials_phase3.addData('key_resp_dax9.rt', key_resp_dax9.rt)
    trials_phase3.addData('key_resp_dax9.started', key_resp_dax9.tStartRefresh)
    trials_phase3.addData('key_resp_dax9.stopped', key_resp_dax9.tStopRefresh)
    trials_phase3.addData('option1.started', option1.tStartRefresh)
    trials_phase3.addData('option1.stopped', option1.tStopRefresh)
    trials_phase3.addData('option2.started', option2.tStartRefresh)
    trials_phase3.addData('option2.stopped', option2.tStopRefresh)
    trials_phase3.addData('option3.started', option3.tStartRefresh)
    trials_phase3.addData('option3.stopped', option3.tStopRefresh)
    # the Routine "dax9" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax9"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax9.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax9.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9.setText(msg1)
    feedback0_dax9.setText(msg0)
    feedback_dax9.setText(msg)
    # keep track of which components have finished
    fb_dax9Components = [feedback1_dax9, feedback0_dax9, feedback_dax9]
    for thisComponent in fb_dax9Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax9"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax9Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax9Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9* updates
        if feedback1_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9.frameNStart = frameN  # exact frame index
            feedback1_dax9.tStart = t  # local t and not account for scr refresh
            feedback1_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9.setAutoDraw(True)
        if feedback1_dax9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9.tStop = t  # not accounting for scr refresh
                feedback1_dax9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9.setAutoDraw(False)
        
        # *feedback0_dax9* updates
        if feedback0_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9.frameNStart = frameN  # exact frame index
            feedback0_dax9.tStart = t  # local t and not account for scr refresh
            feedback0_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9.setAutoDraw(True)
        if feedback0_dax9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9.tStop = t  # not accounting for scr refresh
                feedback0_dax9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9.setAutoDraw(False)
        
        # *feedback_dax9* updates
        if feedback_dax9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9.frameNStart = frameN  # exact frame index
            feedback_dax9.tStart = t  # local t and not account for scr refresh
            feedback_dax9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9.setAutoDraw(True)
        if feedback_dax9.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9.tStop = t  # not accounting for scr refresh
                feedback_dax9.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax9Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax9"-------
    for thisComponent in fb_dax9Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9.started', feedback1_dax9.tStartRefresh)
    trials_phase3.addData('feedback1_dax9.stopped', feedback1_dax9.tStopRefresh)
    trials_phase3.addData('feedback0_dax9.started', feedback0_dax9.tStartRefresh)
    trials_phase3.addData('feedback0_dax9.stopped', feedback0_dax9.tStopRefresh)
    trials_phase3.addData('feedback_dax9.started', feedback_dax9.tStartRefresh)
    trials_phase3.addData('feedback_dax9.stopped', feedback_dax9.tStopRefresh)
    
    # ------Prepare to start Routine "dax10"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_zud7.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    triangle_10.setFillColor('black')
    cross_10.setFillColor('black')
    star_10.setFillColor('black')
    key_resp_dax10.keys = []
    key_resp_dax10.rt = []
    _key_resp_dax10_allKeys = []
    # keep track of which components have finished
    dax10Components = [dax10_corr1, triangle_10, cross_10, star_10, key_resp_dax10, option1_8, option2_8, option3_10]
    for thisComponent in dax10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax10"-------
    while continueRoutine:
        # get current time
        t = dax10Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax10Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax10_corr1* updates
        if dax10_corr1.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax10_corr1.frameNStart = frameN  # exact frame index
            dax10_corr1.tStart = t  # local t and not account for scr refresh
            dax10_corr1.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax10_corr1, 'tStartRefresh')  # time at next scr refresh
            dax10_corr1.setAutoDraw(True)
        
        # *triangle_10* updates
        if triangle_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_10.frameNStart = frameN  # exact frame index
            triangle_10.tStart = t  # local t and not account for scr refresh
            triangle_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_10, 'tStartRefresh')  # time at next scr refresh
            triangle_10.setAutoDraw(True)
        
        # *cross_10* updates
        if cross_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_10.frameNStart = frameN  # exact frame index
            cross_10.tStart = t  # local t and not account for scr refresh
            cross_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_10, 'tStartRefresh')  # time at next scr refresh
            cross_10.setAutoDraw(True)
        
        # *star_10* updates
        if star_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_10.frameNStart = frameN  # exact frame index
            star_10.tStart = t  # local t and not account for scr refresh
            star_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_10, 'tStartRefresh')  # time at next scr refresh
            star_10.setAutoDraw(True)
        
        # *key_resp_dax10* updates
        waitOnFlip = False
        if key_resp_dax10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax10.frameNStart = frameN  # exact frame index
            key_resp_dax10.tStart = t  # local t and not account for scr refresh
            key_resp_dax10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax10, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax10.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax10.clock.reset)  # t=0 on next screen flip
        if key_resp_dax10.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax10.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax10_allKeys.extend(theseKeys)
            if len(_key_resp_dax10_allKeys):
                key_resp_dax10.keys = _key_resp_dax10_allKeys[-1].name  # just the last key pressed
                key_resp_dax10.rt = _key_resp_dax10_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax10.keys == str('1')) or (key_resp_dax10.keys == '1'):
                    key_resp_dax10.corr = 1
                else:
                    key_resp_dax10.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_8* updates
        if option1_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_8.frameNStart = frameN  # exact frame index
            option1_8.tStart = t  # local t and not account for scr refresh
            option1_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_8, 'tStartRefresh')  # time at next scr refresh
            option1_8.setAutoDraw(True)
        
        # *option2_8* updates
        if option2_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_8.frameNStart = frameN  # exact frame index
            option2_8.tStart = t  # local t and not account for scr refresh
            option2_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_8, 'tStartRefresh')  # time at next scr refresh
            option2_8.setAutoDraw(True)
        
        # *option3_10* updates
        if option3_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_10.frameNStart = frameN  # exact frame index
            option3_10.tStart = t  # local t and not account for scr refresh
            option3_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_10, 'tStartRefresh')  # time at next scr refresh
            option3_10.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax10"-------
    for thisComponent in dax10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax10_corr1.started', dax10_corr1.tStartRefresh)
    trials_phase3.addData('dax10_corr1.stopped', dax10_corr1.tStopRefresh)
    trials_phase3.addData('triangle_10.started', triangle_10.tStartRefresh)
    trials_phase3.addData('triangle_10.stopped', triangle_10.tStopRefresh)
    trials_phase3.addData('cross_10.started', cross_10.tStartRefresh)
    trials_phase3.addData('cross_10.stopped', cross_10.tStopRefresh)
    trials_phase3.addData('star_10.started', star_10.tStartRefresh)
    trials_phase3.addData('star_10.stopped', star_10.tStopRefresh)
    # check responses
    if key_resp_dax10.keys in ['', [], None]:  # No response was made
        key_resp_dax10.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_dax10.corr = 1;  # correct non-response
        else:
           key_resp_dax10.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_dax10.keys',key_resp_dax10.keys)
    trials_phase3.addData('key_resp_dax10.corr', key_resp_dax10.corr)
    if key_resp_dax10.keys != None:  # we had a response
        trials_phase3.addData('key_resp_dax10.rt', key_resp_dax10.rt)
    trials_phase3.addData('key_resp_dax10.started', key_resp_dax10.tStartRefresh)
    trials_phase3.addData('key_resp_dax10.stopped', key_resp_dax10.tStopRefresh)
    trials_phase3.addData('option1_8.started', option1_8.tStartRefresh)
    trials_phase3.addData('option1_8.stopped', option1_8.tStopRefresh)
    trials_phase3.addData('option2_8.started', option2_8.tStartRefresh)
    trials_phase3.addData('option2_8.stopped', option2_8.tStopRefresh)
    trials_phase3.addData('option3_10.started', option3_10.tStartRefresh)
    trials_phase3.addData('option3_10.stopped', option3_10.tStopRefresh)
    # the Routine "dax10" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax10"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax10.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax10.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_2.setText(msg1)
    feedback0_dax9_2.setText(msg0)
    feedback_dax9_2.setText(msg)
    # keep track of which components have finished
    fb_dax10Components = [feedback1_dax9_2, feedback0_dax9_2, feedback_dax9_2]
    for thisComponent in fb_dax10Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax10Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax10"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax10Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax10Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_2* updates
        if feedback1_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_2.frameNStart = frameN  # exact frame index
            feedback1_dax9_2.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_2, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_2.setAutoDraw(True)
        if feedback1_dax9_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_2.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_2.tStop = t  # not accounting for scr refresh
                feedback1_dax9_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_2, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_2.setAutoDraw(False)
        
        # *feedback0_dax9_2* updates
        if feedback0_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_2.frameNStart = frameN  # exact frame index
            feedback0_dax9_2.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_2, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_2.setAutoDraw(True)
        if feedback0_dax9_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_2.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_2.tStop = t  # not accounting for scr refresh
                feedback0_dax9_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_2, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_2.setAutoDraw(False)
        
        # *feedback_dax9_2* updates
        if feedback_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_2.frameNStart = frameN  # exact frame index
            feedback_dax9_2.tStart = t  # local t and not account for scr refresh
            feedback_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_2, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_2.setAutoDraw(True)
        if feedback_dax9_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_2.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_2.tStop = t  # not accounting for scr refresh
                feedback_dax9_2.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_2, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_2.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax10Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax10"-------
    for thisComponent in fb_dax10Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_2.started', feedback1_dax9_2.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_2.stopped', feedback1_dax9_2.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_2.started', feedback0_dax9_2.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_2.stopped', feedback0_dax9_2.tStopRefresh)
    trials_phase3.addData('feedback_dax9_2.started', feedback_dax9_2.tStartRefresh)
    trials_phase3.addData('feedback_dax9_2.stopped', feedback_dax9_2.tStopRefresh)
    
    # ------Prepare to start Routine "dax11"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax11.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_11.setFillColor('white')
    cross_11.setFillColor('white')
    triangle_11.setFillColor('white')
    key_resp_dax11.keys = []
    key_resp_dax11.rt = []
    _key_resp_dax11_allKeys = []
    # keep track of which components have finished
    dax11Components = [dax11_corr3, star_11, cross_11, triangle_11, key_resp_dax11, option1_6, option2_6, option3_6]
    for thisComponent in dax11Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax11"-------
    while continueRoutine:
        # get current time
        t = dax11Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax11Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax11_corr3* updates
        if dax11_corr3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax11_corr3.frameNStart = frameN  # exact frame index
            dax11_corr3.tStart = t  # local t and not account for scr refresh
            dax11_corr3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax11_corr3, 'tStartRefresh')  # time at next scr refresh
            dax11_corr3.setAutoDraw(True)
        
        # *star_11* updates
        if star_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_11.frameNStart = frameN  # exact frame index
            star_11.tStart = t  # local t and not account for scr refresh
            star_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_11, 'tStartRefresh')  # time at next scr refresh
            star_11.setAutoDraw(True)
        
        # *cross_11* updates
        if cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_11.frameNStart = frameN  # exact frame index
            cross_11.tStart = t  # local t and not account for scr refresh
            cross_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_11, 'tStartRefresh')  # time at next scr refresh
            cross_11.setAutoDraw(True)
        
        # *triangle_11* updates
        if triangle_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triangle_11.frameNStart = frameN  # exact frame index
            triangle_11.tStart = t  # local t and not account for scr refresh
            triangle_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triangle_11, 'tStartRefresh')  # time at next scr refresh
            triangle_11.setAutoDraw(True)
        
        # *key_resp_dax11* updates
        waitOnFlip = False
        if key_resp_dax11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax11.frameNStart = frameN  # exact frame index
            key_resp_dax11.tStart = t  # local t and not account for scr refresh
            key_resp_dax11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax11, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax11.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax11.clock.reset)  # t=0 on next screen flip
        if key_resp_dax11.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax11.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax11_allKeys.extend(theseKeys)
            if len(_key_resp_dax11_allKeys):
                key_resp_dax11.keys = _key_resp_dax11_allKeys[-1].name  # just the last key pressed
                key_resp_dax11.rt = _key_resp_dax11_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax11.keys == str('3')) or (key_resp_dax11.keys == '3'):
                    key_resp_dax11.corr = 1
                else:
                    key_resp_dax11.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_6* updates
        if option1_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_6.frameNStart = frameN  # exact frame index
            option1_6.tStart = t  # local t and not account for scr refresh
            option1_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_6, 'tStartRefresh')  # time at next scr refresh
            option1_6.setAutoDraw(True)
        
        # *option2_6* updates
        if option2_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_6.frameNStart = frameN  # exact frame index
            option2_6.tStart = t  # local t and not account for scr refresh
            option2_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_6, 'tStartRefresh')  # time at next scr refresh
            option2_6.setAutoDraw(True)
        
        # *option3_6* updates
        if option3_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_6.frameNStart = frameN  # exact frame index
            option3_6.tStart = t  # local t and not account for scr refresh
            option3_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_6, 'tStartRefresh')  # time at next scr refresh
            option3_6.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax11Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax11"-------
    for thisComponent in dax11Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax11_corr3.started', dax11_corr3.tStartRefresh)
    trials_phase3.addData('dax11_corr3.stopped', dax11_corr3.tStopRefresh)
    trials_phase3.addData('star_11.started', star_11.tStartRefresh)
    trials_phase3.addData('star_11.stopped', star_11.tStopRefresh)
    trials_phase3.addData('cross_11.started', cross_11.tStartRefresh)
    trials_phase3.addData('cross_11.stopped', cross_11.tStopRefresh)
    trials_phase3.addData('triangle_11.started', triangle_11.tStartRefresh)
    trials_phase3.addData('triangle_11.stopped', triangle_11.tStopRefresh)
    # check responses
    if key_resp_dax11.keys in ['', [], None]:  # No response was made
        key_resp_dax11.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_dax11.corr = 1;  # correct non-response
        else:
           key_resp_dax11.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_dax11.keys',key_resp_dax11.keys)
    trials_phase3.addData('key_resp_dax11.corr', key_resp_dax11.corr)
    if key_resp_dax11.keys != None:  # we had a response
        trials_phase3.addData('key_resp_dax11.rt', key_resp_dax11.rt)
    trials_phase3.addData('key_resp_dax11.started', key_resp_dax11.tStartRefresh)
    trials_phase3.addData('key_resp_dax11.stopped', key_resp_dax11.tStopRefresh)
    trials_phase3.addData('option1_6.started', option1_6.tStartRefresh)
    trials_phase3.addData('option1_6.stopped', option1_6.tStopRefresh)
    trials_phase3.addData('option2_6.started', option2_6.tStartRefresh)
    trials_phase3.addData('option2_6.stopped', option2_6.tStopRefresh)
    trials_phase3.addData('option3_6.started', option3_6.tStartRefresh)
    trials_phase3.addData('option3_6.stopped', option3_6.tStopRefresh)
    # the Routine "dax11" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax11"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax11.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax11.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_3.setText(msg1)
    feedback0_dax9_3.setText(msg0)
    feedback_dax9_3.setText(msg)
    # keep track of which components have finished
    fb_dax11Components = [feedback1_dax9_3, feedback0_dax9_3, feedback_dax9_3]
    for thisComponent in fb_dax11Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax11Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax11"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax11Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax11Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_3* updates
        if feedback1_dax9_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_3.frameNStart = frameN  # exact frame index
            feedback1_dax9_3.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_3, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_3.setAutoDraw(True)
        if feedback1_dax9_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_3.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_3.tStop = t  # not accounting for scr refresh
                feedback1_dax9_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_3, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_3.setAutoDraw(False)
        
        # *feedback0_dax9_3* updates
        if feedback0_dax9_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_3.frameNStart = frameN  # exact frame index
            feedback0_dax9_3.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_3, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_3.setAutoDraw(True)
        if feedback0_dax9_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_3.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_3.tStop = t  # not accounting for scr refresh
                feedback0_dax9_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_3, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_3.setAutoDraw(False)
        
        # *feedback_dax9_3* updates
        if feedback_dax9_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_3.frameNStart = frameN  # exact frame index
            feedback_dax9_3.tStart = t  # local t and not account for scr refresh
            feedback_dax9_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_3, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_3.setAutoDraw(True)
        if feedback_dax9_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_3.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_3.tStop = t  # not accounting for scr refresh
                feedback_dax9_3.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_3, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax11Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax11"-------
    for thisComponent in fb_dax11Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_3.started', feedback1_dax9_3.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_3.stopped', feedback1_dax9_3.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_3.started', feedback0_dax9_3.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_3.stopped', feedback0_dax9_3.tStopRefresh)
    trials_phase3.addData('feedback_dax9_3.started', feedback_dax9_3.tStartRefresh)
    trials_phase3.addData('feedback_dax9_3.stopped', feedback_dax9_3.tStopRefresh)
    
    # ------Prepare to start Routine "dax12"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax12.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_12.setFillColor('white')
    tr_12.setFillColor('white')
    cr_12.setFillColor('white')
    key_resp_dax12.keys = []
    key_resp_dax12.rt = []
    _key_resp_dax12_allKeys = []
    # keep track of which components have finished
    dax12Components = [dax11_corr2, star_12, tr_12, cr_12, key_resp_dax12, option1_7, option2_7, option3_7]
    for thisComponent in dax12Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    dax12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "dax12"-------
    while continueRoutine:
        # get current time
        t = dax12Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=dax12Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax11_corr2* updates
        if dax11_corr2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax11_corr2.frameNStart = frameN  # exact frame index
            dax11_corr2.tStart = t  # local t and not account for scr refresh
            dax11_corr2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax11_corr2, 'tStartRefresh')  # time at next scr refresh
            dax11_corr2.setAutoDraw(True)
        
        # *star_12* updates
        if star_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_12.frameNStart = frameN  # exact frame index
            star_12.tStart = t  # local t and not account for scr refresh
            star_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_12, 'tStartRefresh')  # time at next scr refresh
            star_12.setAutoDraw(True)
        
        # *tr_12* updates
        if tr_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            tr_12.frameNStart = frameN  # exact frame index
            tr_12.tStart = t  # local t and not account for scr refresh
            tr_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(tr_12, 'tStartRefresh')  # time at next scr refresh
            tr_12.setAutoDraw(True)
        
        # *cr_12* updates
        if cr_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cr_12.frameNStart = frameN  # exact frame index
            cr_12.tStart = t  # local t and not account for scr refresh
            cr_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cr_12, 'tStartRefresh')  # time at next scr refresh
            cr_12.setAutoDraw(True)
        
        # *key_resp_dax12* updates
        waitOnFlip = False
        if key_resp_dax12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_dax12.frameNStart = frameN  # exact frame index
            key_resp_dax12.tStart = t  # local t and not account for scr refresh
            key_resp_dax12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_dax12, 'tStartRefresh')  # time at next scr refresh
            key_resp_dax12.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_dax12.clock.reset)  # t=0 on next screen flip
        if key_resp_dax12.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_dax12.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_dax12_allKeys.extend(theseKeys)
            if len(_key_resp_dax12_allKeys):
                key_resp_dax12.keys = _key_resp_dax12_allKeys[-1].name  # just the last key pressed
                key_resp_dax12.rt = _key_resp_dax12_allKeys[-1].rt
                # was this correct?
                if (key_resp_dax12.keys == str('2')) or (key_resp_dax12.keys == '2'):
                    key_resp_dax12.corr = 1
                else:
                    key_resp_dax12.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_7* updates
        if option1_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_7.frameNStart = frameN  # exact frame index
            option1_7.tStart = t  # local t and not account for scr refresh
            option1_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_7, 'tStartRefresh')  # time at next scr refresh
            option1_7.setAutoDraw(True)
        
        # *option2_7* updates
        if option2_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_7.frameNStart = frameN  # exact frame index
            option2_7.tStart = t  # local t and not account for scr refresh
            option2_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_7, 'tStartRefresh')  # time at next scr refresh
            option2_7.setAutoDraw(True)
        
        # *option3_7* updates
        if option3_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_7.frameNStart = frameN  # exact frame index
            option3_7.tStart = t  # local t and not account for scr refresh
            option3_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_7, 'tStartRefresh')  # time at next scr refresh
            option3_7.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in dax12Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "dax12"-------
    for thisComponent in dax12Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax11_corr2.started', dax11_corr2.tStartRefresh)
    trials_phase3.addData('dax11_corr2.stopped', dax11_corr2.tStopRefresh)
    trials_phase3.addData('star_12.started', star_12.tStartRefresh)
    trials_phase3.addData('star_12.stopped', star_12.tStopRefresh)
    trials_phase3.addData('tr_12.started', tr_12.tStartRefresh)
    trials_phase3.addData('tr_12.stopped', tr_12.tStopRefresh)
    trials_phase3.addData('cr_12.started', cr_12.tStartRefresh)
    trials_phase3.addData('cr_12.stopped', cr_12.tStopRefresh)
    # check responses
    if key_resp_dax12.keys in ['', [], None]:  # No response was made
        key_resp_dax12.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_dax12.corr = 1;  # correct non-response
        else:
           key_resp_dax12.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_dax12.keys',key_resp_dax12.keys)
    trials_phase3.addData('key_resp_dax12.corr', key_resp_dax12.corr)
    if key_resp_dax12.keys != None:  # we had a response
        trials_phase3.addData('key_resp_dax12.rt', key_resp_dax12.rt)
    trials_phase3.addData('key_resp_dax12.started', key_resp_dax12.tStartRefresh)
    trials_phase3.addData('key_resp_dax12.stopped', key_resp_dax12.tStopRefresh)
    trials_phase3.addData('option1_7.started', option1_7.tStartRefresh)
    trials_phase3.addData('option1_7.stopped', option1_7.tStopRefresh)
    trials_phase3.addData('option2_7.started', option2_7.tStartRefresh)
    trials_phase3.addData('option2_7.stopped', option2_7.tStopRefresh)
    trials_phase3.addData('option3_7.started', option3_7.tStartRefresh)
    trials_phase3.addData('option3_7.stopped', option3_7.tStopRefresh)
    # the Routine "dax12" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_dax12"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_dax12.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_dax12.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_4.setText(msg1)
    feedback0_dax9_4.setText(msg0)
    feedback_dax9_4.setText(msg)
    # keep track of which components have finished
    fb_dax12Components = [feedback1_dax9_4, feedback0_dax9_4, feedback_dax9_4]
    for thisComponent in fb_dax12Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_dax12Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_dax12"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_dax12Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_dax12Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_4* updates
        if feedback1_dax9_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_4.frameNStart = frameN  # exact frame index
            feedback1_dax9_4.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_4, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_4.setAutoDraw(True)
        if feedback1_dax9_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_4.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_4.tStop = t  # not accounting for scr refresh
                feedback1_dax9_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_4, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_4.setAutoDraw(False)
        
        # *feedback0_dax9_4* updates
        if feedback0_dax9_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_4.frameNStart = frameN  # exact frame index
            feedback0_dax9_4.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_4, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_4.setAutoDraw(True)
        if feedback0_dax9_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_4.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_4.tStop = t  # not accounting for scr refresh
                feedback0_dax9_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_4, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_4.setAutoDraw(False)
        
        # *feedback_dax9_4* updates
        if feedback_dax9_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_4.frameNStart = frameN  # exact frame index
            feedback_dax9_4.tStart = t  # local t and not account for scr refresh
            feedback_dax9_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_4, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_4.setAutoDraw(True)
        if feedback_dax9_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_4.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_4.tStop = t  # not accounting for scr refresh
                feedback_dax9_4.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_4, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_4.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_dax12Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_dax12"-------
    for thisComponent in fb_dax12Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_4.started', feedback1_dax9_4.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_4.stopped', feedback1_dax9_4.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_4.started', feedback0_dax9_4.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_4.stopped', feedback0_dax9_4.tStopRefresh)
    trials_phase3.addData('feedback_dax9_4.started', feedback_dax9_4.tStartRefresh)
    trials_phase3.addData('feedback_dax9_4.stopped', feedback_dax9_4.tStopRefresh)
    
    # ------Prepare to start Routine "tas29"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax9.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_24.setFillColor('black')
    triange_12.setFillColor('black')
    cross_22.setFillColor('black')
    key_resp_tas29.keys = []
    key_resp_tas29.rt = []
    _key_resp_tas29_allKeys = []
    # keep track of which components have finished
    tas29Components = [dax9_corr2_12, star_24, triange_12, cross_22, key_resp_tas29, option1_19, option2_19, option3_18]
    for thisComponent in tas29Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    tas29Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "tas29"-------
    while continueRoutine:
        # get current time
        t = tas29Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=tas29Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_12* updates
        if dax9_corr2_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_12.frameNStart = frameN  # exact frame index
            dax9_corr2_12.tStart = t  # local t and not account for scr refresh
            dax9_corr2_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_12, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_12.setAutoDraw(True)
        
        # *star_24* updates
        if star_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_24.frameNStart = frameN  # exact frame index
            star_24.tStart = t  # local t and not account for scr refresh
            star_24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_24, 'tStartRefresh')  # time at next scr refresh
            star_24.setAutoDraw(True)
        
        # *triange_12* updates
        if triange_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_12.frameNStart = frameN  # exact frame index
            triange_12.tStart = t  # local t and not account for scr refresh
            triange_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_12, 'tStartRefresh')  # time at next scr refresh
            triange_12.setAutoDraw(True)
        
        # *cross_22* updates
        if cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_22.frameNStart = frameN  # exact frame index
            cross_22.tStart = t  # local t and not account for scr refresh
            cross_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_22, 'tStartRefresh')  # time at next scr refresh
            cross_22.setAutoDraw(True)
        
        # *key_resp_tas29* updates
        waitOnFlip = False
        if key_resp_tas29.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_tas29.frameNStart = frameN  # exact frame index
            key_resp_tas29.tStart = t  # local t and not account for scr refresh
            key_resp_tas29.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_tas29, 'tStartRefresh')  # time at next scr refresh
            key_resp_tas29.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_tas29.clock.reset)  # t=0 on next screen flip
        if key_resp_tas29.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_tas29.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_tas29_allKeys.extend(theseKeys)
            if len(_key_resp_tas29_allKeys):
                key_resp_tas29.keys = _key_resp_tas29_allKeys[-1].name  # just the last key pressed
                key_resp_tas29.rt = _key_resp_tas29_allKeys[-1].rt
                # was this correct?
                if (key_resp_tas29.keys == str('1')) or (key_resp_tas29.keys == '1'):
                    key_resp_tas29.corr = 1
                else:
                    key_resp_tas29.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_19* updates
        if option1_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_19.frameNStart = frameN  # exact frame index
            option1_19.tStart = t  # local t and not account for scr refresh
            option1_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_19, 'tStartRefresh')  # time at next scr refresh
            option1_19.setAutoDraw(True)
        
        # *option2_19* updates
        if option2_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_19.frameNStart = frameN  # exact frame index
            option2_19.tStart = t  # local t and not account for scr refresh
            option2_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_19, 'tStartRefresh')  # time at next scr refresh
            option2_19.setAutoDraw(True)
        
        # *option3_18* updates
        if option3_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_18.frameNStart = frameN  # exact frame index
            option3_18.tStart = t  # local t and not account for scr refresh
            option3_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_18, 'tStartRefresh')  # time at next scr refresh
            option3_18.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in tas29Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "tas29"-------
    for thisComponent in tas29Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax9_corr2_12.started', dax9_corr2_12.tStartRefresh)
    trials_phase3.addData('dax9_corr2_12.stopped', dax9_corr2_12.tStopRefresh)
    trials_phase3.addData('star_24.started', star_24.tStartRefresh)
    trials_phase3.addData('star_24.stopped', star_24.tStopRefresh)
    trials_phase3.addData('triange_12.started', triange_12.tStartRefresh)
    trials_phase3.addData('triange_12.stopped', triange_12.tStopRefresh)
    trials_phase3.addData('cross_22.started', cross_22.tStartRefresh)
    trials_phase3.addData('cross_22.stopped', cross_22.tStopRefresh)
    # check responses
    if key_resp_tas29.keys in ['', [], None]:  # No response was made
        key_resp_tas29.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_tas29.corr = 1;  # correct non-response
        else:
           key_resp_tas29.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_tas29.keys',key_resp_tas29.keys)
    trials_phase3.addData('key_resp_tas29.corr', key_resp_tas29.corr)
    if key_resp_tas29.keys != None:  # we had a response
        trials_phase3.addData('key_resp_tas29.rt', key_resp_tas29.rt)
    trials_phase3.addData('key_resp_tas29.started', key_resp_tas29.tStartRefresh)
    trials_phase3.addData('key_resp_tas29.stopped', key_resp_tas29.tStopRefresh)
    trials_phase3.addData('option1_19.started', option1_19.tStartRefresh)
    trials_phase3.addData('option1_19.stopped', option1_19.tStopRefresh)
    trials_phase3.addData('option2_19.started', option2_19.tStartRefresh)
    trials_phase3.addData('option2_19.stopped', option2_19.tStopRefresh)
    trials_phase3.addData('option3_18.started', option3_18.tStartRefresh)
    trials_phase3.addData('option3_18.stopped', option3_18.tStopRefresh)
    # the Routine "tas29" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_tas29"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_tas29.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_tas29.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_21.setText(msg1)
    feedback0_dax9_21.setText(msg0)
    feedback_dax9_21.setText(msg)
    # keep track of which components have finished
    fb_tas29Components = [feedback1_dax9_21, feedback0_dax9_21, feedback_dax9_21]
    for thisComponent in fb_tas29Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_tas29Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_tas29"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_tas29Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_tas29Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_21* updates
        if feedback1_dax9_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_21.frameNStart = frameN  # exact frame index
            feedback1_dax9_21.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_21, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_21.setAutoDraw(True)
        if feedback1_dax9_21.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_21.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_21.tStop = t  # not accounting for scr refresh
                feedback1_dax9_21.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_21, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_21.setAutoDraw(False)
        
        # *feedback0_dax9_21* updates
        if feedback0_dax9_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_21.frameNStart = frameN  # exact frame index
            feedback0_dax9_21.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_21, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_21.setAutoDraw(True)
        if feedback0_dax9_21.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_21.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_21.tStop = t  # not accounting for scr refresh
                feedback0_dax9_21.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_21, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_21.setAutoDraw(False)
        
        # *feedback_dax9_21* updates
        if feedback_dax9_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_21.frameNStart = frameN  # exact frame index
            feedback_dax9_21.tStart = t  # local t and not account for scr refresh
            feedback_dax9_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_21, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_21.setAutoDraw(True)
        if feedback_dax9_21.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_21.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_21.tStop = t  # not accounting for scr refresh
                feedback_dax9_21.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_21, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_21.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_tas29Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_tas29"-------
    for thisComponent in fb_tas29Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_21.started', feedback1_dax9_21.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_21.stopped', feedback1_dax9_21.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_21.started', feedback0_dax9_21.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_21.stopped', feedback0_dax9_21.tStopRefresh)
    trials_phase3.addData('feedback_dax9_21.started', feedback_dax9_21.tStartRefresh)
    trials_phase3.addData('feedback_dax9_21.stopped', feedback_dax9_21.tStopRefresh)
    
    # ------Prepare to start Routine "tas30"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax9.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_25.setFillColor('black')
    triange_13.setFillColor('black')
    cross_23.setFillColor('black')
    key_resp_tas30.keys = []
    key_resp_tas30.rt = []
    _key_resp_tas30_allKeys = []
    # keep track of which components have finished
    tas30Components = [dax9_corr2_13, star_25, triange_13, cross_23, key_resp_tas30, option1_20, option2_20, option3_19]
    for thisComponent in tas30Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    tas30Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "tas30"-------
    while continueRoutine:
        # get current time
        t = tas30Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=tas30Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_13* updates
        if dax9_corr2_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_13.frameNStart = frameN  # exact frame index
            dax9_corr2_13.tStart = t  # local t and not account for scr refresh
            dax9_corr2_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_13, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_13.setAutoDraw(True)
        
        # *star_25* updates
        if star_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_25.frameNStart = frameN  # exact frame index
            star_25.tStart = t  # local t and not account for scr refresh
            star_25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_25, 'tStartRefresh')  # time at next scr refresh
            star_25.setAutoDraw(True)
        
        # *triange_13* updates
        if triange_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_13.frameNStart = frameN  # exact frame index
            triange_13.tStart = t  # local t and not account for scr refresh
            triange_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_13, 'tStartRefresh')  # time at next scr refresh
            triange_13.setAutoDraw(True)
        
        # *cross_23* updates
        if cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_23.frameNStart = frameN  # exact frame index
            cross_23.tStart = t  # local t and not account for scr refresh
            cross_23.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_23, 'tStartRefresh')  # time at next scr refresh
            cross_23.setAutoDraw(True)
        
        # *key_resp_tas30* updates
        waitOnFlip = False
        if key_resp_tas30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_tas30.frameNStart = frameN  # exact frame index
            key_resp_tas30.tStart = t  # local t and not account for scr refresh
            key_resp_tas30.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_tas30, 'tStartRefresh')  # time at next scr refresh
            key_resp_tas30.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_tas30.clock.reset)  # t=0 on next screen flip
        if key_resp_tas30.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_tas30.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_tas30_allKeys.extend(theseKeys)
            if len(_key_resp_tas30_allKeys):
                key_resp_tas30.keys = _key_resp_tas30_allKeys[-1].name  # just the last key pressed
                key_resp_tas30.rt = _key_resp_tas30_allKeys[-1].rt
                # was this correct?
                if (key_resp_tas30.keys == str('2')) or (key_resp_tas30.keys == '2'):
                    key_resp_tas30.corr = 1
                else:
                    key_resp_tas30.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_20* updates
        if option1_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_20.frameNStart = frameN  # exact frame index
            option1_20.tStart = t  # local t and not account for scr refresh
            option1_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_20, 'tStartRefresh')  # time at next scr refresh
            option1_20.setAutoDraw(True)
        
        # *option2_20* updates
        if option2_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_20.frameNStart = frameN  # exact frame index
            option2_20.tStart = t  # local t and not account for scr refresh
            option2_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_20, 'tStartRefresh')  # time at next scr refresh
            option2_20.setAutoDraw(True)
        
        # *option3_19* updates
        if option3_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_19.frameNStart = frameN  # exact frame index
            option3_19.tStart = t  # local t and not account for scr refresh
            option3_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_19, 'tStartRefresh')  # time at next scr refresh
            option3_19.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in tas30Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "tas30"-------
    for thisComponent in tas30Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax9_corr2_13.started', dax9_corr2_13.tStartRefresh)
    trials_phase3.addData('dax9_corr2_13.stopped', dax9_corr2_13.tStopRefresh)
    trials_phase3.addData('star_25.started', star_25.tStartRefresh)
    trials_phase3.addData('star_25.stopped', star_25.tStopRefresh)
    trials_phase3.addData('triange_13.started', triange_13.tStartRefresh)
    trials_phase3.addData('triange_13.stopped', triange_13.tStopRefresh)
    trials_phase3.addData('cross_23.started', cross_23.tStartRefresh)
    trials_phase3.addData('cross_23.stopped', cross_23.tStopRefresh)
    # check responses
    if key_resp_tas30.keys in ['', [], None]:  # No response was made
        key_resp_tas30.keys = None
        # was no response the correct answer?!
        if str('2').lower() == 'none':
           key_resp_tas30.corr = 1;  # correct non-response
        else:
           key_resp_tas30.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_tas30.keys',key_resp_tas30.keys)
    trials_phase3.addData('key_resp_tas30.corr', key_resp_tas30.corr)
    if key_resp_tas30.keys != None:  # we had a response
        trials_phase3.addData('key_resp_tas30.rt', key_resp_tas30.rt)
    trials_phase3.addData('key_resp_tas30.started', key_resp_tas30.tStartRefresh)
    trials_phase3.addData('key_resp_tas30.stopped', key_resp_tas30.tStopRefresh)
    trials_phase3.addData('option1_20.started', option1_20.tStartRefresh)
    trials_phase3.addData('option1_20.stopped', option1_20.tStopRefresh)
    trials_phase3.addData('option2_20.started', option2_20.tStartRefresh)
    trials_phase3.addData('option2_20.stopped', option2_20.tStopRefresh)
    trials_phase3.addData('option3_19.started', option3_19.tStartRefresh)
    trials_phase3.addData('option3_19.stopped', option3_19.tStopRefresh)
    # the Routine "tas30" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_tas30"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_tas30.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_tas30.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_22.setText(msg1)
    feedback0_dax9_22.setText(msg0)
    feedback_dax9_22.setText(msg)
    # keep track of which components have finished
    fb_tas30Components = [feedback1_dax9_22, feedback0_dax9_22, feedback_dax9_22]
    for thisComponent in fb_tas30Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_tas30Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_tas30"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_tas30Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_tas30Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_22* updates
        if feedback1_dax9_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_22.frameNStart = frameN  # exact frame index
            feedback1_dax9_22.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_22, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_22.setAutoDraw(True)
        if feedback1_dax9_22.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_22.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_22.tStop = t  # not accounting for scr refresh
                feedback1_dax9_22.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_22, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_22.setAutoDraw(False)
        
        # *feedback0_dax9_22* updates
        if feedback0_dax9_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_22.frameNStart = frameN  # exact frame index
            feedback0_dax9_22.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_22, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_22.setAutoDraw(True)
        if feedback0_dax9_22.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_22.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_22.tStop = t  # not accounting for scr refresh
                feedback0_dax9_22.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_22, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_22.setAutoDraw(False)
        
        # *feedback_dax9_22* updates
        if feedback_dax9_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_22.frameNStart = frameN  # exact frame index
            feedback_dax9_22.tStart = t  # local t and not account for scr refresh
            feedback_dax9_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_22, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_22.setAutoDraw(True)
        if feedback_dax9_22.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_22.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_22.tStop = t  # not accounting for scr refresh
                feedback_dax9_22.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_22, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_22.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_tas30Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_tas30"-------
    for thisComponent in fb_tas30Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_22.started', feedback1_dax9_22.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_22.stopped', feedback1_dax9_22.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_22.started', feedback0_dax9_22.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_22.stopped', feedback0_dax9_22.tStopRefresh)
    trials_phase3.addData('feedback_dax9_22.started', feedback_dax9_22.tStartRefresh)
    trials_phase3.addData('feedback_dax9_22.stopped', feedback_dax9_22.tStopRefresh)
    
    # ------Prepare to start Routine "tas31"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax9.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_26.setFillColor('white')
    triange_14.setFillColor('white')
    cross_24.setFillColor('white')
    key_resp_tas31.keys = []
    key_resp_tas31.rt = []
    _key_resp_tas31_allKeys = []
    # keep track of which components have finished
    tas31Components = [dax9_corr2_14, star_26, triange_14, cross_24, key_resp_tas31, option1_21, option2_21, option3_20]
    for thisComponent in tas31Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    tas31Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "tas31"-------
    while continueRoutine:
        # get current time
        t = tas31Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=tas31Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_14* updates
        if dax9_corr2_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_14.frameNStart = frameN  # exact frame index
            dax9_corr2_14.tStart = t  # local t and not account for scr refresh
            dax9_corr2_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_14, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_14.setAutoDraw(True)
        
        # *star_26* updates
        if star_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_26.frameNStart = frameN  # exact frame index
            star_26.tStart = t  # local t and not account for scr refresh
            star_26.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_26, 'tStartRefresh')  # time at next scr refresh
            star_26.setAutoDraw(True)
        
        # *triange_14* updates
        if triange_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_14.frameNStart = frameN  # exact frame index
            triange_14.tStart = t  # local t and not account for scr refresh
            triange_14.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_14, 'tStartRefresh')  # time at next scr refresh
            triange_14.setAutoDraw(True)
        
        # *cross_24* updates
        if cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_24.frameNStart = frameN  # exact frame index
            cross_24.tStart = t  # local t and not account for scr refresh
            cross_24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_24, 'tStartRefresh')  # time at next scr refresh
            cross_24.setAutoDraw(True)
        
        # *key_resp_tas31* updates
        waitOnFlip = False
        if key_resp_tas31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_tas31.frameNStart = frameN  # exact frame index
            key_resp_tas31.tStart = t  # local t and not account for scr refresh
            key_resp_tas31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_tas31, 'tStartRefresh')  # time at next scr refresh
            key_resp_tas31.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_tas31.clock.reset)  # t=0 on next screen flip
        if key_resp_tas31.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_tas31.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_tas31_allKeys.extend(theseKeys)
            if len(_key_resp_tas31_allKeys):
                key_resp_tas31.keys = _key_resp_tas31_allKeys[-1].name  # just the last key pressed
                key_resp_tas31.rt = _key_resp_tas31_allKeys[-1].rt
                # was this correct?
                if (key_resp_tas31.keys == str('1')) or (key_resp_tas31.keys == '1'):
                    key_resp_tas31.corr = 1
                else:
                    key_resp_tas31.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_21* updates
        if option1_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_21.frameNStart = frameN  # exact frame index
            option1_21.tStart = t  # local t and not account for scr refresh
            option1_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_21, 'tStartRefresh')  # time at next scr refresh
            option1_21.setAutoDraw(True)
        
        # *option2_21* updates
        if option2_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_21.frameNStart = frameN  # exact frame index
            option2_21.tStart = t  # local t and not account for scr refresh
            option2_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_21, 'tStartRefresh')  # time at next scr refresh
            option2_21.setAutoDraw(True)
        
        # *option3_20* updates
        if option3_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_20.frameNStart = frameN  # exact frame index
            option3_20.tStart = t  # local t and not account for scr refresh
            option3_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_20, 'tStartRefresh')  # time at next scr refresh
            option3_20.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in tas31Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "tas31"-------
    for thisComponent in tas31Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax9_corr2_14.started', dax9_corr2_14.tStartRefresh)
    trials_phase3.addData('dax9_corr2_14.stopped', dax9_corr2_14.tStopRefresh)
    trials_phase3.addData('star_26.started', star_26.tStartRefresh)
    trials_phase3.addData('star_26.stopped', star_26.tStopRefresh)
    trials_phase3.addData('triange_14.started', triange_14.tStartRefresh)
    trials_phase3.addData('triange_14.stopped', triange_14.tStopRefresh)
    trials_phase3.addData('cross_24.started', cross_24.tStartRefresh)
    trials_phase3.addData('cross_24.stopped', cross_24.tStopRefresh)
    # check responses
    if key_resp_tas31.keys in ['', [], None]:  # No response was made
        key_resp_tas31.keys = None
        # was no response the correct answer?!
        if str('1').lower() == 'none':
           key_resp_tas31.corr = 1;  # correct non-response
        else:
           key_resp_tas31.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_tas31.keys',key_resp_tas31.keys)
    trials_phase3.addData('key_resp_tas31.corr', key_resp_tas31.corr)
    if key_resp_tas31.keys != None:  # we had a response
        trials_phase3.addData('key_resp_tas31.rt', key_resp_tas31.rt)
    trials_phase3.addData('key_resp_tas31.started', key_resp_tas31.tStartRefresh)
    trials_phase3.addData('key_resp_tas31.stopped', key_resp_tas31.tStopRefresh)
    trials_phase3.addData('option1_21.started', option1_21.tStartRefresh)
    trials_phase3.addData('option1_21.stopped', option1_21.tStopRefresh)
    trials_phase3.addData('option2_21.started', option2_21.tStartRefresh)
    trials_phase3.addData('option2_21.stopped', option2_21.tStopRefresh)
    trials_phase3.addData('option3_20.started', option3_20.tStartRefresh)
    trials_phase3.addData('option3_20.stopped', option3_20.tStopRefresh)
    # the Routine "tas31" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_tas31"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_tas31.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_tas31.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_23.setText(msg1)
    feedback0_dax9_23.setText(msg0)
    feedback_dax9_23.setText(msg)
    # keep track of which components have finished
    fb_tas31Components = [feedback1_dax9_23, feedback0_dax9_23, feedback_dax9_23]
    for thisComponent in fb_tas31Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_tas31Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_tas31"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_tas31Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_tas31Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_23* updates
        if feedback1_dax9_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_23.frameNStart = frameN  # exact frame index
            feedback1_dax9_23.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_23.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_23, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_23.setAutoDraw(True)
        if feedback1_dax9_23.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_23.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_23.tStop = t  # not accounting for scr refresh
                feedback1_dax9_23.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_23, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_23.setAutoDraw(False)
        
        # *feedback0_dax9_23* updates
        if feedback0_dax9_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_23.frameNStart = frameN  # exact frame index
            feedback0_dax9_23.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_23.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_23, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_23.setAutoDraw(True)
        if feedback0_dax9_23.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_23.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_23.tStop = t  # not accounting for scr refresh
                feedback0_dax9_23.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_23, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_23.setAutoDraw(False)
        
        # *feedback_dax9_23* updates
        if feedback_dax9_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_23.frameNStart = frameN  # exact frame index
            feedback_dax9_23.tStart = t  # local t and not account for scr refresh
            feedback_dax9_23.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_23, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_23.setAutoDraw(True)
        if feedback_dax9_23.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_23.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_23.tStop = t  # not accounting for scr refresh
                feedback_dax9_23.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_23, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_23.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_tas31Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_tas31"-------
    for thisComponent in fb_tas31Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_23.started', feedback1_dax9_23.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_23.stopped', feedback1_dax9_23.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_23.started', feedback0_dax9_23.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_23.stopped', feedback0_dax9_23.tStopRefresh)
    trials_phase3.addData('feedback_dax9_23.started', feedback_dax9_23.tStartRefresh)
    trials_phase3.addData('feedback_dax9_23.stopped', feedback_dax9_23.tStopRefresh)
    
    # ------Prepare to start Routine "tas32"-------
    continueRoutine = True
    # update component parameters for each repeat
    #if not key_resp1.keys:
    #    msg="Allowed Keys: 1,2,3"
    if key_resp_dax9.corr: #stored on last run routine 
        msg1="Correct!"
        msg0=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
    star_27.setFillColor('white')
    triange_15.setFillColor('white')
    cross_25.setFillColor('white')
    key_resp_tas32.keys = []
    key_resp_tas32.rt = []
    _key_resp_tas32_allKeys = []
    # keep track of which components have finished
    tas32Components = [dax9_corr2_15, star_27, triange_15, cross_25, key_resp_tas32, option1_22, option2_22, option3_21]
    for thisComponent in tas32Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    tas32Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "tas32"-------
    while continueRoutine:
        # get current time
        t = tas32Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=tas32Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *dax9_corr2_15* updates
        if dax9_corr2_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            dax9_corr2_15.frameNStart = frameN  # exact frame index
            dax9_corr2_15.tStart = t  # local t and not account for scr refresh
            dax9_corr2_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(dax9_corr2_15, 'tStartRefresh')  # time at next scr refresh
            dax9_corr2_15.setAutoDraw(True)
        
        # *star_27* updates
        if star_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            star_27.frameNStart = frameN  # exact frame index
            star_27.tStart = t  # local t and not account for scr refresh
            star_27.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(star_27, 'tStartRefresh')  # time at next scr refresh
            star_27.setAutoDraw(True)
        
        # *triange_15* updates
        if triange_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            triange_15.frameNStart = frameN  # exact frame index
            triange_15.tStart = t  # local t and not account for scr refresh
            triange_15.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(triange_15, 'tStartRefresh')  # time at next scr refresh
            triange_15.setAutoDraw(True)
        
        # *cross_25* updates
        if cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            cross_25.frameNStart = frameN  # exact frame index
            cross_25.tStart = t  # local t and not account for scr refresh
            cross_25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(cross_25, 'tStartRefresh')  # time at next scr refresh
            cross_25.setAutoDraw(True)
        
        # *key_resp_tas32* updates
        waitOnFlip = False
        if key_resp_tas32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_tas32.frameNStart = frameN  # exact frame index
            key_resp_tas32.tStart = t  # local t and not account for scr refresh
            key_resp_tas32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_tas32, 'tStartRefresh')  # time at next scr refresh
            key_resp_tas32.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_tas32.clock.reset)  # t=0 on next screen flip
        if key_resp_tas32.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_tas32.getKeys(keyList=['1', '2', '3'], waitRelease=False)
            _key_resp_tas32_allKeys.extend(theseKeys)
            if len(_key_resp_tas32_allKeys):
                key_resp_tas32.keys = _key_resp_tas32_allKeys[-1].name  # just the last key pressed
                key_resp_tas32.rt = _key_resp_tas32_allKeys[-1].rt
                # was this correct?
                if (key_resp_tas32.keys == str('3')) or (key_resp_tas32.keys == '3'):
                    key_resp_tas32.corr = 1
                else:
                    key_resp_tas32.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *option1_22* updates
        if option1_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option1_22.frameNStart = frameN  # exact frame index
            option1_22.tStart = t  # local t and not account for scr refresh
            option1_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option1_22, 'tStartRefresh')  # time at next scr refresh
            option1_22.setAutoDraw(True)
        
        # *option2_22* updates
        if option2_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option2_22.frameNStart = frameN  # exact frame index
            option2_22.tStart = t  # local t and not account for scr refresh
            option2_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option2_22, 'tStartRefresh')  # time at next scr refresh
            option2_22.setAutoDraw(True)
        
        # *option3_21* updates
        if option3_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            option3_21.frameNStart = frameN  # exact frame index
            option3_21.tStart = t  # local t and not account for scr refresh
            option3_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(option3_21, 'tStartRefresh')  # time at next scr refresh
            option3_21.setAutoDraw(True)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in tas32Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "tas32"-------
    for thisComponent in tas32Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('dax9_corr2_15.started', dax9_corr2_15.tStartRefresh)
    trials_phase3.addData('dax9_corr2_15.stopped', dax9_corr2_15.tStopRefresh)
    trials_phase3.addData('star_27.started', star_27.tStartRefresh)
    trials_phase3.addData('star_27.stopped', star_27.tStopRefresh)
    trials_phase3.addData('triange_15.started', triange_15.tStartRefresh)
    trials_phase3.addData('triange_15.stopped', triange_15.tStopRefresh)
    trials_phase3.addData('cross_25.started', cross_25.tStartRefresh)
    trials_phase3.addData('cross_25.stopped', cross_25.tStopRefresh)
    # check responses
    if key_resp_tas32.keys in ['', [], None]:  # No response was made
        key_resp_tas32.keys = None
        # was no response the correct answer?!
        if str('3').lower() == 'none':
           key_resp_tas32.corr = 1;  # correct non-response
        else:
           key_resp_tas32.corr = 0;  # failed to respond (incorrectly)
    # store data for trials_phase3 (TrialHandler)
    trials_phase3.addData('key_resp_tas32.keys',key_resp_tas32.keys)
    trials_phase3.addData('key_resp_tas32.corr', key_resp_tas32.corr)
    if key_resp_tas32.keys != None:  # we had a response
        trials_phase3.addData('key_resp_tas32.rt', key_resp_tas32.rt)
    trials_phase3.addData('key_resp_tas32.started', key_resp_tas32.tStartRefresh)
    trials_phase3.addData('key_resp_tas32.stopped', key_resp_tas32.tStopRefresh)
    trials_phase3.addData('option1_22.started', option1_22.tStartRefresh)
    trials_phase3.addData('option1_22.stopped', option1_22.tStopRefresh)
    trials_phase3.addData('option2_22.started', option2_22.tStartRefresh)
    trials_phase3.addData('option2_22.stopped', option2_22.tStopRefresh)
    trials_phase3.addData('option3_21.started', option3_21.tStartRefresh)
    trials_phase3.addData('option3_21.stopped', option3_21.tStopRefresh)
    # the Routine "tas32" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # ------Prepare to start Routine "fb_tas32"-------
    continueRoutine = True
    routineTimer.add(4.000000)
    # update component parameters for each repeat
    if not key_resp_tas32.keys :
        msg="Allowed Keys: 1, 2, 3"
        msg1=""
        msg0=""
    elif key_resp_tas32.corr:   #stored on last run routine 
        msg1="Correct!"
        msg0=""
        msg=""
    else:
        msg0="Oops! That was wrong"
        msg1=""
        msg=""
    feedback1_dax9_24.setText(msg1)
    feedback0_dax9_24.setText(msg0)
    feedback_dax9_24.setText(msg)
    # keep track of which components have finished
    fb_tas32Components = [feedback1_dax9_24, feedback0_dax9_24, feedback_dax9_24]
    for thisComponent in fb_tas32Components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    fb_tas32Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "fb_tas32"-------
    while continueRoutine and routineTimer.getTime() > 0:
        # get current time
        t = fb_tas32Clock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=fb_tas32Clock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *feedback1_dax9_24* updates
        if feedback1_dax9_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback1_dax9_24.frameNStart = frameN  # exact frame index
            feedback1_dax9_24.tStart = t  # local t and not account for scr refresh
            feedback1_dax9_24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback1_dax9_24, 'tStartRefresh')  # time at next scr refresh
            feedback1_dax9_24.setAutoDraw(True)
        if feedback1_dax9_24.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback1_dax9_24.tStartRefresh + 2.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback1_dax9_24.tStop = t  # not accounting for scr refresh
                feedback1_dax9_24.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback1_dax9_24, 'tStopRefresh')  # time at next scr refresh
                feedback1_dax9_24.setAutoDraw(False)
        
        # *feedback0_dax9_24* updates
        if feedback0_dax9_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback0_dax9_24.frameNStart = frameN  # exact frame index
            feedback0_dax9_24.tStart = t  # local t and not account for scr refresh
            feedback0_dax9_24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback0_dax9_24, 'tStartRefresh')  # time at next scr refresh
            feedback0_dax9_24.setAutoDraw(True)
        if feedback0_dax9_24.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback0_dax9_24.tStartRefresh + 4.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback0_dax9_24.tStop = t  # not accounting for scr refresh
                feedback0_dax9_24.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback0_dax9_24, 'tStopRefresh')  # time at next scr refresh
                feedback0_dax9_24.setAutoDraw(False)
        
        # *feedback_dax9_24* updates
        if feedback_dax9_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            feedback_dax9_24.frameNStart = frameN  # exact frame index
            feedback_dax9_24.tStart = t  # local t and not account for scr refresh
            feedback_dax9_24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(feedback_dax9_24, 'tStartRefresh')  # time at next scr refresh
            feedback_dax9_24.setAutoDraw(True)
        if feedback_dax9_24.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > feedback_dax9_24.tStartRefresh + 3.0-frameTolerance:
                # keep track of stop time/frame for later
                feedback_dax9_24.tStop = t  # not accounting for scr refresh
                feedback_dax9_24.frameNStop = frameN  # exact frame index
                win.timeOnFlip(feedback_dax9_24, 'tStopRefresh')  # time at next scr refresh
                feedback_dax9_24.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in fb_tas32Components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "fb_tas32"-------
    for thisComponent in fb_tas32Components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('feedback1_dax9_24.started', feedback1_dax9_24.tStartRefresh)
    trials_phase3.addData('feedback1_dax9_24.stopped', feedback1_dax9_24.tStopRefresh)
    trials_phase3.addData('feedback0_dax9_24.started', feedback0_dax9_24.tStartRefresh)
    trials_phase3.addData('feedback0_dax9_24.stopped', feedback0_dax9_24.tStopRefresh)
    trials_phase3.addData('feedback_dax9_24.started', feedback_dax9_24.tStartRefresh)
    trials_phase3.addData('feedback_dax9_24.stopped', feedback_dax9_24.tStopRefresh)
    
    # ------Prepare to start Routine "proceed"-------
    continueRoutine = True
    # update component parameters for each repeat
    key_resp_6.keys = []
    key_resp_6.rt = []
    _key_resp_6_allKeys = []
    # keep track of which components have finished
    proceedComponents = [text2, key_resp_6]
    for thisComponent in proceedComponents:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    proceedClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
    frameN = -1
    
    # -------Run Routine "proceed"-------
    while continueRoutine:
        # get current time
        t = proceedClock.getTime()
        tThisFlip = win.getFutureFlipTime(clock=proceedClock)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text2* updates
        if text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text2.frameNStart = frameN  # exact frame index
            text2.tStart = t  # local t and not account for scr refresh
            text2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text2, 'tStartRefresh')  # time at next scr refresh
            text2.setAutoDraw(True)
        
        # *key_resp_6* updates
        waitOnFlip = False
        if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_6.frameNStart = frameN  # exact frame index
            key_resp_6.tStart = t  # local t and not account for scr refresh
            key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
            key_resp_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
            _key_resp_6_allKeys.extend(theseKeys)
            if len(_key_resp_6_allKeys):
                key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
                key_resp_6.rt = _key_resp_6_allKeys[-1].rt
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
            core.quit()
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in proceedComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # -------Ending Routine "proceed"-------
    for thisComponent in proceedComponents:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    trials_phase3.addData('text2.started', text2.tStartRefresh)
    trials_phase3.addData('text2.stopped', text2.tStopRefresh)
    # check responses
    if key_resp_6.keys in ['', [], None]:  # No response was made
        key_resp_6.keys = None
    trials_phase3.addData('key_resp_6.keys',key_resp_6.keys)
    if key_resp_6.keys != None:  # we had a response
        trials_phase3.addData('key_resp_6.rt', key_resp_6.rt)
    trials_phase3.addData('key_resp_6.started', key_resp_6.tStartRefresh)
    trials_phase3.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
    # the Routine "proceed" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # set up handler to look after randomisation of conditions etc
    trials_test3 = data.TrialHandler(nReps=1.0, method='random', 
        extraInfo=expInfo, originPath=-1,
        trialList=[None],
        seed=None, name='trials_test3')
    thisExp.addLoop(trials_test3)  # add the loop to the experiment
    thisTrials_test3 = trials_test3.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_test3.rgb)
    if thisTrials_test3 != None:
        for paramName in thisTrials_test3:
            exec('{} = thisTrials_test3[paramName]'.format(paramName))
    
    for thisTrials_test3 in trials_test3:
        currentLoop = trials_test3
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_test3.rgb)
        if thisTrials_test3 != None:
            for paramName in thisTrials_test3:
                exec('{} = thisTrials_test3[paramName]'.format(paramName))
        
        # ------Prepare to start Routine "test2dax9"-------
        continueRoutine = True
        # update component parameters for each repeat
        number_correct3 = 0
        star_28.setFillColor('black')
        triange_16.setFillColor('black')
        cross_26.setFillColor('black')
        key_resp_dax9_2.keys = []
        key_resp_dax9_2.rt = []
        _key_resp_dax9_2_allKeys = []
        # keep track of which components have finished
        test2dax9Components = [dax9_corr2_16, star_28, triange_16, cross_26, key_resp_dax9_2, option1_23, option2_23, option3_22]
        for thisComponent in test2dax9Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        test2dax9Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "test2dax9"-------
        while continueRoutine:
            # get current time
            t = test2dax9Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=test2dax9Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *dax9_corr2_16* updates
            if dax9_corr2_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                dax9_corr2_16.frameNStart = frameN  # exact frame index
                dax9_corr2_16.tStart = t  # local t and not account for scr refresh
                dax9_corr2_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(dax9_corr2_16, 'tStartRefresh')  # time at next scr refresh
                dax9_corr2_16.setAutoDraw(True)
            
            # *star_28* updates
            if star_28.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                star_28.frameNStart = frameN  # exact frame index
                star_28.tStart = t  # local t and not account for scr refresh
                star_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(star_28, 'tStartRefresh')  # time at next scr refresh
                star_28.setAutoDraw(True)
            
            # *triange_16* updates
            if triange_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                triange_16.frameNStart = frameN  # exact frame index
                triange_16.tStart = t  # local t and not account for scr refresh
                triange_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(triange_16, 'tStartRefresh')  # time at next scr refresh
                triange_16.setAutoDraw(True)
            
            # *cross_26* updates
            if cross_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cross_26.frameNStart = frameN  # exact frame index
                cross_26.tStart = t  # local t and not account for scr refresh
                cross_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cross_26, 'tStartRefresh')  # time at next scr refresh
                cross_26.setAutoDraw(True)
            
            # *key_resp_dax9_2* updates
            waitOnFlip = False
            if key_resp_dax9_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_dax9_2.frameNStart = frameN  # exact frame index
                key_resp_dax9_2.tStart = t  # local t and not account for scr refresh
                key_resp_dax9_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_dax9_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_dax9_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_dax9_2.clock.reset)  # t=0 on next screen flip
            if key_resp_dax9_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_dax9_2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
                _key_resp_dax9_2_allKeys.extend(theseKeys)
                if len(_key_resp_dax9_2_allKeys):
                    key_resp_dax9_2.keys = _key_resp_dax9_2_allKeys[-1].name  # just the last key pressed
                    key_resp_dax9_2.rt = _key_resp_dax9_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_dax9_2.keys == str('2')) or (key_resp_dax9_2.keys == '2'):
                        key_resp_dax9_2.corr = 1
                    else:
                        key_resp_dax9_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *option1_23* updates
            if option1_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_23.frameNStart = frameN  # exact frame index
                option1_23.tStart = t  # local t and not account for scr refresh
                option1_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_23, 'tStartRefresh')  # time at next scr refresh
                option1_23.setAutoDraw(True)
            
            # *option2_23* updates
            if option2_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_23.frameNStart = frameN  # exact frame index
                option2_23.tStart = t  # local t and not account for scr refresh
                option2_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_23, 'tStartRefresh')  # time at next scr refresh
                option2_23.setAutoDraw(True)
            
            # *option3_22* updates
            if option3_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option3_22.frameNStart = frameN  # exact frame index
                option3_22.tStart = t  # local t and not account for scr refresh
                option3_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option3_22, 'tStartRefresh')  # time at next scr refresh
                option3_22.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in test2dax9Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "test2dax9"-------
        for thisComponent in test2dax9Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_dax9_2.corr: 
            number_correct3 = number_correct3 + 1
            print('Correct3: ' + str(number_correct3))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct3 == 2:
            print('total Correct2: ' + str(number_correct3))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase3.finished = True
        else:
            print('flag2!')
            trials_phase3.finished = False
        trials_test3.addData('dax9_corr2_16.started', dax9_corr2_16.tStartRefresh)
        trials_test3.addData('dax9_corr2_16.stopped', dax9_corr2_16.tStopRefresh)
        trials_test3.addData('star_28.started', star_28.tStartRefresh)
        trials_test3.addData('star_28.stopped', star_28.tStopRefresh)
        trials_test3.addData('triange_16.started', triange_16.tStartRefresh)
        trials_test3.addData('triange_16.stopped', triange_16.tStopRefresh)
        trials_test3.addData('cross_26.started', cross_26.tStartRefresh)
        trials_test3.addData('cross_26.stopped', cross_26.tStopRefresh)
        # check responses
        if key_resp_dax9_2.keys in ['', [], None]:  # No response was made
            key_resp_dax9_2.keys = None
            # was no response the correct answer?!
            if str('2').lower() == 'none':
               key_resp_dax9_2.corr = 1;  # correct non-response
            else:
               key_resp_dax9_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test3 (TrialHandler)
        trials_test3.addData('key_resp_dax9_2.keys',key_resp_dax9_2.keys)
        trials_test3.addData('key_resp_dax9_2.corr', key_resp_dax9_2.corr)
        if key_resp_dax9_2.keys != None:  # we had a response
            trials_test3.addData('key_resp_dax9_2.rt', key_resp_dax9_2.rt)
        trials_test3.addData('key_resp_dax9_2.started', key_resp_dax9_2.tStartRefresh)
        trials_test3.addData('key_resp_dax9_2.stopped', key_resp_dax9_2.tStopRefresh)
        trials_test3.addData('option1_23.started', option1_23.tStartRefresh)
        trials_test3.addData('option1_23.stopped', option1_23.tStopRefresh)
        trials_test3.addData('option2_23.started', option2_23.tStartRefresh)
        trials_test3.addData('option2_23.stopped', option2_23.tStopRefresh)
        trials_test3.addData('option3_22.started', option3_22.tStartRefresh)
        trials_test3.addData('option3_22.stopped', option3_22.tStopRefresh)
        # the Routine "test2dax9" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # ------Prepare to start Routine "test2tas32"-------
        continueRoutine = True
        # update component parameters for each repeat
        star_29.setFillColor('white')
        triange_17.setFillColor('white')
        cross_27.setFillColor('white')
        key_resp_tas32_2.keys = []
        key_resp_tas32_2.rt = []
        _key_resp_tas32_2_allKeys = []
        # keep track of which components have finished
        test2tas32Components = [dax9_corr2_17, star_29, triange_17, cross_27, key_resp_tas32_2, option1_24, option2_24, option3_23]
        for thisComponent in test2tas32Components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        test2tas32Clock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
        frameN = -1
        
        # -------Run Routine "test2tas32"-------
        while continueRoutine:
            # get current time
            t = test2tas32Clock.getTime()
            tThisFlip = win.getFutureFlipTime(clock=test2tas32Clock)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *dax9_corr2_17* updates
            if dax9_corr2_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                dax9_corr2_17.frameNStart = frameN  # exact frame index
                dax9_corr2_17.tStart = t  # local t and not account for scr refresh
                dax9_corr2_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(dax9_corr2_17, 'tStartRefresh')  # time at next scr refresh
                dax9_corr2_17.setAutoDraw(True)
            
            # *star_29* updates
            if star_29.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                star_29.frameNStart = frameN  # exact frame index
                star_29.tStart = t  # local t and not account for scr refresh
                star_29.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(star_29, 'tStartRefresh')  # time at next scr refresh
                star_29.setAutoDraw(True)
            
            # *triange_17* updates
            if triange_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                triange_17.frameNStart = frameN  # exact frame index
                triange_17.tStart = t  # local t and not account for scr refresh
                triange_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(triange_17, 'tStartRefresh')  # time at next scr refresh
                triange_17.setAutoDraw(True)
            
            # *cross_27* updates
            if cross_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                cross_27.frameNStart = frameN  # exact frame index
                cross_27.tStart = t  # local t and not account for scr refresh
                cross_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(cross_27, 'tStartRefresh')  # time at next scr refresh
                cross_27.setAutoDraw(True)
            
            # *key_resp_tas32_2* updates
            waitOnFlip = False
            if key_resp_tas32_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                key_resp_tas32_2.frameNStart = frameN  # exact frame index
                key_resp_tas32_2.tStart = t  # local t and not account for scr refresh
                key_resp_tas32_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_tas32_2, 'tStartRefresh')  # time at next scr refresh
                key_resp_tas32_2.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_tas32_2.clock.reset)  # t=0 on next screen flip
            if key_resp_tas32_2.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_tas32_2.getKeys(keyList=['1', '2', '3'], waitRelease=False)
                _key_resp_tas32_2_allKeys.extend(theseKeys)
                if len(_key_resp_tas32_2_allKeys):
                    key_resp_tas32_2.keys = _key_resp_tas32_2_allKeys[-1].name  # just the last key pressed
                    key_resp_tas32_2.rt = _key_resp_tas32_2_allKeys[-1].rt
                    # was this correct?
                    if (key_resp_tas32_2.keys == str('3')) or (key_resp_tas32_2.keys == '3'):
                        key_resp_tas32_2.corr = 1
                    else:
                        key_resp_tas32_2.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *option1_24* updates
            if option1_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option1_24.frameNStart = frameN  # exact frame index
                option1_24.tStart = t  # local t and not account for scr refresh
                option1_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option1_24, 'tStartRefresh')  # time at next scr refresh
                option1_24.setAutoDraw(True)
            
            # *option2_24* updates
            if option2_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option2_24.frameNStart = frameN  # exact frame index
                option2_24.tStart = t  # local t and not account for scr refresh
                option2_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option2_24, 'tStartRefresh')  # time at next scr refresh
                option2_24.setAutoDraw(True)
            
            # *option3_23* updates
            if option3_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                option3_23.frameNStart = frameN  # exact frame index
                option3_23.tStart = t  # local t and not account for scr refresh
                option3_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(option3_23, 'tStartRefresh')  # time at next scr refresh
                option3_23.setAutoDraw(True)
            
            # check for quit (typically the Esc key)
            if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
                core.quit()
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in test2tas32Components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # -------Ending Routine "test2tas32"-------
        for thisComponent in test2tas32Components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        #''' update the number correct:'''
        if key_resp_tas32_2.corr: 
            number_correct3 = number_correct3 + 1
            print('Correct3: ' + str(number_correct3))
        #     ''' if this is the final repetition, check the proportion correct.
        #         (am avoiding hard coding the value '12' for flexibility):'''
        if number_correct3 == 2:
            print('total Correct2: ' + str(number_correct3))
        # ''' terminate the outer loop so no more practice happens:'''
            trials_phase3.finished = True
        else:
            print('flag2!')
            trials_phase3.finished = False
        trials_test3.addData('dax9_corr2_17.started', dax9_corr2_17.tStartRefresh)
        trials_test3.addData('dax9_corr2_17.stopped', dax9_corr2_17.tStopRefresh)
        trials_test3.addData('star_29.started', star_29.tStartRefresh)
        trials_test3.addData('star_29.stopped', star_29.tStopRefresh)
        trials_test3.addData('triange_17.started', triange_17.tStartRefresh)
        trials_test3.addData('triange_17.stopped', triange_17.tStopRefresh)
        trials_test3.addData('cross_27.started', cross_27.tStartRefresh)
        trials_test3.addData('cross_27.stopped', cross_27.tStopRefresh)
        # check responses
        if key_resp_tas32_2.keys in ['', [], None]:  # No response was made
            key_resp_tas32_2.keys = None
            # was no response the correct answer?!
            if str('3').lower() == 'none':
               key_resp_tas32_2.corr = 1;  # correct non-response
            else:
               key_resp_tas32_2.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_test3 (TrialHandler)
        trials_test3.addData('key_resp_tas32_2.keys',key_resp_tas32_2.keys)
        trials_test3.addData('key_resp_tas32_2.corr', key_resp_tas32_2.corr)
        if key_resp_tas32_2.keys != None:  # we had a response
            trials_test3.addData('key_resp_tas32_2.rt', key_resp_tas32_2.rt)
        trials_test3.addData('key_resp_tas32_2.started', key_resp_tas32_2.tStartRefresh)
        trials_test3.addData('key_resp_tas32_2.stopped', key_resp_tas32_2.tStopRefresh)
        trials_test3.addData('option1_24.started', option1_24.tStartRefresh)
        trials_test3.addData('option1_24.stopped', option1_24.tStopRefresh)
        trials_test3.addData('option2_24.started', option2_24.tStartRefresh)
        trials_test3.addData('option2_24.stopped', option2_24.tStopRefresh)
        trials_test3.addData('option3_23.started', option3_23.tStartRefresh)
        trials_test3.addData('option3_23.stopped', option3_23.tStopRefresh)
        # the Routine "test2tas32" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 1.0 repeats of 'trials_test3'
    
    thisExp.nextEntry()
    
# completed 4.0 repeats of 'trials_phase3'


# ------Prepare to start Routine "proceed"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_6.keys = []
key_resp_6.rt = []
_key_resp_6_allKeys = []
# keep track of which components have finished
proceedComponents = [text2, key_resp_6]
for thisComponent in proceedComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
proceedClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "proceed"-------
while continueRoutine:
    # get current time
    t = proceedClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=proceedClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *text2* updates
    if text2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text2.frameNStart = frameN  # exact frame index
        text2.tStart = t  # local t and not account for scr refresh
        text2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text2, 'tStartRefresh')  # time at next scr refresh
        text2.setAutoDraw(True)
    
    # *key_resp_6* updates
    waitOnFlip = False
    if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_6.frameNStart = frameN  # exact frame index
        key_resp_6.tStart = t  # local t and not account for scr refresh
        key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
        key_resp_6.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_6.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_6.getKeys(keyList=['space'], waitRelease=False)
        _key_resp_6_allKeys.extend(theseKeys)
        if len(_key_resp_6_allKeys):
            key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
            key_resp_6.rt = _key_resp_6_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in proceedComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "proceed"-------
for thisComponent in proceedComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('text2.started', text2.tStartRefresh)
thisExp.addData('text2.stopped', text2.tStopRefresh)
# check responses
if key_resp_6.keys in ['', [], None]:  # No response was made
    key_resp_6.keys = None
thisExp.addData('key_resp_6.keys',key_resp_6.keys)
if key_resp_6.keys != None:  # we had a response
    thisExp.addData('key_resp_6.rt', key_resp_6.rt)
thisExp.addData('key_resp_6.started', key_resp_6.tStartRefresh)
thisExp.addData('key_resp_6.stopped', key_resp_6.tStopRefresh)
thisExp.nextEntry()
# the Routine "proceed" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "blank"-------
continueRoutine = True
routineTimer.add(0.200000)
# update component parameters for each repeat
# keep track of which components have finished
blankComponents = [blank500ms]
for thisComponent in blankComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
blankClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "blank"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = blankClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=blankClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *blank500ms* updates
    if blank500ms.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        blank500ms.frameNStart = frameN  # exact frame index
        blank500ms.tStart = t  # local t and not account for scr refresh
        blank500ms.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(blank500ms, 'tStartRefresh')  # time at next scr refresh
        blank500ms.setAutoDraw(True)
    if blank500ms.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > blank500ms.tStartRefresh + 0.2-frameTolerance:
            # keep track of stop time/frame for later
            blank500ms.tStop = t  # not accounting for scr refresh
            blank500ms.frameNStop = frameN  # exact frame index
            win.timeOnFlip(blank500ms, 'tStopRefresh')  # time at next scr refresh
            blank500ms.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in blankComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "blank"-------
for thisComponent in blankComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('blank500ms.started', blank500ms.tStartRefresh)
thisExp.addData('blank500ms.stopped', blank500ms.tStopRefresh)

# ------Prepare to start Routine "test"-------
continueRoutine = True
# update component parameters for each repeat
key_resp_t1_3.keys = []
key_resp_t1_3.rt = []
_key_resp_t1_3_allKeys = []
t1_triangle1_3.setFillColor('black')
t1_rectangle1_3.setFillColor('black')
# keep track of which components have finished
testComponents = [key_resp_t1_3, t1_zud_3, t1_triangle1_3, t1_rectangle1_3, option1_critical_13, option2_critical_13]
for thisComponent in testComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
testClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "test"-------
while continueRoutine:
    # get current time
    t = testClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=testClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *key_resp_t1_3* updates
    waitOnFlip = False
    if key_resp_t1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_t1_3.frameNStart = frameN  # exact frame index
        key_resp_t1_3.tStart = t  # local t and not account for scr refresh
        key_resp_t1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_t1_3, 'tStartRefresh')  # time at next scr refresh
        key_resp_t1_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_t1_3.clock.reset)  # t=0 on next screen flip
    if key_resp_t1_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_t1_3.getKeys(keyList=['1', '2'], waitRelease=False)
        _key_resp_t1_3_allKeys.extend(theseKeys)
        if len(_key_resp_t1_3_allKeys):
            key_resp_t1_3.keys = _key_resp_t1_3_allKeys[-1].name  # just the last key pressed
            key_resp_t1_3.rt = _key_resp_t1_3_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # *t1_zud_3* updates
    if t1_zud_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_zud_3.frameNStart = frameN  # exact frame index
        t1_zud_3.tStart = t  # local t and not account for scr refresh
        t1_zud_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_zud_3, 'tStartRefresh')  # time at next scr refresh
        t1_zud_3.setAutoDraw(True)
    
    # *t1_triangle1_3* updates
    if t1_triangle1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_triangle1_3.frameNStart = frameN  # exact frame index
        t1_triangle1_3.tStart = t  # local t and not account for scr refresh
        t1_triangle1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_triangle1_3, 'tStartRefresh')  # time at next scr refresh
        t1_triangle1_3.setAutoDraw(True)
    
    # *t1_rectangle1_3* updates
    if t1_rectangle1_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        t1_rectangle1_3.frameNStart = frameN  # exact frame index
        t1_rectangle1_3.tStart = t  # local t and not account for scr refresh
        t1_rectangle1_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(t1_rectangle1_3, 'tStartRefresh')  # time at next scr refresh
        t1_rectangle1_3.setAutoDraw(True)
    
    # *option1_critical_13* updates
    if option1_critical_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option1_critical_13.frameNStart = frameN  # exact frame index
        option1_critical_13.tStart = t  # local t and not account for scr refresh
        option1_critical_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option1_critical_13, 'tStartRefresh')  # time at next scr refresh
        option1_critical_13.setAutoDraw(True)
    
    # *option2_critical_13* updates
    if option2_critical_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        option2_critical_13.frameNStart = frameN  # exact frame index
        option2_critical_13.tStart = t  # local t and not account for scr refresh
        option2_critical_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(option2_critical_13, 'tStartRefresh')  # time at next scr refresh
        option2_critical_13.setAutoDraw(True)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in testComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "test"-------
for thisComponent in testComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
# check responses
if key_resp_t1_3.keys in ['', [], None]:  # No response was made
    key_resp_t1_3.keys = None
thisExp.addData('key_resp_t1_3.keys',key_resp_t1_3.keys)
if key_resp_t1_3.keys != None:  # we had a response
    thisExp.addData('key_resp_t1_3.rt', key_resp_t1_3.rt)
thisExp.addData('key_resp_t1_3.started', key_resp_t1_3.tStartRefresh)
thisExp.addData('key_resp_t1_3.stopped', key_resp_t1_3.tStopRefresh)
thisExp.nextEntry()
thisExp.addData('t1_zud_3.started', t1_zud_3.tStartRefresh)
thisExp.addData('t1_zud_3.stopped', t1_zud_3.tStopRefresh)
thisExp.addData('t1_triangle1_3.started', t1_triangle1_3.tStartRefresh)
thisExp.addData('t1_triangle1_3.stopped', t1_triangle1_3.tStopRefresh)
thisExp.addData('t1_rectangle1_3.started', t1_rectangle1_3.tStartRefresh)
thisExp.addData('t1_rectangle1_3.stopped', t1_rectangle1_3.tStopRefresh)
thisExp.addData('option1_critical_13.started', option1_critical_13.tStartRefresh)
thisExp.addData('option1_critical_13.stopped', option1_critical_13.tStopRefresh)
thisExp.addData('option2_critical_13.started', option2_critical_13.tStartRefresh)
thisExp.addData('option2_critical_13.stopped', option2_critical_13.tStopRefresh)
# the Routine "test" was not non-slip safe, so reset the non-slip timer
routineTimer.reset()

# ------Prepare to start Routine "end"-------
continueRoutine = True
routineTimer.add(1.000000)
# update component parameters for each repeat
# keep track of which components have finished
endComponents = [thankyou]
for thisComponent in endComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
endClock.reset(-_timeToFirstFrame)  # t0 is time of first possible flip
frameN = -1

# -------Run Routine "end"-------
while continueRoutine and routineTimer.getTime() > 0:
    # get current time
    t = endClock.getTime()
    tThisFlip = win.getFutureFlipTime(clock=endClock)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    
    # *thankyou* updates
    if thankyou.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        thankyou.frameNStart = frameN  # exact frame index
        thankyou.tStart = t  # local t and not account for scr refresh
        thankyou.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(thankyou, 'tStartRefresh')  # time at next scr refresh
        thankyou.setAutoDraw(True)
    if thankyou.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > thankyou.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            thankyou.tStop = t  # not accounting for scr refresh
            thankyou.frameNStop = frameN  # exact frame index
            win.timeOnFlip(thankyou, 'tStopRefresh')  # time at next scr refresh
            thankyou.setAutoDraw(False)
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in endComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# -------Ending Routine "end"-------
for thisComponent in endComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
thisExp.addData('thankyou.started', thankyou.tStartRefresh)
thisExp.addData('thankyou.stopped', thankyou.tStopRefresh)

# Flip one final time so any remaining win.callOnFlip() 
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv', delim='auto')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()
